--- std ---
Block {
  Array: 0,
  Bool: 1,
  Box: 2,
  Bytes: 3,
  Error: 4,
  F32: 5,
  F64: 6,
  Float: 7,
  I8: 8,
  I16: 9,
  I32: 10,
  I64: 11,
  Int: 12,
  ISize: 13,
  Opt: 14,
  Slice: 15,
  U8: 16,
  U16: 17,
  U32: 18,
  U64: 19,
  USize: 20,
  Void: 21,
  print: 22,
}
  Token VSpace[1, 1](

)
  Token Comment[3, 1](# Always 1D for now.)
  Token VSpace[3, 21](
)
  Token Comment[4, 1](# Sometime to support ND later or in separate library.)
  Token VSpace[4, 55](
)
  Type
    Token Type[5, 1](type)
    Spaced
      Token HSpace[5, 5]( )
      Token Id[5, 6](Array) @ 0
      Parens
        Token BracketOpen[5, 11]([)
        Token Id[5, 12](Item)
        Token BracketClose[5, 16](])
  Token VSpace[5, 17](
)
  Token Comment[6, 1](# type Array[Item, let size: Int])
  Token VSpace[6, 34](

)
  Type
    Token Type[8, 1](type)
    Token HSpace[8, 5]( )
    Token Id[8, 6](Bool) @ 1
  Token VSpace[8, 10](
)
  Token Comment[9, 1](# type Bool: Opt[Void] # Could be? Array of 0 or 1 (Opt) vs Void as array of 0?)
  Token VSpace[9, 80](
)
  Token Comment[10, 1](# let false = Bool::None)
  Token VSpace[10, 25](
)
  Token Comment[11, 1](# let true = Bool::Some())
  Token VSpace[11, 26](
)
  Token Comment[12, 1](# enum Bool # Maybe?)
  Token VSpace[12, 21](
)
  Token Comment[13, 1](#    False)
  Token VSpace[13, 11](
)
  Token Comment[14, 1](#    True)
  Token VSpace[14, 10](
)
  Token Comment[15, 1](# end)
  Token VSpace[15, 6](

)
  Type
    Token Type[17, 1](type)
    Spaced
      Token HSpace[17, 5]( )
      Token Id[17, 6](Box) @ 2
      Parens
        Token BracketOpen[17, 9]([)
        Token Id[17, 10](Item)
        Token BracketClose[17, 14](])
  Token VSpace[17, 15](
)
  Token Comment[18, 1](# type Box[Item]: Array[Item, 1] ???)
  Token VSpace[18, 37](

)
  Token Comment[20, 1](# TODO Formally, should be Octets.)
  Token VSpace[20, 35](
)
  Token Comment[21, 1](# TODO No force null-terminated here? Just on literals?)
  Token VSpace[21, 56](
)
  Token Comment[22, 1](# TODO Slices won't have )
  Token VSpace[22, 26](
)
  Type
    Token Type[23, 1](type)
    Spaced
      Colon
        Token HSpace[23, 5]( )
        Token Id[23, 6](Bytes) @ 3
        Token Colon[23, 11](:)
        Token HSpace[23, 12]( )
        Token Id[23, 13](Array) @ 0
      Parens
        Token BracketOpen[23, 18]([)
        Token Id[23, 19](U8) @ 16
        Token BracketClose[23, 21](])
  Token VSpace[23, 22](

)
  Token Comment[25, 1](# Somewhat equivalent to U4 but different default stringification.)
  Token VSpace[25, 67](
)
  Token Comment[26, 1](# type Char: U32)
  Token VSpace[26, 17](

)
  Type
    Token Type[28, 1](type)
    Token HSpace[28, 5]( )
    Token Id[28, 6](Error) @ 4
  Token VSpace[28, 11](

)
  Type <F32 @ 5>
    Token Type[30, 1](type)
    Token HSpace[30, 5]( )
    Token Id[30, 6](F32) @ 5
  Token VSpace[30, 9](

)
  Type <F64 @ 6>
    Token Type[32, 1](type)
    Token HSpace[32, 5]( )
    Token Id[32, 6](F64) @ 6
  Token VSpace[32, 9](

)
  Token Comment[34, 1](# Rust default float type.)
  Token VSpace[34, 27](
)
  Type
    Token Type[35, 1](type)
    Assign
      Token HSpace[35, 5]( )
      Token Id[35, 6](Float) @ 7
      Token HSpace[35, 11]( )
      Token Assign[35, 12](=)
      Token HSpace[35, 13]( )
      Token Id[35, 14](F64) @ 6
  Token VSpace[35, 17](

)
  Token Comment[37, 1](# type Function[Input, Output])
  Token VSpace[37, 31](
)
  Token Comment[38, 1](# struct Function[Input, Output, throws: Bool])
  Token VSpace[38, 47](
)
  Token Comment[39, 1](#   # Need specialization for throws or not ...)
  Token VSpace[39, 48](
)
  Token Comment[40, 1](#   call: CFunction[Input: (Void&, ...Input), Output])
  Token VSpace[40, 54](
)
  Token Comment[41, 1](#   data: Void&)
  Token VSpace[41, 16](
)
  Token Comment[42, 1](# end)
  Token VSpace[42, 6](
)
  Token Comment[43, 1](# Input -> Output throws)
  Token VSpace[43, 25](

)
  Type <I8 @ 8>
    Token Type[45, 1](type)
    Token HSpace[45, 5]( )
    Token Id[45, 6](I8) @ 8
  Token VSpace[45, 8](

)
  Type <I16 @ 9>
    Token Type[47, 1](type)
    Token HSpace[47, 5]( )
    Token Id[47, 6](I16) @ 9
  Token VSpace[47, 9](

)
  Type <I32 @ 10>
    Token Type[49, 1](type)
    Token HSpace[49, 5]( )
    Token Id[49, 6](I32) @ 10
  Token VSpace[49, 9](

)
  Type <I64 @ 11>
    Token Type[51, 1](type)
    Token HSpace[51, 5]( )
    Token Id[51, 6](I64) @ 11
  Token VSpace[51, 9](

)
  Token Comment[53, 1](# Rust default integer type, even for 64-bit systems.)
  Token VSpace[53, 54](
)
  Token Comment[54, 1](# TODO(tjp): But it runs higher risk of overflow in math ...)
  Token VSpace[54, 61](
)
  Type
    Token Type[55, 1](type)
    Assign
      Token HSpace[55, 5]( )
      Token Id[55, 6](Int) @ 12
      Token HSpace[55, 9]( )
      Token Assign[55, 10](=)
      Token HSpace[55, 11]( )
      Token Id[55, 12](I32) @ 10
  Token VSpace[55, 15](

)
  Type
    Token Type[57, 1](type)
    Token HSpace[57, 5]( )
    Token Id[57, 6](ISize) @ 13
  Token VSpace[57, 11](

)
  Type
    Token Type[59, 1](type)
    Spaced
      Token HSpace[59, 5]( )
      Token Id[59, 6](Opt) @ 14
      Parens
        Token BracketOpen[59, 9]([)
        Token Id[59, 10](Item)
        Token BracketClose[59, 14](])
  Token VSpace[59, 15](
)
  Token Comment[60, 1](# enum Opt[Item])
  Token VSpace[60, 17](
)
  Token Comment[61, 1](#   None)
  Token VSpace[61, 9](
)
  Token Comment[62, 1](#   Some(Item))
  Token VSpace[62, 15](
)
  Token Comment[63, 1](# end)
  Token VSpace[63, 6](

)
  Token Comment[65, 1](# TODO Can enum be a library-level thing with vararg or tuple generics?)
  Token VSpace[65, 72](
)
  Token Comment[66, 1](# TODO Like variant in c++?)
  Token VSpace[66, 28](
)
  Token Comment[67, 1](# TODO Also, allow arbitary sum types of other types?)
  Token VSpace[67, 54](
)
  Token Comment[68, 1](# enum Result[Item, E: Error])
  Token VSpace[68, 30](
)
  Token Comment[69, 1](#   Ok(Item))
  Token VSpace[69, 13](
)
  Token Comment[70, 1](#   Err(E))
  Token VSpace[70, 11](
)
  Token Comment[71, 1](# end)
  Token VSpace[71, 6](

)
  Token Comment[73, 1](# TODO Slices don't own, and Arrays do? Is that all?)
  Token VSpace[73, 53](
)
  Token Comment[74, 1](# TODO Dimensionality on slices?)
  Token VSpace[74, 33](
)
  Type
    Token Type[75, 1](type)
    Spaced
      Token HSpace[75, 5]( )
      Token Id[75, 6](Slice) @ 15
      Parens
        Token BracketOpen[75, 11]([)
        Token Id[75, 12](Item)
        Token BracketClose[75, 16](])
  Token VSpace[75, 17](

)
  Type <U8 @ 16>
    Token Type[77, 1](type)
    Token HSpace[77, 5]( )
    Token Id[77, 6](U8) @ 16
  Token VSpace[77, 8](

)
  Type <U16 @ 17>
    Token Type[79, 1](type)
    Token HSpace[79, 5]( )
    Token Id[79, 6](U16) @ 17
  Token VSpace[79, 9](

)
  Type <U32 @ 18>
    Token Type[81, 1](type)
    Token HSpace[81, 5]( )
    Token Id[81, 6](U32) @ 18
  Token VSpace[81, 9](

)
  Type <U64 @ 19>
    Token Type[83, 1](type)
    Token HSpace[83, 5]( )
    Token Id[83, 6](U64) @ 19
  Token VSpace[83, 9](

)
  Type
    Token Type[85, 1](type)
    Token HSpace[85, 5]( )
    Token Id[85, 6](USize) @ 20
  Token VSpace[85, 11](

)
  Token Comment[87, 1](# TODO Or is Unit better? Or call it Void but use as Unit?)
  Token VSpace[87, 59](
)
  Token Comment[88, 1](# TODO Just that Unit and Uint are so close. Maybe that's why () as a type?)
  Token VSpace[88, 76](
)
  Type
    Token Type[89, 1](type)
    Token HSpace[89, 5]( )
    Token Id[89, 6](Void) @ 21
  Token VSpace[89, 10](

)
  Def
    Token Def[91, 1](def)
    Assign
      Spaced
        Token HSpace[91, 4]( )
        Token Id[91, 5](print) @ 22
        Arrow
          Parens
            Token ParenOpen[91, 10](()
            Colon
              Token Id[91, 11](line)
              Token Colon[91, 15](:)
              Token HSpace[91, 16]( )
              Token Id[91, 17](Bytes) @ 3
            Token ParenClose[91, 22]())
          Token HSpace[91, 23]( )
          Token Arrow[91, 24](->)
          Token HSpace[91, 26]( )
          Token Id[91, 27](Void) @ 21
      Token HSpace[91, 31]( )
      Token Assign[91, 32](=)
      Token HSpace[91, 33]( )
      Token Extern[91, 34](extern)
  Token VSpace[91, 40](

)
  Token Eof[91, 40]()

--- main ---
Token Eof[1, 1]()
