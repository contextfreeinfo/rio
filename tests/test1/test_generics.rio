fn test_generics() {
  let slirce: Slirce;
  let slorce: Slorce<int> = {items = (:[]int){1, 2, 3}, length = 3};
  let slorce_ref: Slorce<&int> = {items = (:[]&int){slorce.items}, length = 1};
  printf("Generically, %d\n", *slorce_ref[0]);
  let slarb: Slorce<Bar>;
  let slerce: Slerce<int>;
  slerce.boring.thing = 5;
  slerce.goo = {items = &slerce.boring.thing, length = 1};
  slerce.goos = {items = &slerce.goo.items, length = 1};
  printf("Should be %d: %d\n", slerce.boring.thing, slerce.goos[0][0]);
  // Assignment properly succeeds.
  let slarce: Slarce = slorce;
  // Assignment properly fails.
  // slarce = slarb;
  // This should render as test1_Slorce_Hey, and no test1_Slorce_float should
  // even exist.
  let slorce_hey: Slorce<Hey>;
  // And this should both parse and yield a proper type name.
  let slorce_slorce_hey: Slorce<Slorce<Hey>>;
  // Test some functions, too.
  test_generic_functions();
}

typedef Hey = float;

struct Slirce {
  slarce: Slarce;
}

typedef Slarce = Slorce<int>;

struct Slorce<Item> {
  length: usize;
  items: *Item;
}

struct Boring<Thing> {
  thing: Thing;
}

struct Slerce<Goo> {
  // We need to resolve type args in dupe, too.
  goo: Slorce<Goo>;
  goos: Slorce<*Goo>;
  boring: Boring<Goo>;
}

// Should be unresolved here.
// let item: Item;

fn test_generic_functions() {
  // let slarce: Slarce;
  // printf("slarce sum: %d", sum(slarce, slarce));
  printf("int sum: %d\n", sum.<int>(1, 2));
  printf("float sum: %g\n", sum.<float>(1.1, 2.2));
  // printf("int sum: %d", sum(1, 2));
  // printf("float sum: %d", sum(1.1, 2.2));
  // let thing = 2;
  // first((:Slice<int>){});
  // first((:Slice<int>){items = &thing, length = 1});
  // first(Slice.<int>{});
  // first(Slice.<int>{items = &thing, length = 1});
  // first(Slice[int]{});
  // first(Slice[int]{items = &thing, length = 1});
  // first.<int>(Slice.<int>{});
  // first.<int>({});
}

fn sum<Num: int>(x: Num, y: Num) -> Num {
  return x + y;
}

// fn sum(x, y) {
//   return x + y;
// }

// fn sum(x, y) where x: int, y: int {
//   return x + y;
// }

// Deeper generics.
// TODO In generation, optimize all equivalent functions down to single cases?
// TODO That is, from a type checking perspective, these types matter, but they
// TODO could all be replace with `void` from an implementation perspective.
// TODO Maybe could still generate simple wrapper functions for type safety from
// TODO C if wanted ...
fn first<Item>(slice: Slice<Item>) -> Result<&Item, TestErr> {
  if (slice.length) {
    return {kind = Result.Ok, val = &slice[0]};
  } else {
    return {kind = Result.Err, err = TestErr.Crazy};
  }
}
