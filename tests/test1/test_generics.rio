fn test_generics() {
  let slirce: Slirce;
  let slorce: Slorce<int> = {items = (:[]int){1, 2, 3}, length = 3};
  let slorce_ref: Slorce<&int> = {items = (:[]&int){slorce.items}, length = 1};
  printf("Generically, %d\n", *slorce_ref[0]);
  let slarb: Slorce<Bar>;
  // Assignment properly succeeds.
  let slarce: Slarce = slorce;
  // Assignment properly fails.
  // slarce = slarb;
  // This should render as test1_Slorce_Hey, and no test1_Slorce_float should
  // even exist.
  let slorce_hey: Slorce<Hey>;
  // And this should both parse and yield a proper type name.
  let slorce_slorce_hey: Slorce<Slorce<Hey>>;
  // Test some functions, too.
  test_generic_functions();
}

typedef Hey = float;

struct Slirce {
  slarce: Slarce;
}

typedef Slarce = Slorce<int>;

struct Slorce<Item> {
  length: usize;
  items: *Item;
}

// Should be unresolved here.
// let item: Item;

fn test_generic_functions() {
  // let slarce: Slarce;
  // printf("slarce sum: %d", sum(slarce, slarce));
  // printf("int sum: %d", sum.<int>(1, 2));
  // printf("float sum: %d", sum.<float>(1.1, 2.2));
  // printf("int sum: %d", sum(1, 2));
  // printf("float sum: %d", sum(1.1, 2.2));
  // first((:Slice<int>){});
  // first(Slice.<int>{});
  // first.<int>(Slice.<int>{});
  // first.<int>({});
}

fn sum<Num: int>(x: Num, y: Num) -> Num {
  return x + y;
}

// fn sum(x, y) {
//   return x + y;
// }

// fn sum(x, y) where x: int, y: int {
//   return x + y;
// }

// TODO Deeper generics:
fn first<Item>(slice: Slice<Item>) -> Result<&Item, TestErr> {
  return {kind = Result.Ok};
  // return {kind = Result.Ok, val = Item{}};
}
