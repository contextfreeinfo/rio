let gen_buf: *char = NULL;  // No auto init to NULL on globals?

// #define genf(...) buf_printf(gen_buf, __VA_ARGS__)
// #define genlnf(...) (genln(), genf(__VA_ARGS__))

let gen_indent: int;
let gen_pos: SrcPos;

let gen_headers_buf: **const char;

let gen_preamble_str = """// Preamble
#define __USE_MINGW_ANSI_STDIO 1
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif
#ifndef _CRT_NONSTDC_NO_DEPRECATE
#define _CRT_NONSTDC_NO_DEPRECATE
#endif

#if _MSC_VER >= 1900 || __STDC_VERSION__ >= 201112L
// Visual Studio 2015 supports enough C99/C11 features for us.
#else
#error "C11 support required or Visual Studio 2015 or later"
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wvarargs"
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <stdarg.h>
#include <assert.h>

typedef unsigned char uchar;
typedef signed char schar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef long long llong;
typedef unsigned long long ullong;

#ifdef _MSC_VER
#define alignof(x) __alignof(x)
#else
#define alignof(x) __alignof__(x)
#endif

#define va_start_ptr(args, arg) (va_start(*(args), *(arg)))
#define va_copy_ptr(dest, src) (va_copy(*(dest), *(src)))
#define va_end_ptr(args) (va_end(*(args)))

struct Any;
static void va_arg_ptr(va_list *args, struct Any any);
""";

let gen_postamble_str = """
static void va_arg_ptr(va_list *args, Any any) {
  switch (typeid_kind(any.type)) {
  case TypeKind_Bool:
    *(bool *)any.ptr = (bool)va_arg(*args, int);
    break;
  case TypeKind_Char:
    *(char *)any.ptr = (char)va_arg(*args, int);
    break;
  case TypeKind_UChar:
    *(uchar *)any.ptr = (uchar)va_arg(*args, int);
    break;
  case TypeKind_SChar:
    *(schar *)any.ptr = (schar)va_arg(*args, int);
    break;
  case TypeKind_Short:
    *(short *)any.ptr = (short)va_arg(*args, int);
    break;
  case TypeKind_UShort:
    *(ushort *)any.ptr = (ushort)va_arg(*args, int);
    break;
  case TypeKind_Int:
    *(int *)any.ptr = va_arg(*args, int);
    break;
  case TypeKind_UInt:
    *(uint *)any.ptr = va_arg(*args, uint);
    break;
  case TypeKind_Long:
    *(long *)any.ptr = va_arg(*args, long);
    break;
  case TypeKind_ULong:
    *(ulong *)any.ptr = va_arg(*args, ulong);
    break;
  case TypeKind_LLong:
    *(llong *)any.ptr = va_arg(*args, llong);
    break;
  case TypeKind_ULLong:
    *(ullong *)any.ptr = va_arg(*args, ullong);
    break;
  case TypeKind_Float:
    *(float *)any.ptr = (float)va_arg(*args, double);
    break;
  case TypeKind_Double:
    *(double *)any.ptr = va_arg(*args, double);
    break;
  case TypeKind_Func:
  case TypeKind_Ptr:
  case TypeKind_Ref:
    *(void **)any.ptr = va_arg(*args, void *);
    break;
  default:
    assert(0 && "argument type not supported");
    break;
  }
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
""";

fn genln() {
  buf_printf(&gen_buf, "\n%.*s", gen_indent * 2, "                                  ");
  gen_pos.line++;
}

fn is_incomplete_array_typespec(typespec: &Typespec) -> bool {
  return typespec.kind == Typespec.Array && !typespec.num_elems;
}

let char_to_escape: [256]char = {
  ['\0'] = '0',
  ['\n'] = 'n',
  ['\r'] = 'r',
  ['\t'] = 't',
  ['\v'] = 'v',
  ['\b'] = 'b',
  ['\a'] = 'a',
  ['\\'] = '\\',
  ['"'] = '"',
  ['\''] = '\'',
};

fn gen_char(c: char) {
  if (char_to_escape[(:uchar)c]) {
    buf_printf(&gen_buf, "'\\%c'", char_to_escape[(:uchar)c]);
  } else if (isprint(c)) {
    buf_printf(&gen_buf, "'%c'", c);
  } else {
    buf_printf(&gen_buf, "'\\x%X'", (:uchar)c);
  }
}

fn gen_str(str: *const char, multiline: bool) {
  if (multiline) {
    gen_indent++;
    genln();
  }
  buf_printf(&gen_buf, "\"");
  while (*str) {
    let start: *const char = str;
    while (*str && isprint(*str) && !char_to_escape[(:uchar)*str]) {
      str++;
    }
    if (start != str) {
      buf_printf(&gen_buf, "%.*s", str - start, start);
    }
    if (*str) {
      if (char_to_escape[(:uchar)*str]) {
        buf_printf(&gen_buf, "\\%c", char_to_escape[(:uchar)*str]);
        if (str[0] == '\n' && str[1]) {
          buf_printf(&gen_buf, "\"");
          genln(); buf_printf(&gen_buf, "\"");
        }
      } else {
        #assert(!isprint(*str));
        buf_printf(&gen_buf, "\\x%X", (:uchar)*str);
      }
      str++;
    } if;
  } while;
  buf_printf(&gen_buf, "\"");
  if (multiline) {
    gen_indent--;
  }
}

fn gen_sync_pos(pos: SrcPos) {
  if (flag_nosourcemap) {
    return;
  }
  if (gen_pos.line != pos.line || gen_pos.name != pos.name) {
    genln(); buf_printf(&gen_buf, "#line %d", pos.line);
    if (gen_pos.name != pos.name) {
      buf_printf(&gen_buf, " ");
      gen_str(pos.name, false);
    }
    gen_pos = pos;
  } if;
}

fn cdecl_paren(str: *const char, c: char) -> *const char {
  return c && c != '[' ? (:*const char)strf("(%s)", str) : str;
}

fn cdecl_name(type: &Type) -> *const char {
  let type_name: *const char = type_names[type.kind];
  if (type_name) {
    return type_name;
  } else {
    #assert(type.sym);
    return get_gen_name(type.sym);
  }
}

fn type_to_cdecl(type: &Type, str: *const char) -> *char {
  switch (type.kind) {
    Ptr, Ref => {
      return type_to_cdecl(type.base, cdecl_paren(strf("*%s", str), *str));
    }
    Const => {
      return type_to_cdecl(type.base, strf("const %s", cdecl_paren(str, *str)));
    }
    Array => {
      if (type.num_elems == 0) {
        return type_to_cdecl(type.base, cdecl_paren(strf("%s[]", str), *str));
      } else {
        return type_to_cdecl(
          type.base, cdecl_paren(strf("%s[%zu]", str, type.num_elems), *str),
        );
      }
    }
    Func => {
      let result: *char;
      buf_printf(&result, "(*%s)(", str);
      if (type.function.num_params == 0) {
        buf_printf(&result, "void");
      } else {
        for (let i: usize = 0; i < type.function.num_params; i++) {
          buf_printf(
            &result, "%s%s",
            i == 0 ? "" : ", ", type_to_cdecl(type.function.params[i], ""),
          );
        } for;
      } if;
      if (type.function.has_varargs) {
        buf_printf(&result, ", ...");
      }
      buf_printf(&result, ")");
      return type_to_cdecl(type.function.ret, result);
    }
    default => return strf("%s%s%s", cdecl_name(type), *str ? " " : "", str);
  }
}

fn gen_expr_str(expr: &Expr) -> *const char {
  let temp: *char = gen_buf;
  gen_buf = NULL;
  gen_expr(expr);
  let result = gen_buf;
  gen_buf = temp;
  return result;
}

let gen_name_map: Map;

fn get_gen_name_or_default(ptr: &const void, default_name: *const char) -> *const char {
  let name: *const char = map_get(&gen_name_map, ptr);
  if (!name) {
    let sym = get_resolved_sym(ptr);
    if (sym) {
      if (sym.external_name) {
        name = sym.external_name;
      } else if (sym.home_package.external_name) {
        let external_name = sym.home_package.external_name;
        name = strf("%s%s", external_name, sym.name);
      } else {
        name = sym.name;
      }
    } else {
      #assert(default_name);
      name = default_name;
    }
    map_put(&gen_name_map, ptr, (:&void)name);
  } if;
  return name;
}

fn get_gen_name(ptr: &const void) -> *const char {
  return get_gen_name_or_default(ptr, "ERROR");
}

fn typespec_to_cdecl(typespec: &Typespec, str: *const char) -> *char {
  if (!typespec) {
    return strf("void%s%s", *str ? " " : "", str);
  }
  @complete
  switch (typespec.kind) {
    Name => {
      return strf("%s%s%s", get_gen_name(typespec), *str ? " " : "", str);
    }
    Ptr, Ref => return typespec_to_cdecl(
      typespec.base, cdecl_paren(strf("*%s", str), *str),
    );
    Const => return typespec_to_cdecl(
      typespec.base, strf("const %s", cdecl_paren(str, *str)),
    );
    Array => {
      if (typespec.num_elems == 0) {
        return typespec_to_cdecl(
          typespec.base, cdecl_paren(strf("%s[]", str), *str),
        );
      } else {
        return typespec_to_cdecl(typespec.base, cdecl_paren(
          strf("%s[%s]", str, gen_expr_str(typespec.num_elems)), *str,
        ));
      }
    }
    Func => {
      let result: *char = NULL;
      buf_printf(&result, "(*%s)(", str);
      if (typespec.function.num_args == 0) {
        buf_printf(&result, "void");
      } else {
        for (let i: usize = 0; i < typespec.function.num_args; i++) {
          buf_printf(&result, "%s%s", i == 0 ? "" : ", ", typespec_to_cdecl(
            typespec.function.args[i], "",
          ));
        } for;
      } if;
      if (typespec.function.has_varargs) {
        buf_printf(&result, ", ...");
      }
      buf_printf(&result, ")");
      return typespec_to_cdecl(typespec.function.ret, result);
    }
  } switch;
  return NULL;
}

fn gen_func_decl(decl: &Decl) {
  #assert(decl.kind == Decl.Func);
  let result: *char = NULL;
  buf_printf(&result, "%s(", get_gen_name(decl));
  if (decl.function.num_params == 0) {
    buf_printf(&result, "void");
  } else {
    for (let i: usize = 0; i < decl.function.num_params; i++) {
      let param = decl.function.params[i];
      if (i != 0) {
        buf_printf(&result, ", ");
      }
      buf_printf(&result, "%s", typespec_to_cdecl(param.type, param.name));
    } for;
  } if;
  if (decl.function.has_varargs) {
    buf_printf(&result, ", ...");
  }
  buf_printf(&result, ")");
  gen_sync_pos(decl.pos);
  if (decl.function.ret_type) {
    genln(); buf_printf(&gen_buf, "%s", typespec_to_cdecl(decl.function.ret_type, result));
  } else {
    genln(); buf_printf(&gen_buf, "void %s", result);
  }
}

fn gen_reachable(sym: &Sym) -> bool {
  return flag_fullgen || sym.reachable == ReachablePhase.Natural;
}

fn gen_forward_decls() {
  for (let it: *&Sym = sorted_syms; it != buf_end(sorted_syms, sizeof(*sorted_syms)); it++) {
    let sym = *it;
    let decl = sym.decl;
    if (!decl || !gen_reachable(sym)) {
      continue;
    }
    if (is_decl_foreign(decl)) {
      continue;
    }
    if (decl.type_params.length) {
      continue;
    }
    switch (decl.kind) {
      Struct, Union => {
        let name = get_gen_name(sym);
        genln();
        buf_printf(
          &gen_buf, "typedef %s %s %s;",
          decl.aggregate.kind == AggregateKind.Struct ? "struct" : "union",
          name, name,
        );
      }
      default => {}
    }
  } for;
}

fn gen_aggregate_item(item: &AggregateItem) {
  @complete
  if (item.kind == AggregateItem.Field) {
    for (let j: usize = 0; j < item.num_names; j++) {
      gen_sync_pos(item.pos);
      let prefix = "";
      // Skip actually generating void fields.
      // TODO Error on uses of void fields.
      // TODO Error on void fields outside of enum unions.
      // TODO Find a better way to check for void.
      if (item.type.kind == Typespec.Name) {
        let name = get_gen_name(item.type);
        if (name == void_name) {
          prefix = "// ";
        }
      }
      // Generate standard field.
      genln();
      buf_printf(
        &gen_buf, "%s%s;", prefix, typespec_to_cdecl(item.type, item.names[j]),
      );
    } for;
  } else if (item.kind == AggregateItem.Subaggregate) {
    genln();
    buf_printf(
      &gen_buf, "%s {",
      item.subaggregate.kind == AggregateKind.Struct ? "struct" : "union",
    );
    gen_aggregate_items(item.subaggregate);
    genln();
    buf_printf(&gen_buf, "};");
  }
}

fn gen_aggregate_items(aggregate: &Aggregate) {
  gen_indent++;
  for (let i: usize = 0; i < aggregate.num_items; i++) {
    let item = aggregate.items[i];
    gen_aggregate_item(&aggregate.items[i]);
  }
  gen_indent--;
}

fn gen_aggregate(decl: &Decl) {
  #assert(decl.kind == Decl.Struct || decl.kind == Decl.Union);
  if (decl.is_incomplete || decl.type_params.length) {
    return;
  }
  genln();
  buf_printf(
    &gen_buf, "%s %s {",
    decl.aggregate.kind == AggregateKind.Struct ? "struct" : "union",
    get_gen_name(decl),
  );
  gen_aggregate_items(decl.aggregate);
  genln();
  buf_printf(&gen_buf, "};");
}

fn gen_paren_expr(expr: &Expr) {
  buf_printf(&gen_buf, "(");
  gen_expr(expr);
  buf_printf(&gen_buf, ")");
}

fn gen_expr_compound(expr: &Expr) {
  let expected_type = get_resolved_expected_type(expr);
  if (expected_type && !is_ptr_type(expected_type)) {
    buf_printf(&gen_buf, "{");
  } else if (expr.compound.type) {
    buf_printf(&gen_buf, "(%s){", typespec_to_cdecl(expr.compound.type, ""));
  } else {
    buf_printf(&gen_buf, "(%s){", type_to_cdecl(get_resolved_type(expr), ""));
  }
  for (let i: usize = 0; i < expr.compound.num_fields; i++) {
    if (i != 0) {
      buf_printf(&gen_buf, ", ");
    }
    let field = expr.compound.fields[i];
    if (field.kind == CompoundField.Name) {
      buf_printf(&gen_buf, ".%s = ", field.name);
    } else if (field.kind == CompoundField.Index) {
      buf_printf(&gen_buf, "[");
      gen_expr(field.index);
      buf_printf(&gen_buf, "] = ");
    }
    gen_expr(field.init);
  } for;
  if (expr.compound.num_fields == 0) {
    buf_printf(&gen_buf, "0");
  }
  buf_printf(&gen_buf, "}");
}

let typeid_kind_names: [CompilerTypeKind.Num]*const char = {
  [CompilerTypeKind.None] = "TypeKind_None",
  [CompilerTypeKind.Void] = "TypeKind_Void",
  [CompilerTypeKind.Bool] = "TypeKind_Bool",
  [CompilerTypeKind.Char] = "TypeKind_Char",
  [CompilerTypeKind.UChar] = "TypeKind_UChar",
  [CompilerTypeKind.SChar] = "TypeKind_SChar",
  [CompilerTypeKind.Short] = "TypeKind_Short",
  [CompilerTypeKind.UShort] = "TypeKind_UShort",
  [CompilerTypeKind.Int] =  "TypeKind_Int",
  [CompilerTypeKind.UInt] = "TypeKind_UInt",
  [CompilerTypeKind.Long] = "TypeKind_Long",
  [CompilerTypeKind.ULong] = "TypeKind_ULong",
  [CompilerTypeKind.LLong] = "TypeKind_LLong",
  [CompilerTypeKind.ULLong] = "TypeKind_ULLong",
  [CompilerTypeKind.Float] = "TypeKind_Float",
  [CompilerTypeKind.Double] = "TypeKind_Double",
  [CompilerTypeKind.Const] = "TypeKind_Const",
  [CompilerTypeKind.Ptr] = "TypeKind_Ptr",
  [CompilerTypeKind.Ref] = "TypeKind_Ref",
  [CompilerTypeKind.Array] = "TypeKind_Array",
  [CompilerTypeKind.Struct] = "TypeKind_Struct",
  [CompilerTypeKind.Union] = "TypeKind_Union",
  [CompilerTypeKind.Func] = "TypeKind_Func",
};

fn typeid_kind_name(type: &Type) -> *const char {
  if (type.kind < CompilerTypeKind.Num) {
    let name = typeid_kind_names[type.kind];
    if (name) {
      return name;
    }
  }
  return "TypeKind_None";
}

fn is_excluded_typeinfo(type: &Type) -> bool {
  while (type.kind == CompilerTypeKind.Array || type.kind == CompilerTypeKind.Const || is_ptr_type(type)) {
    type = type.base;
  }
  if (type.sym) {
    return !gen_reachable(type.sym);
  } else {
    return !type.sym && (type.kind == CompilerTypeKind.Struct || type.kind == CompilerTypeKind.Union);
  }
}

fn gen_typeid(type: &Type) {
  if (type.size == 0 || is_excluded_typeinfo(type)) {
    buf_printf(&gen_buf, "TYPEID0(%d, %s)", type.typeid, typeid_kind_name(type));
  } else {
    buf_printf(&gen_buf, "TYPEID(%d, %s, %s)", type.typeid, typeid_kind_name(type), type_to_cdecl(type, ""));
  }
}

fn gen_expr(expr: &Expr) {
  @complete
  switch (expr.kind) {
    Paren => {
      buf_printf(&gen_buf, "(");
      gen_expr(expr.paren.expr);
      buf_printf(&gen_buf, ")");
    }
    Int => {
      let suffix_name: *const char = token_suffix_names[expr.int_lit.suffix];
      switch (expr.int_lit.mod) {
        Bin, Hex => {
          buf_printf(&gen_buf, "0x%llx%s", expr.int_lit.val, suffix_name);
        }
        Oct => buf_printf(&gen_buf, "0%llo%s", expr.int_lit.val, suffix_name);
        Char => gen_char((:char)expr.int_lit.val);
        default => {
          buf_printf(&gen_buf, "%llu%s", expr.int_lit.val, suffix_name);
        }
      }
    }
    Float => {
      let is_double = expr.float_lit.suffix == TokenSuffix.D;
      let len: usize = expr.float_lit.end - expr.float_lit.start;
      buf_printf(
        &gen_buf, "%.*s%s",
        is_double ? len-1 : len, expr.float_lit.start, is_double ? "" : "f",
      );
    }
    Str => {
      gen_str(expr.str_lit.val, expr.str_lit.mod == TokenMod.Multiline);
    }
    Name => {
      buf_printf(&gen_buf, "%s", get_gen_name_or_default(expr, expr.name));
    }
    Cast => {
      buf_printf(&gen_buf, "(%s)(", typespec_to_cdecl(expr.cast.type, ""));
      gen_expr(expr.cast.expr);
      buf_printf(&gen_buf, ")");
    }
    Call => {
      let sym = get_resolved_sym(expr.call.expr);
      if (sym && sym.kind == Sym.Type) {
        buf_printf(&gen_buf, "(%s)", get_gen_name(sym));
      } else {
        gen_expr(expr.call.expr);
      }
      buf_printf(&gen_buf, "(");
      for (let i: usize = 0; i < expr.call.num_args; i++) {
        if (i != 0) {
          buf_printf(&gen_buf, ", ");
        }
        gen_expr(expr.call.args[i]);
      }
      buf_printf(&gen_buf, ")");
    }
    Index => {
      gen_expr(expr.index.expr);
      buf_printf(&gen_buf, "[");
      gen_expr(expr.index.index);
      buf_printf(&gen_buf, "]");
    }
    Field => {
      let sym = get_resolved_sym(expr);
      if (sym) {
        buf_printf(&gen_buf, "(%s)", get_gen_name(sym));
      } else {
        gen_expr(expr.field.expr);
        let type = unqualify_type(get_resolved_type(expr.field.expr));
        buf_printf(
          &gen_buf, "%s%s", is_ptr_type(type) ? "->" : ".", expr.field.name,
        );
      }
    }
    Compound => gen_expr_compound(expr);
    Unary => {
      buf_printf(&gen_buf, "%s(", token_kind_name(expr.unary.op));
      gen_expr(expr.unary.expr);
      buf_printf(&gen_buf, ")");
    }
    Binary => {
      buf_printf(&gen_buf, "(");
      gen_expr(expr.binary.left);
      buf_printf(&gen_buf, ") %s (", token_kind_name(expr.binary.op));
      gen_expr(expr.binary.right);
      buf_printf(&gen_buf, ")");
    }
    Ternary => {
      buf_printf(&gen_buf, "(");
      gen_expr(expr.ternary.cond);
      buf_printf(&gen_buf, " ? ");
      gen_expr(expr.ternary.then_expr);
      buf_printf(&gen_buf, " : ");
      gen_expr(expr.ternary.else_expr);
      buf_printf(&gen_buf, ")");
    }
    SizeofExpr => {
      buf_printf(&gen_buf, "sizeof(");
      gen_expr(expr.sizeof_expr);
      buf_printf(&gen_buf, ")");
    }
    SizeofType => buf_printf(
      &gen_buf, "sizeof(%s)", typespec_to_cdecl(expr.sizeof_type, ""),
    );
    AlignofExpr => buf_printf(&gen_buf, "alignof(%s)", type_to_cdecl(
      get_resolved_type(expr.alignof_expr), "",
    ));
    AlignofType => buf_printf(
      &gen_buf, "alignof(%s)", typespec_to_cdecl(expr.alignof_type, ""),
    );
    TypeofExpr => {
      let type = get_resolved_type(expr.typeof_expr);
      #assert(type.typeid);
      gen_typeid(type);
    }
    TypeofType => {
      let type = get_resolved_type(expr.typeof_type);
      #assert(type.typeid);
      gen_typeid(type);
    }
    Offsetof => buf_printf(
      &gen_buf, "offsetof(%s, %s)",
      typespec_to_cdecl(expr.offsetof_field.type, ""),
      expr.offsetof_field.name,
    );
    Modify => {
      if (!expr.modify.post) {
        buf_printf(&gen_buf, "%s", token_kind_name(expr.modify.op));
      }
      gen_paren_expr(expr.modify.expr);
      if (expr.modify.post) {
        buf_printf(&gen_buf, "%s", token_kind_name(expr.modify.op));
      }
    }
  }
}

fn gen_stmt_block(block: StmtList) {
  buf_printf(&gen_buf, "{");
  gen_indent++;
  for (let i: usize = 0; i < block.num_stmts; i++) {
    gen_stmt(block.stmts[i]);
  }
  gen_indent--;
  genln(); buf_printf(&gen_buf, "}");
}

fn gen_simple_stmt(stmt: &Stmt) {
  @complete
  switch (stmt.kind) {
    Expr => gen_expr(stmt.expr);
    Init => {
      if (stmt.init.type) {
        let init_typespec = stmt.init.type;
        if (is_incomplete_array_typespec(stmt.init.type)) {
          let size = new_expr_int(
            init_typespec.pos,
            get_resolved_type(stmt.init.expr).num_elems,
            0, 0,
          );
          init_typespec =
            new_typespec_array(init_typespec.pos, init_typespec.base, size);
        }
        buf_printf(
          &gen_buf, "%s = ", typespec_to_cdecl(stmt.init.type, stmt.init.name),
        );
        if (stmt.init.expr) {
          gen_expr(stmt.init.expr);
        } else {
          buf_printf(&gen_buf, "{0}");
        }
      } else {
        buf_printf(&gen_buf, "%s = ", type_to_cdecl(
          unqualify_type(get_resolved_type(stmt.init.expr)), stmt.init.name,
        ));
        gen_expr(stmt.init.expr);
      }
    }
    Assign => {
      gen_expr(stmt.assign.left);
      buf_printf(&gen_buf, " %s ", token_kind_name(stmt.assign.op));
      gen_expr(stmt.assign.right);
    }
  }
}

fn is_char_lit(expr: &Expr) -> bool {
  return expr.kind == Expr.Int && expr.int_lit.mod == TokenMod.Char;
}

fn gen_stmt(stmt: &Stmt) {
  gen_sync_pos(stmt.pos);
  switch (stmt.kind) {
    Return => {
      genln();
      buf_printf(&gen_buf, "return");
      if (stmt.expr) {
        buf_printf(&gen_buf, " ");
        gen_expr(stmt.expr);
      }
      buf_printf(&gen_buf, ";");
    }
    Break => {
      genln();
      buf_printf(&gen_buf, "break;");
    }
    Continue => {
      genln();
      buf_printf(&gen_buf, "continue;");
    }
    Block => {
      if (stmt.block.num_stmts) {
        genln();
        gen_stmt_block(stmt.block);
      }
    }
    Close => {}
    Note => {
      if (stmt.note.name == assert_name) {
        genln(); buf_printf(&gen_buf, "assert(");
        #assert(stmt.note.num_args == 1);
        gen_expr(stmt.note.args[0].expr);
        buf_printf(&gen_buf, ");");
      }
    }
    If => {
      if (stmt.if_stmt.init) {
        genln(); buf_printf(&gen_buf, "{");
        gen_indent++;
        gen_stmt(stmt.if_stmt.init);
      }
      gen_sync_pos(stmt.pos);
      genln(); buf_printf(&gen_buf, "if (");
      if (stmt.if_stmt.cond) {
        gen_expr(stmt.if_stmt.cond);
      } else {
        buf_printf(&gen_buf, "%s", stmt.if_stmt.init.init.name);
      }
      buf_printf(&gen_buf, ") ");
      gen_stmt_block(stmt.if_stmt.then_block);
      for (let i: usize = 0; i < stmt.if_stmt.num_elseifs; i++) {
        let elseif = stmt.if_stmt.elseifs[i];
        buf_printf(&gen_buf, " else if (");
        gen_expr(elseif.cond);
        buf_printf(&gen_buf, ") ");
        gen_stmt_block(elseif.block);
      }
      if (stmt.if_stmt.else_block.stmts) {
        buf_printf(&gen_buf, " else ");
        gen_stmt_block(stmt.if_stmt.else_block);
      } else {
        let complete_note = get_stmt_note(stmt, complete_name);
        if (complete_note) {
          buf_printf(&gen_buf, " else {");
          gen_indent++;
          gen_sync_pos(complete_note.pos);
          genln();
          buf_printf(
            &gen_buf,
            "assert(\"@complete if/elseif chain failed to handle case\" && 0);",
          );
          gen_indent--;
          genln();
          buf_printf(&gen_buf, "}");
        } if;
      } if;
      if (stmt.if_stmt.init) {
        gen_indent--;
        genln(); buf_printf(&gen_buf, "}");
      }
    }
    While => {
      genln(); buf_printf(&gen_buf, "while (");
      gen_expr(stmt.while_stmt.cond);
      buf_printf(&gen_buf, ") ");
      gen_stmt_block(stmt.while_stmt.block);
    }
    DoWhile => {
      genln(); buf_printf(&gen_buf, "do ");
      gen_stmt_block(stmt.while_stmt.block);
      buf_printf(&gen_buf, " while (");
      gen_expr(stmt.while_stmt.cond);
      buf_printf(&gen_buf, ");");
    }
    For => {
      genln(); buf_printf(&gen_buf, "for (");
      if (stmt.for_stmt.init) {
        gen_simple_stmt(stmt.for_stmt.init);
      }
      buf_printf(&gen_buf, ";");
      if (stmt.for_stmt.cond) {
        buf_printf(&gen_buf, " ");
        gen_expr(stmt.for_stmt.cond);
      }
      buf_printf(&gen_buf, ";");
      if (stmt.for_stmt.next) {
        buf_printf(&gen_buf, " ");
        gen_simple_stmt(stmt.for_stmt.next);
      }
      buf_printf(&gen_buf, ") ");
      gen_stmt_block(stmt.for_stmt.block);
    }
    Switch => {
      genln(); buf_printf(&gen_buf, "switch (");
      gen_expr(stmt.switch_stmt.expr);
      buf_printf(&gen_buf, ") {");
      let has_default = false;
      for (let i: usize = 0; i < stmt.switch_stmt.num_cases; i++) {
        let switch_case = stmt.switch_stmt.cases[i];
        for (let j: usize = 0; j < switch_case.num_patterns; j++) {
          let pattern = switch_case.patterns[j];
          if (pattern.is_default) {
            has_default = true;
            genln(); buf_printf(&gen_buf, "default:");
          } else if (pattern.end) {
            let start_val = get_resolved_val(pattern.start);
            let end_val = get_resolved_val(pattern.end);
            if (is_char_lit(pattern.start) && is_char_lit(pattern.end)) {
              genln();
              for (let c = (:int)start_val.ll; c <= (:int)end_val.ll; c++) {
                buf_printf(&gen_buf, "case ");
                gen_char(c);
                buf_printf(&gen_buf, ": ");
              }
            } else {
              genln(); buf_printf(&gen_buf, "// ");
              gen_expr(pattern.start);
              buf_printf(&gen_buf, "...");
              gen_expr(pattern.end);
              genln();
              for (let ll: llong = start_val.ll; ll <= end_val.ll; ll++) {
                buf_printf(&gen_buf, "case %lld: ", ll);
              }
            }
          } else {
            genln(); buf_printf(&gen_buf, "case ");
            gen_expr(pattern.start);
            buf_printf(&gen_buf, ":");
          }
        } for;
        buf_printf(&gen_buf, " ");
        buf_printf(&gen_buf, "{");
        gen_indent++;
        let block = &switch_case.block;
        if (block.num_stmts == 1) {
          // Clean block nesting for the case of a single block.
          // We're already inside on of those.
          let first = block.stmts[0];
          if (first.kind == Stmt.Block) {
            block = &first.block;
          }
        }
        for (let j: usize = 0; j < block.num_stmts; j++) {
          gen_stmt(block.stmts[j]);
        }
        genln(); buf_printf(&gen_buf, "break;");
        gen_indent--;
        genln(); buf_printf(&gen_buf, "}");
      } for;
      if (!has_default) {
        let note = get_stmt_note(stmt, complete_name);
        if (note) {
          genln();
          buf_printf(&gen_buf, "default:");
          gen_indent++;
          genln();
          buf_printf(
            &gen_buf,
            "assert(\"@complete switch failed to handle case\" && 0);",
          );
          genln();
          buf_printf(&gen_buf, "break;");
          gen_indent--;
        } if;
      } if;
      genln(); buf_printf(&gen_buf, "}");
    }
    Label => {
      genln();
      buf_printf(&gen_buf, "%s: ;", stmt.label);
    }
    Goto => {
      genln();
      buf_printf(&gen_buf, "goto %s;", stmt.label);
    }
    default => {
      genln();
      gen_simple_stmt(stmt);
      buf_printf(&gen_buf, ";");
    }
  }
}

fn gen_decl(sym: &Sym) {
  let decl = sym.decl;
  if (!decl || is_decl_foreign(decl)) {
    return;
  }
  gen_sync_pos(decl.pos);
  @complete
  switch (decl.kind) {
    Const => {
      genln(); buf_printf(&gen_buf, "#define %s (", get_gen_name(sym));
      if (decl.const_decl.type) {
        buf_printf(
          &gen_buf, "(%s)(", typespec_to_cdecl(decl.const_decl.type, ""),
        );
      }
      gen_expr(decl.const_decl.expr);
      if (decl.const_decl.type) {
        buf_printf(&gen_buf, ")");
      }
      buf_printf(&gen_buf, ")");
    }
    Var => {
      genln(); buf_printf(&gen_buf, "extern ");
      if (
        decl.var_decl.type &&
        !is_incomplete_array_typespec(decl.var_decl.type)
      ) {
        buf_printf(&gen_buf, "%s", typespec_to_cdecl(
          decl.var_decl.type, get_gen_name(sym),
        ));
      } else {
        buf_printf(&gen_buf, "%s", type_to_cdecl(sym.type, get_gen_name(sym)));
      }
      buf_printf(&gen_buf, ";");
    }
    Func => {
      gen_func_decl(decl);
      buf_printf(&gen_buf, ";");
    }
    Struct, Union => gen_aggregate(decl);
    Typedef => {
      genln();
      buf_printf(&gen_buf, "typedef %s;", typespec_to_cdecl(
        decl.typedef_decl.type, get_gen_name(sym),
      ));
    }
    Enum => {
      if (decl.enum_decl.type) {
        genln();
        buf_printf(&gen_buf, "typedef %s;", typespec_to_cdecl(
          decl.enum_decl.type, get_gen_name(decl),
        ));
      } else {
        genln();
        buf_printf(&gen_buf, "typedef int %s;", get_gen_name(decl));
      }
    }
    Import => {}
  }
  genln();
}

fn gen_sorted_decls() {
  for (let i: usize = 0; i < buf_len(sorted_syms); i++) {
    if (sorted_syms[i].reachable == ReachablePhase.Natural) {
      gen_decl(sorted_syms[i]);
    }
  }
}

fn gen_defs() {
  for (let it: *&Sym = sorted_syms; it != buf_end(sorted_syms, sizeof(*sorted_syms)); it++) {
    let sym = *it;
    let decl = sym.decl;
    if (sym.state != SymState.Resolved || !decl || is_decl_foreign(decl) || decl.is_incomplete || sym.reachable != ReachablePhase.Natural) {
      continue;
    }
    if (decl.kind == Decl.Func) {
      gen_func_decl(decl);
      buf_printf(&gen_buf, " ");
      gen_stmt_block(decl.function.block);
      genln();
    } else if (decl.kind == Decl.Var) {
      if (decl.var_decl.type && !is_incomplete_array_typespec(decl.var_decl.type)) {
        genln(); buf_printf(&gen_buf, "%s", typespec_to_cdecl(decl.var_decl.type, get_gen_name(sym)));
      } else {
        genln(); buf_printf(&gen_buf, "%s", type_to_cdecl(sym.type, get_gen_name(sym)));
      }
      if (decl.var_decl.expr) {
        buf_printf(&gen_buf, " = ");
        gen_expr(decl.var_decl.expr);
      }
      buf_printf(&gen_buf, ";");
    } if;
  } for;
}

let gen_foreign_headers_map: Map;
let gen_foreign_headers_buf: **const char;

fn add_foreign_header(name: *const char) {
  name = str_intern(name);
  if (!map_get(&gen_foreign_headers_map, name)) {
    map_put(&gen_foreign_headers_map, name, (:&void)1);
    buf_push((:*&void)&gen_foreign_headers_buf, &name, sizeof(name));
  }
}

let gen_foreign_sources_buf: **const char;

fn add_foreign_source(name: *const char) {
  let interned = str_intern(name);
  buf_push((:*&void)&gen_foreign_sources_buf, &interned, sizeof(interned));
}

fn gen_include(path: *const char) {
  genln(); buf_printf(&gen_buf, "#include ");
  if (*path == '<') {
    buf_printf(&gen_buf, "%s", path);
  } else {
    gen_str(path, false);
  }
}

fn gen_foreign_headers() {
  if (gen_foreign_headers_buf) {
    genln(); buf_printf(&gen_buf, "// Foreign header files");
    for (let i: usize = 0; i < buf_len(gen_foreign_headers_buf); i++) {
      gen_include(gen_foreign_headers_buf[i]);
    }
  }
}

fn gen_foreign_sources() {
  for (let i: usize = 0; i < buf_len(gen_foreign_sources_buf); i++) {
    gen_include(gen_foreign_sources_buf[i]);
  }
}

let gen_sources_buf: **const char;

fn put_include_path(path: [MAX_PATH]char, package: &Package, filename: *const char) {
  if (*filename == '<') {
    path_copy(path, filename);
  } else {
    path_copy(path, package.full_path);
    path_join(path, filename);
    path_absolute(path);
  }
}

let gen_preamble_buf: *char;
let gen_postamble_buf: *char;

fn preprocess_package(package: &Package) {
  if (!package.external_name) {
    let external_name: *char = NULL;
    for (let ptr: *const char = package.path; *ptr; ptr++) {
      buf_printf(&external_name, "%c", *ptr == '/' ? '_' : *ptr);
    }
    buf_printf(&external_name, "_");
    package.external_name = str_intern(external_name);
  }
  let header_name = str_intern("header");
  let source_name = str_intern("source");
  let preamble_name = str_intern("preamble");
  let postamble_name = str_intern("postamble");
  for (let i: usize = 0; i < package.num_decls; i++) {
    let decl = package.decls[i];
    if (decl.kind != Decl.Note) {
      continue;
    }
    let note = decl.note;
    if (note.name == foreign_name) {
      for (let k: usize = 0; k < note.num_args; k++) {
        let arg = note.args[k];
        let expr = note.args[k].expr;
        if (expr.kind != Expr.Str) {
          fatal_error(decl.pos, "#foreign argument must be a string");
        }
        let str = expr.str_lit.val;
        if (arg.name == header_name) {
          let path: [MAX_PATH]char;
          put_include_path(path, package, str);
          add_foreign_header(path);
        } else if (arg.name == source_name) {
          let path: [MAX_PATH]char;
          put_include_path(path, package, str);
          add_foreign_source(path);
        } else if (arg.name == preamble_name) {
          buf_printf(&gen_preamble_buf, "%s\n", str);
        } else if (arg.name == postamble_name) {
          buf_printf(&gen_postamble_buf, "%s\n", str);
        } else {
          fatal_error(decl.pos, "Unknown #foreign named argument '%s'", arg.name);
        }
      } for;
    } if;
  } for;
}

fn preprocess_packages() {
  for (let i: usize = 0; i < buf_len(package_list); i++) {
    preprocess_package(package_list[i]);
  }
}

fn gen_typeinfo_header(kind: *const char, type: &Type) {
  if (type_sizeof(type) == 0) {
    buf_printf(&gen_buf, "&(TypeInfo){%s, .size = 0, .align = 0", kind);
  } else {
    let ctype = type_to_cdecl(type, "");
    buf_printf(&gen_buf, "&(TypeInfo){%s, .size = sizeof(%s), .align = alignof(%s)", kind, ctype, ctype);
  }
}

fn gen_typeinfo_fields(type: &Type) {
  gen_indent++;
  for (let i: usize = 0; i < type.aggregate.num_fields; i++) {
    let field = type.aggregate.fields[i];
    genln(); buf_printf(&gen_buf, "{");
    gen_str(field.name, false);
    buf_printf(&gen_buf, ", .type = ");
    gen_typeid(field.type);
    if (!is_generic_type(type)) {
      buf_printf(
        &gen_buf, ", .offset = offsetof(%s, %s)",
        get_gen_name(type.sym), field.name,
      );
    }
    buf_printf(&gen_buf, "},");
  }
  gen_indent--;
}

// TODO This could be a macro if we had such macros.
fn gen_typeinfo_case(
  buf: &*char, item_name: *const char, type_name: *const char,
) {
  buf_printf(
    buf, "&(TypeInfo){%s, .size = sizeof(%s), .align = sizeof(%s), .name = ",
    item_name, type_name, type_name,
  );
  gen_str(type_name, false);
  buf_printf(buf, "},");
}

fn gen_typeinfo(type: &Type) {
  switch (type.kind) {
    Bool => gen_typeinfo_case(&gen_buf, "TypeKind_Bool", "bool");
    Char => gen_typeinfo_case(&gen_buf, "TypeKind_Char", "char");
    UChar => gen_typeinfo_case(&gen_buf, "TypeKind_UChar", "uchar");
    SChar => gen_typeinfo_case(&gen_buf, "TypeKind_SChar", "schar");
    Short => gen_typeinfo_case(&gen_buf, "TypeKind_Short", "short");
    UShort => gen_typeinfo_case(&gen_buf, "TypeKind_UShort", "ushort");
    Int => gen_typeinfo_case(&gen_buf, "TypeKind_Int", "int");
    UInt => gen_typeinfo_case(&gen_buf, "TypeKind_UInt", "uint");
    Long => gen_typeinfo_case(&gen_buf, "TypeKind_Long", "long");
    ULong => gen_typeinfo_case(&gen_buf, "TypeKind_ULong", "ulong");
    LLong => gen_typeinfo_case(&gen_buf, "TypeKind_LLong", "llong");
    ULLong => gen_typeinfo_case(&gen_buf, "TypeKind_ULLong", "ullong");
    Float => gen_typeinfo_case(&gen_buf, "TypeKind_Float", "float");
    Double => gen_typeinfo_case(&gen_buf, "TypeKind_Double", "double");
    Void => {
      buf_printf(
        &gen_buf,
        "&(TypeInfo){TypeKind_Void, .name = \"void\", .size = 0, .align = 0},",
      );
    }
    Ptr => {
      buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Ptr, .size = sizeof(void *), .align = alignof(void *), .base = ");
      gen_typeid(type.base);
      buf_printf(&gen_buf, "},");
    }
    Ref => {
      buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Ref, .size = sizeof(void *), .align = alignof(void *), .base = ");
      gen_typeid(type.base);
      buf_printf(&gen_buf, "},");
    }
    Const => {
      gen_typeinfo_header("TypeKind_Const", type);
      buf_printf(&gen_buf, ", .base = ");
      gen_typeid(type.base);
      buf_printf(&gen_buf, "},");
    }
    Array => {
      if (is_incomplete_array_type(type)) {
        buf_printf(&gen_buf, "NULL, // Incomplete array type");
      } else {
        gen_typeinfo_header("TypeKind_Array", type);
        buf_printf(&gen_buf, ", .base = ");
        gen_typeid(type.base);
        buf_printf(&gen_buf, ", .count = %d},", type.num_elems);
      }
    }
    Struct, Union => {
      gen_typeinfo_header(
        type.kind == CompilerTypeKind.Struct ?
          "TypeKind_Struct" : "TypeKind_Union",
        type,
      );
      buf_printf(&gen_buf, ", .name = ");
      gen_str(get_gen_name(type.sym), false);
      buf_printf(
        &gen_buf, ", .num_fields = %d, .fields = (TypeFieldInfo[]) {",
        type.aggregate.num_fields,
      );
      gen_typeinfo_fields(type);
      genln();
      buf_printf(&gen_buf, "}},");
    }
    Func => buf_printf(&gen_buf, "NULL, // Function");
    Enum => buf_printf(&gen_buf, "NULL, // Enum");
    Incomplete => {
      buf_printf(&gen_buf, "NULL, // Incomplete: %s", get_gen_name(type.sym));
    }
    default => buf_printf(&gen_buf, "NULL, // Unhandled");
  }
}

// #undef CASE

fn gen_typeinfos() {
  genln(); buf_printf(&gen_buf, "#define TYPEID0(index, kind) ((ullong)(index) | ((ullong)(kind) << 24))");
  genln(); buf_printf(&gen_buf, "#define TYPEID(index, kind, ...) ((ullong)(index) | ((ullong)sizeof(__VA_ARGS__) << 32) | ((ullong)(kind) << 24))");
  genln();
  if (flag_notypeinfo) {
    genln(); buf_printf(&gen_buf, "int num_typeinfos;");
    genln(); buf_printf(&gen_buf, "const TypeInfo **typeinfos;");
  } else {
    let num_typeinfos = next_typeid;
    genln(); buf_printf(&gen_buf, "const TypeInfo *typeinfo_table[%d] = {", num_typeinfos);
    gen_indent++;
    for (let typeid: int = 0; typeid < num_typeinfos; typeid++) {
      genln(); buf_printf(&gen_buf, "[%d] = ", typeid);
      let type = get_type_from_typeid(typeid);
      if (type && !is_excluded_typeinfo(type)) {
        gen_typeinfo(type);
      } else {
        buf_printf(&gen_buf, "NULL, // No associated type");
      }
    } for;
    gen_indent--;
    genln(); buf_printf(&gen_buf, "};");
    genln();
    genln(); buf_printf(&gen_buf, "int num_typeinfos = %d;", num_typeinfos);
    genln(); buf_printf(&gen_buf, "const TypeInfo **typeinfos = (const TypeInfo **)typeinfo_table;");
  } if;
}

fn gen_package_external_names() {
  for (let i: usize = 0; i < buf_len(package_list); i++) {
  }
}

fn gen_preamble() {
  buf_printf(&gen_buf, "%s", gen_preamble_str);
  if (gen_preamble_buf) {
    genln();
    genln(); buf_printf(&gen_buf, "// Foreign preamble");
    genln(); buf_printf(&gen_buf, "%s", gen_preamble_buf);
  }
}

fn gen_postamble() {
  buf_printf(&gen_buf, "%s", gen_postamble_str);
  if (gen_postamble_buf) {
    genln();
    genln(); buf_printf(&gen_buf, "// Foreign postamble");
    genln(); buf_printf(&gen_buf, "%s", gen_postamble_buf);
  }
}

fn gen_all() {
  preprocess_packages();
  gen_buf = NULL;
  gen_preamble();
  gen_foreign_headers();
  genln();
  genln(); buf_printf(&gen_buf, "// Forward declarations");
  gen_forward_decls();
  genln();
  genln(); buf_printf(&gen_buf, "// Sorted declarations");
  gen_sorted_decls();
  genln(); buf_printf(&gen_buf, "// Typeinfo");
  gen_typeinfos();
  genln();
  genln(); buf_printf(&gen_buf, "// Definitions");
  gen_defs();
  genln(); buf_printf(&gen_buf, "// Foreign source files");
  gen_foreign_sources();
  genln();
  gen_postamble();
}
