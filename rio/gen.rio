let gen_buf: *char = NULL;  // No auto init to NULL on globals?

// #define genf(...) buf_printf(gen_buf, __VA_ARGS__)
// #define genlnf(...) (genln(), genf(__VA_ARGS__))

let gen_indent: int;
let gen_pos: SrcPos;

let gen_headers_buf: **const char;

let gen_preamble_str = """// Preamble
#define __USE_MINGW_ANSI_STDIO 1
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif
#ifndef _CRT_NONSTDC_NO_DEPRECATE
#define _CRT_NONSTDC_NO_DEPRECATE
#endif

#if _MSC_VER >= 1900 || __STDC_VERSION__ >= 201112L
// Visual Studio 2015 supports enough C99/C11 features for us.
#else
#error "C11 support required or Visual Studio 2015 or later"
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wvarargs"
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <stdarg.h>
#include <assert.h>

typedef unsigned char uchar;
typedef signed char schar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef long long llong;
typedef unsigned long long ullong;

#ifdef _MSC_VER
#define alignof(x) __alignof(x)
#else
#define alignof(x) __alignof__(x)
#endif

#define va_start_ptr(args, arg) (va_start(*(args), *(arg)))
#define va_copy_ptr(dest, src) (va_copy(*(dest), *(src)))
#define va_end_ptr(args) (va_end(*(args)))

struct Any;
static void va_arg_ptr(va_list *args, struct Any any);
""";

let gen_postamble_str = """
static void va_arg_ptr(va_list *args, Any any) {
  switch (typeid_kind(any.type)) {
  case TypeKind_Bool:
    *(bool *)any.ptr = (bool)va_arg(*args, int);
    break;
  case TypeKind_Char:
    *(char *)any.ptr = (char)va_arg(*args, int);
    break;
  case TypeKind_UChar:
    *(uchar *)any.ptr = (uchar)va_arg(*args, int);
    break;
  case TypeKind_SChar:
    *(schar *)any.ptr = (schar)va_arg(*args, int);
    break;
  case TypeKind_Short:
    *(short *)any.ptr = (short)va_arg(*args, int);
    break;
  case TypeKind_UShort:
    *(ushort *)any.ptr = (ushort)va_arg(*args, int);
    break;
  case TypeKind_Int:
    *(int *)any.ptr = va_arg(*args, int);
    break;
  case TypeKind_UInt:
    *(uint *)any.ptr = va_arg(*args, uint);
    break;
  case TypeKind_Long:
    *(long *)any.ptr = va_arg(*args, long);
    break;
  case TypeKind_ULong:
    *(ulong *)any.ptr = va_arg(*args, ulong);
    break;
  case TypeKind_LLong:
    *(llong *)any.ptr = va_arg(*args, llong);
    break;
  case TypeKind_ULLong:
    *(ullong *)any.ptr = va_arg(*args, ullong);
    break;
  case TypeKind_Float:
    *(float *)any.ptr = (float)va_arg(*args, double);
    break;
  case TypeKind_Double:
    *(double *)any.ptr = va_arg(*args, double);
    break;
  case TypeKind_Func:
  case TypeKind_Ptr:
  case TypeKind_Ref:
    *(void **)any.ptr = va_arg(*args, void *);
    break;
  default:
    assert(0 && "argument type not supported");
    break;
  }
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
""";

fn genln() {
  buf_printf(&gen_buf, "\n%.*s", gen_indent * 2, "                                  ");
  gen_pos.line++;
}

fn is_incomplete_array_typespec(typespec: &Typespec) -> bool {
  return typespec.kind == Typespec.Array && !typespec.num_elems;
}

let char_to_escape: [256]char = {
  ['\0'] = '0',
  ['\n'] = 'n',
  ['\r'] = 'r',
  ['\t'] = 't',
  ['\v'] = 'v',
  ['\b'] = 'b',
  ['\a'] = 'a',
  ['\\'] = '\\',
  ['"'] = '"',
  ['\''] = '\'',
};

fn gen_char(c: char) {
  if (char_to_escape[(:uchar)c]) {
    buf_printf(&gen_buf, "'\\%c'", char_to_escape[(:uchar)c]);
  } else if (isprint(c)) {
    buf_printf(&gen_buf, "'%c'", c);
  } else {
    buf_printf(&gen_buf, "'\\x%X'", (:uchar)c);
  }
}

fn gen_str(str: *const char, multiline: bool) {
  if (multiline) {
    gen_indent++;
    genln();
  }
  buf_printf(&gen_buf, "\"");
  while (*str) {
    let start: *const char = str;
    while (*str && isprint(*str) && !char_to_escape[(:uchar)*str]) {
      str++;
    }
    if (start != str) {
      buf_printf(&gen_buf, "%.*s", str - start, start);
    }
    if (*str) {
      if (char_to_escape[(:uchar)*str]) {
        buf_printf(&gen_buf, "\\%c", char_to_escape[(:uchar)*str]);
        if (str[0] == '\n' && str[1]) {
          buf_printf(&gen_buf, "\"");
          genln(); buf_printf(&gen_buf, "\"");
        }
      } else {
        #assert(!isprint(*str));
        buf_printf(&gen_buf, "\\x%X", (:uchar)*str);
      }
      str++;
    }
  }
  buf_printf(&gen_buf, "\"");
  if (multiline) {
    gen_indent--;
  }
}

fn gen_sync_pos(pos: SrcPos) {
  if (flag_nosourcemap) {
    return;
  }
  if (gen_pos.line != pos.line || gen_pos.name != pos.name) {
    genln(); buf_printf(&gen_buf, "#line %d", pos.line);
    if (gen_pos.name != pos.name) {
      buf_printf(&gen_buf, " ");
      gen_str(pos.name, false);
    }
    gen_pos = pos;
  }
}

fn cdecl_paren(str: *const char, c: char) -> *const char {
  return c && c != '[' ? (:*const char)strf("(%s)", str) : str;
}

fn cdecl_name(type: &Type) -> *const char {
  let type_name: *const char = type_names[type.kind];
  if (type_name) {
    return type_name;
  } else {
    #assert(type.sym);
    return get_gen_name(type.sym);
  }
}

fn type_to_cdecl(type: &Type, str: *const char) -> *char {
  switch (type.kind) {
  case CompilerTypeKind.Ptr:
  case CompilerTypeKind.Ref:
    return type_to_cdecl(type.base, cdecl_paren(strf("*%s", str), *str));
  case CompilerTypeKind.Const:
    return type_to_cdecl(type.base, strf("const %s", cdecl_paren(str, *str)));
  case CompilerTypeKind.Array:
    if (type.num_elems == 0) {
      return type_to_cdecl(type.base, cdecl_paren(strf("%s[]", str), *str));
    } else {
      return type_to_cdecl(type.base, cdecl_paren(strf("%s[%zu]", str, type.num_elems), *str));
    }
  case CompilerTypeKind.Func: {
    let result: *char = NULL;
    buf_printf(&result, "(*%s)(", str);
    if (type.function.num_params == 0) {
      buf_printf(&result, "void");
    } else {
      for (let i: usize = 0; i < type.function.num_params; i++) {
        buf_printf(&result, "%s%s", i == 0 ? "" : ", ", type_to_cdecl(type.function.params[i], ""));
      }
    }
    if (type.function.has_varargs) {
      buf_printf(&result, ", ...");
    }
    buf_printf(&result, ")");
    return type_to_cdecl(type.function.ret, result);
  }
  default:
    return strf("%s%s%s", cdecl_name(type), *str ? " " : "", str);
  }
}

fn gen_expr_str(expr: &Expr) -> *const char {
  let temp: *char = gen_buf;
  gen_buf = NULL;
  gen_expr(expr);
  let result = gen_buf;
  gen_buf = temp;
  return result;
}

let gen_name_map: Map;

fn get_gen_name_or_default(ptr: &const void, default_name: *const char) -> *const char {
  let name: *const char = map_get(&gen_name_map, ptr);
  if (!name) {
    let sym = get_resolved_sym(ptr);
    if (sym) {
      if (sym.external_name) {
        name = sym.external_name;
      } else if (sym.home_package.external_name) {
        let external_name = sym.home_package.external_name;
        name = strf("%s%s", external_name, sym.name);
      } else {
        name = sym.name;
      }
    } else {
      #assert(default_name);
      name = default_name;
    }
    map_put(&gen_name_map, ptr, (:&void)name);
  }
  return name;
}

fn get_gen_name(ptr: &const void) -> *const char {
  return get_gen_name_or_default(ptr, "ERROR");
}

fn typespec_to_cdecl(typespec: &Typespec, str: *const char) -> *char {
  if (!typespec) {
    return strf("void%s%s", *str ? " " : "", str);
  }
  switch (typespec.kind) {
  case Typespec.Name:
    return strf("%s%s%s", get_gen_name_or_default(typespec, typespec.name), *str ? " " : "", str);
  case Typespec.Ptr:
  case Typespec.Ref:
    return typespec_to_cdecl(typespec.base, cdecl_paren(strf("*%s", str), *str));
  case Typespec.Const:
    return typespec_to_cdecl(typespec.base, strf("const %s", cdecl_paren(str, *str)));
  case Typespec.Array:
    if (typespec.num_elems == 0) {
      return typespec_to_cdecl(typespec.base, cdecl_paren(strf("%s[]", str), *str));
    } else {
      return typespec_to_cdecl(typespec.base, cdecl_paren(strf("%s[%s]", str, gen_expr_str(typespec.num_elems)), *str));
    }
  case Typespec.Func:
    let result: *char = NULL;
    buf_printf(&result, "(*%s)(", str);
    if (typespec.function.num_args == 0) {
      buf_printf(&result, "void");
    } else {
      for (let i: usize = 0; i < typespec.function.num_args; i++) {
        buf_printf(&result, "%s%s", i == 0 ? "" : ", ", typespec_to_cdecl(typespec.function.args[i], ""));
      }
    }
    if (typespec.function.has_varargs) {
      buf_printf(&result, ", ...");
    }
    buf_printf(&result, ")");
    return typespec_to_cdecl(typespec.function.ret, result);
  default:
    #assert(0);
    return NULL;
  }
}

fn gen_func_decl(decl: &Decl) {
  #assert(decl.kind == Decl.Func);
  let result: *char = NULL;
  buf_printf(&result, "%s(", get_gen_name(decl));
  if (decl.function.num_params == 0) {
    buf_printf(&result, "void");
  } else {
    for (let i: usize = 0; i < decl.function.num_params; i++) {
      let param = decl.function.params[i];
      if (i != 0) {
        buf_printf(&result, ", ");
      }
      buf_printf(&result, "%s", typespec_to_cdecl(param.type, param.name));
    }
  }
  if (decl.function.has_varargs) {
    buf_printf(&result, ", ...");
  }
  buf_printf(&result, ")");
  gen_sync_pos(decl.pos);
  if (decl.function.ret_type) {
    genln(); buf_printf(&gen_buf, "%s", typespec_to_cdecl(decl.function.ret_type, result));
  } else {
    genln(); buf_printf(&gen_buf, "void %s", result);
  }
}

fn gen_reachable(sym: &Sym) -> bool {
  return flag_fullgen || sym.reachable == ReachablePhase.Natural;
}

fn gen_forward_decls() {
  for (let it: *&Sym = sorted_syms; it != buf_end(sorted_syms, sizeof(*sorted_syms)); it++) {
    let sym = *it;
    let decl = sym.decl;
    if (!decl || !gen_reachable(sym)) {
      continue;
    }
    if (is_decl_foreign(decl)) {
      continue;
    }
    switch (decl.kind) {
    case Decl.Struct:
    case Decl.Union: {
      let name = get_gen_name(sym);
      genln();
      buf_printf(
        &gen_buf, "typedef %s %s %s;",
        decl.aggregate.kind == AggregateKind.Struct ? "struct" : "union",
        name, name,
      );
      break;
    }
    default:
      // Do nothing.
      break;
    }
  }
}

fn gen_aggregate_item(item: &AggregateItem) {
  @complete
  if (item.kind == AggregateItem.Field) {
    for (let j: usize = 0; j < item.num_names; j++) {
      gen_sync_pos(item.pos);
      let prefix = "";
      // Skip actually generating void fields.
      // TODO Error on uses of void fields.
      // TODO Error on void fields outside of enum unions.
      // TODO Find a better way to check for void.
      if (item.type.kind == Typespec.Name) {
        let name = get_gen_name_or_default(item.type, item.type.name);
        if (name == void_name) {
          prefix = "// ";
        }
      }
      // Generate standard field.
      genln();
      buf_printf(
        &gen_buf, "%s%s;", prefix, typespec_to_cdecl(item.type, item.names[j]),
      );
    }
  } else if (item.kind == AggregateItem.Subaggregate) {
    genln();
    buf_printf(
      &gen_buf, "%s {",
      item.subaggregate.kind == AggregateKind.Struct ? "struct" : "union",
    );
    gen_aggregate_items(item.subaggregate);
    genln();
    buf_printf(&gen_buf, "};");
  }
}

fn gen_aggregate_items(aggregate: &Aggregate) {
  gen_indent++;
  for (let i: usize = 0; i < aggregate.num_items; i++) {
    let item = aggregate.items[i];
    gen_aggregate_item(&aggregate.items[i]);
  }
  gen_indent--;
}

fn gen_aggregate(decl: &Decl) {
  #assert(decl.kind == Decl.Struct || decl.kind == Decl.Union);
  if (decl.is_incomplete) {
    return;
  }
  genln();
  buf_printf(
    &gen_buf, "%s %s {",
    decl.aggregate.kind == AggregateKind.Struct ? "struct" : "union",
    get_gen_name(decl),
  );
  gen_aggregate_items(decl.aggregate);
  genln();
  buf_printf(&gen_buf, "};");
}

fn gen_paren_expr(expr: &Expr) {
  buf_printf(&gen_buf, "(");
  gen_expr(expr);
  buf_printf(&gen_buf, ")");
}

fn gen_expr_compound(expr: &Expr) {
  let expected_type = get_resolved_expected_type(expr);
  if (expected_type && !is_ptr_type(expected_type)) {
    buf_printf(&gen_buf, "{");
  } else if (expr.compound.type) {
    buf_printf(&gen_buf, "(%s){", typespec_to_cdecl(expr.compound.type, ""));
  } else {
    buf_printf(&gen_buf, "(%s){", type_to_cdecl(get_resolved_type(expr), ""));
  }
  for (let i: usize = 0; i < expr.compound.num_fields; i++) {
    if (i != 0) {
      buf_printf(&gen_buf, ", ");
    }
    let field = expr.compound.fields[i];
    if (field.kind == CompoundField.Name) {
      buf_printf(&gen_buf, ".%s = ", field.name);
    } else if (field.kind == CompoundField.Index) {
      buf_printf(&gen_buf, "[");
      gen_expr(field.index);
      buf_printf(&gen_buf, "] = ");
    }
    gen_expr(field.init);
  }
  if (expr.compound.num_fields == 0) {
    buf_printf(&gen_buf, "0");
  }
  buf_printf(&gen_buf, "}");
}

let typeid_kind_names: [CompilerTypeKind.Num]*const char = {
  [CompilerTypeKind.None] = "TypeKind_None",
  [CompilerTypeKind.Void] = "TypeKind_Void",
  [CompilerTypeKind.Bool] = "TypeKind_Bool",
  [CompilerTypeKind.Char] = "TypeKind_Char",
  [CompilerTypeKind.UChar] = "TypeKind_UChar",
  [CompilerTypeKind.SChar] = "TypeKind_SChar",
  [CompilerTypeKind.Short] = "TypeKind_Short",
  [CompilerTypeKind.UShort] = "TypeKind_UShort",
  [CompilerTypeKind.Int] =  "TypeKind_Int",
  [CompilerTypeKind.UInt] = "TypeKind_UInt",
  [CompilerTypeKind.Long] = "TypeKind_Long",
  [CompilerTypeKind.ULong] = "TypeKind_ULong",
  [CompilerTypeKind.LLong] = "TypeKind_LLong",
  [CompilerTypeKind.ULLong] = "TypeKind_ULLong",
  [CompilerTypeKind.Float] = "TypeKind_Float",
  [CompilerTypeKind.Double] = "TypeKind_Double",
  [CompilerTypeKind.Const] = "TypeKind_Const",
  [CompilerTypeKind.Ptr] = "TypeKind_Ptr",
  [CompilerTypeKind.Ref] = "TypeKind_Ref",
  [CompilerTypeKind.Array] = "TypeKind_Array",
  [CompilerTypeKind.Struct] = "TypeKind_Struct",
  [CompilerTypeKind.Union] = "TypeKind_Union",
  [CompilerTypeKind.Func] = "TypeKind_Func",
};

fn typeid_kind_name(type: &Type) -> *const char {
  if (type.kind < CompilerTypeKind.Num) {
    let name = typeid_kind_names[type.kind];
    if (name) {
      return name;
    }
  }
  return "TypeKind_None";
}

fn is_excluded_typeinfo(type: &Type) -> bool {
  while (type.kind == CompilerTypeKind.Array || type.kind == CompilerTypeKind.Const || is_ptr_type(type)) {
    type = type.base;
  }
  if (type.sym) {
    return !gen_reachable(type.sym);
  } else {
    return !type.sym && (type.kind == CompilerTypeKind.Struct || type.kind == CompilerTypeKind.Union);
  }
}

fn gen_typeid(type: &Type) {
  if (type.size == 0 || is_excluded_typeinfo(type)) {
    buf_printf(&gen_buf, "TYPEID0(%d, %s)", type.typeid, typeid_kind_name(type));
  } else {
    buf_printf(&gen_buf, "TYPEID(%d, %s, %s)", type.typeid, typeid_kind_name(type), type_to_cdecl(type, ""));
  }
}

fn gen_expr(expr: &Expr) {
  @complete
  switch (expr.kind) {
  case ExprKind.Paren:
    buf_printf(&gen_buf, "(");
    gen_expr(expr.paren.expr);
    buf_printf(&gen_buf, ")");
  case ExprKind.Int: {
    let suffix_name: *const char = token_suffix_names[expr.int_lit.suffix];
    switch (expr.int_lit.mod) {
    case TokenMod.Bin:
    case TokenMod.Hex:
      buf_printf(&gen_buf, "0x%llx%s", expr.int_lit.val, suffix_name);
    case TokenMod.Oct:
      buf_printf(&gen_buf, "0%llo%s", expr.int_lit.val, suffix_name);
    case TokenMod.Char:
      gen_char((:char)expr.int_lit.val);
    default:
      buf_printf(&gen_buf, "%llu%s", expr.int_lit.val, suffix_name);
    }
  }
  case ExprKind.Float: {
    let is_double = expr.float_lit.suffix == TokenSuffix.D;
    let len: usize = expr.float_lit.end - expr.float_lit.start;
    buf_printf(&gen_buf, "%.*s%s", is_double ? len-1 : len, expr.float_lit.start, is_double ? "" : "f");
  }
  case ExprKind.Str:
    gen_str(expr.str_lit.val, expr.str_lit.mod == TokenMod.Multiline);
  case ExprKind.Name:
    buf_printf(&gen_buf, "%s", get_gen_name_or_default(expr, expr.name));
  case ExprKind.Cast:
    buf_printf(&gen_buf, "(%s)(", typespec_to_cdecl(expr.cast.type, ""));
    gen_expr(expr.cast.expr);
    buf_printf(&gen_buf, ")");
  case ExprKind.Call: {
    let sym = get_resolved_sym(expr.call.expr);
    if (sym && sym.kind == SymKind.Type) {
      buf_printf(&gen_buf, "(%s)", get_gen_name(sym));
    } else {
      gen_expr(expr.call.expr);
    }
    buf_printf(&gen_buf, "(");
    for (let i: usize = 0; i < expr.call.num_args; i++) {
      if (i != 0) {
        buf_printf(&gen_buf, ", ");
      }
      gen_expr(expr.call.args[i]);
    }
    buf_printf(&gen_buf, ")");
  }
  case ExprKind.Index:
    gen_expr(expr.index.expr);
    buf_printf(&gen_buf, "[");
    gen_expr(expr.index.index);
    buf_printf(&gen_buf, "]");
  case ExprKind.Field: {
    let sym = get_resolved_sym(expr);
    if (sym) {
      buf_printf(&gen_buf, "(%s)", get_gen_name(sym));
    } else {
      gen_expr(expr.field.expr);
      let type = unqualify_type(get_resolved_type(expr.field.expr));
      buf_printf(
        &gen_buf, "%s%s", is_ptr_type(type) ? "->" : ".", expr.field.name,
      );
    }
  }
  case ExprKind.Compound:
    gen_expr_compound(expr);
  case ExprKind.Unary:
    buf_printf(&gen_buf, "%s(", token_kind_name(expr.unary.op));
    gen_expr(expr.unary.expr);
    buf_printf(&gen_buf, ")");
  case ExprKind.Binary:
    buf_printf(&gen_buf, "(");
    gen_expr(expr.binary.left);
    buf_printf(&gen_buf, ") %s (", token_kind_name(expr.binary.op));
    gen_expr(expr.binary.right);
    buf_printf(&gen_buf, ")");
  case ExprKind.Ternary:
    buf_printf(&gen_buf, "(");
    gen_expr(expr.ternary.cond);
    buf_printf(&gen_buf, " ? ");
    gen_expr(expr.ternary.then_expr);
    buf_printf(&gen_buf, " : ");
    gen_expr(expr.ternary.else_expr);
    buf_printf(&gen_buf, ")");
  case ExprKind.SizeofExpr:
    buf_printf(&gen_buf, "sizeof(");
    gen_expr(expr.sizeof_expr);
    buf_printf(&gen_buf, ")");
  case ExprKind.SizeofType:
    buf_printf(&gen_buf, "sizeof(%s)", typespec_to_cdecl(expr.sizeof_type, ""));
  case ExprKind.AlignofExpr:
    buf_printf(&gen_buf, "alignof(%s)", type_to_cdecl(get_resolved_type(expr.alignof_expr), ""));
  case ExprKind.AlignofType:
    buf_printf(&gen_buf, "alignof(%s)", typespec_to_cdecl(expr.alignof_type, ""));
  case ExprKind.TypeofExpr: {
    let type = get_resolved_type(expr.typeof_expr);
    #assert(type.typeid);
    gen_typeid(type);
  }
  case ExprKind.TypeofType: {
    let type = get_resolved_type(expr.typeof_type);
    #assert(type.typeid);
    gen_typeid(type);
  }
  case ExprKind.Offsetof:
    buf_printf(&gen_buf, "offsetof(%s, %s)", typespec_to_cdecl(expr.offsetof_field.type, ""), expr.offsetof_field.name);
  case ExprKind.Modify:
    if (!expr.modify.post) {
      buf_printf(&gen_buf, "%s", token_kind_name(expr.modify.op));
    }
    gen_paren_expr(expr.modify.expr);
    if (expr.modify.post) {
      buf_printf(&gen_buf, "%s", token_kind_name(expr.modify.op));
    }
  }
}

fn gen_stmt_block(block: StmtList) {
  buf_printf(&gen_buf, "{");
  gen_indent++;
  for (let i: usize = 0; i < block.num_stmts; i++) {
    gen_stmt(block.stmts[i]);
  }
  gen_indent--;
  genln(); buf_printf(&gen_buf, "}");
}

fn gen_simple_stmt(stmt: &Stmt) {
  @complete
  switch (stmt.kind) {
  case Stmt.Expr:
    gen_expr(stmt.expr);
  case Stmt.Init:
    if (stmt.init.type) {
      let init_typespec = stmt.init.type;
      if (is_incomplete_array_typespec(stmt.init.type)) {
        let size = new_expr_int(init_typespec.pos, get_resolved_type(stmt.init.expr).num_elems, 0, 0);
        init_typespec = new_typespec_array(init_typespec.pos, init_typespec.base, size);
      }
      buf_printf(&gen_buf, "%s = ", typespec_to_cdecl(stmt.init.type, stmt.init.name));
      if (stmt.init.expr) {
        gen_expr(stmt.init.expr);
      } else {
        buf_printf(&gen_buf, "{0}");
      }
    } else {
      buf_printf(&gen_buf, "%s = ", type_to_cdecl(unqualify_type(get_resolved_type(stmt.init.expr)), stmt.init.name));
      gen_expr(stmt.init.expr);
    }
  case Stmt.Assign:
    gen_expr(stmt.assign.left);
    buf_printf(&gen_buf, " %s ", token_kind_name(stmt.assign.op));
    gen_expr(stmt.assign.right);
  }
}

fn is_char_lit(expr: &Expr) -> bool {
  return expr.kind == ExprKind.Int && expr.int_lit.mod == TokenMod.Char;
}

fn gen_stmt(stmt: &Stmt) {
  gen_sync_pos(stmt.pos);
  switch (stmt.kind) {
  case Stmt.Return:
    genln(); buf_printf(&gen_buf, "return");
    if (stmt.expr) {
      buf_printf(&gen_buf, " ");
      gen_expr(stmt.expr);
    }
    buf_printf(&gen_buf, ";");
  case Stmt.Break:
    genln(); buf_printf(&gen_buf, "break;");
  case Stmt.Continue:
    genln(); buf_printf(&gen_buf, "continue;");
  case Stmt.Block:
    genln();
    gen_stmt_block(stmt.block);
  case Stmt.Note:
    if (stmt.note.name == assert_name) {
      genln(); buf_printf(&gen_buf, "assert(");
      #assert(stmt.note.num_args == 1);
      gen_expr(stmt.note.args[0].expr);
      buf_printf(&gen_buf, ");");
    }
  case Stmt.If:
    if (stmt.if_stmt.init) {
      genln(); buf_printf(&gen_buf, "{");
      gen_indent++;
      gen_stmt(stmt.if_stmt.init);
    }
    gen_sync_pos(stmt.pos);
    genln(); buf_printf(&gen_buf, "if (");
    if (stmt.if_stmt.cond) {
      gen_expr(stmt.if_stmt.cond);
    } else {
      buf_printf(&gen_buf, "%s", stmt.if_stmt.init.init.name);
    }
    buf_printf(&gen_buf, ") ");
    gen_stmt_block(stmt.if_stmt.then_block);
    for (let i: usize = 0; i < stmt.if_stmt.num_elseifs; i++) {
      let elseif = stmt.if_stmt.elseifs[i];
      buf_printf(&gen_buf, " else if (");
      gen_expr(elseif.cond);
      buf_printf(&gen_buf, ") ");
      gen_stmt_block(elseif.block);
    }
    if (stmt.if_stmt.else_block.stmts) {
      buf_printf(&gen_buf, " else ");
      gen_stmt_block(stmt.if_stmt.else_block);
    } else {
      let complete_note = get_stmt_note(stmt, complete_name);
      if (complete_note) {
        buf_printf(&gen_buf, " else {");
        gen_indent++;
        gen_sync_pos(complete_note.pos);
        genln(); buf_printf(&gen_buf, "assert(\"@complete if/elseif chain failed to handle case\" && 0);");
        gen_indent--;
        genln(); buf_printf(&gen_buf, "}");
      }
    }
    if (stmt.if_stmt.init) {
      gen_indent--;
      genln(); buf_printf(&gen_buf, "}");
    }
  case Stmt.While:
    genln(); buf_printf(&gen_buf, "while (");
    gen_expr(stmt.while_stmt.cond);
    buf_printf(&gen_buf, ") ");
    gen_stmt_block(stmt.while_stmt.block);
  case Stmt.DoWhile:
    genln(); buf_printf(&gen_buf, "do ");
    gen_stmt_block(stmt.while_stmt.block);
    buf_printf(&gen_buf, " while (");
    gen_expr(stmt.while_stmt.cond);
    buf_printf(&gen_buf, ");");
  case Stmt.For:
    genln(); buf_printf(&gen_buf, "for (");
    if (stmt.for_stmt.init) {
      gen_simple_stmt(stmt.for_stmt.init);
    }
    buf_printf(&gen_buf, ";");
    if (stmt.for_stmt.cond) {
      buf_printf(&gen_buf, " ");
      gen_expr(stmt.for_stmt.cond);
    }
    buf_printf(&gen_buf, ";");
    if (stmt.for_stmt.next) {
      buf_printf(&gen_buf, " ");
      gen_simple_stmt(stmt.for_stmt.next);
    }
    buf_printf(&gen_buf, ") ");
    gen_stmt_block(stmt.for_stmt.block);
  case Stmt.Switch: {
    genln(); buf_printf(&gen_buf, "switch (");
    gen_expr(stmt.switch_stmt.expr);
    buf_printf(&gen_buf, ") {");
    let has_default = false;
    for (let i: usize = 0; i < stmt.switch_stmt.num_cases; i++) {
      let switch_case = stmt.switch_stmt.cases[i];
      for (let j: usize = 0; j < switch_case.num_patterns; j++) {
        let pattern = switch_case.patterns[j];
        if (pattern.end) {
          let start_val = get_resolved_val(pattern.start);
          let end_val = get_resolved_val(pattern.end);
          if (is_char_lit(pattern.start) && is_char_lit(pattern.end)) {
            genln();
            for (let c = (:int)start_val.ll; c <= (:int)end_val.ll; c++) {
              buf_printf(&gen_buf, "case ");
              gen_char(c);
              buf_printf(&gen_buf, ": ");
            }
          } else {
            genln(); buf_printf(&gen_buf, "// ");
            gen_expr(pattern.start);
            buf_printf(&gen_buf, "...");
            gen_expr(pattern.end);
            genln();
            for (let ll: llong = start_val.ll; ll <= end_val.ll; ll++) {
              buf_printf(&gen_buf, "case %lld: ", ll);
            }
          }
        } else {
          genln(); buf_printf(&gen_buf, "case ");
          gen_expr(pattern.start);
          buf_printf(&gen_buf, ":");
        }
      }
      if (switch_case.is_default) {
        has_default = true;
        genln(); buf_printf(&gen_buf, "default:");
      }
      buf_printf(&gen_buf, " ");
      buf_printf(&gen_buf, "{");
      gen_indent++;
      let block = switch_case.block;
      for (let j: usize = 0; j < block.num_stmts; j++) {
        gen_stmt(block.stmts[j]);
      }
      genln(); buf_printf(&gen_buf, "break;");
      gen_indent--;
      genln(); buf_printf(&gen_buf, "}");
    }
    if (!has_default) {
      let note = get_stmt_note(stmt, complete_name);
      if (note) {
        genln(); buf_printf(&gen_buf, "default:");
        gen_indent++;
        genln(); buf_printf(&gen_buf, "assert(\"@complete switch failed to handle case\" && 0);");
        genln(); buf_printf(&gen_buf, "break;");
        gen_indent--;
      }
    }
    genln(); buf_printf(&gen_buf, "}");
  }
  case Stmt.Label:
    genln(); buf_printf(&gen_buf, "%s: ;", stmt.label);
  case Stmt.Goto:
    genln(); buf_printf(&gen_buf, "goto %s;", stmt.label);
  default:
    genln();
    gen_simple_stmt(stmt);
    buf_printf(&gen_buf, ";");
  }
}

fn gen_decl(sym: &Sym) {
  let decl = sym.decl;
  if (!decl || is_decl_foreign(decl)) {
    return;
  }
  gen_sync_pos(decl.pos);
  @complete
  switch (decl.kind) {
  case Decl.Const:
    genln(); buf_printf(&gen_buf, "#define %s (", get_gen_name(sym));
    if (decl.const_decl.type) {
      buf_printf(&gen_buf, "(%s)(", typespec_to_cdecl(decl.const_decl.type, ""));
    }
    gen_expr(decl.const_decl.expr);
    if (decl.const_decl.type) {
      buf_printf(&gen_buf, ")");
    }
    buf_printf(&gen_buf, ")");
  case Decl.Var:
    genln(); buf_printf(&gen_buf, "extern ");
    if (decl.var_decl.type && !is_incomplete_array_typespec(decl.var_decl.type)) {
      buf_printf(&gen_buf, "%s", typespec_to_cdecl(decl.var_decl.type, get_gen_name(sym)));
    } else {
      buf_printf(&gen_buf, "%s", type_to_cdecl(sym.type, get_gen_name(sym)));
    }
    buf_printf(&gen_buf, ";");
  case Decl.Func:
    gen_func_decl(decl);
    buf_printf(&gen_buf, ";");
  case Decl.Struct:
  case Decl.Union:
    gen_aggregate(decl);
  case Decl.Typedef:
    genln(); buf_printf(&gen_buf, "typedef %s;", typespec_to_cdecl(decl.typedef_decl.type, get_gen_name(sym)));
  case Decl.Enum:
    if (decl.enum_decl.type) {
      genln(); buf_printf(&gen_buf, "typedef %s;", typespec_to_cdecl(decl.enum_decl.type, get_gen_name(decl)));
    } else {
      genln(); buf_printf(&gen_buf, "typedef int %s;", get_gen_name(decl));
    }
  case Decl.Import:
    // Do nothing
    break;
  }
  genln();
}

fn gen_sorted_decls() {
  for (let i: usize = 0; i < buf_len(sorted_syms); i++) {
    if (sorted_syms[i].reachable == ReachablePhase.Natural) {
      gen_decl(sorted_syms[i]);
    }
  }
}

fn gen_defs() {
  for (let it: *&Sym = sorted_syms; it != buf_end(sorted_syms, sizeof(*sorted_syms)); it++) {
    let sym = *it;
    let decl = sym.decl;
    if (sym.state != SymState.Resolved || !decl || is_decl_foreign(decl) || decl.is_incomplete || sym.reachable != ReachablePhase.Natural) {
      continue;
    }
    if (decl.kind == Decl.Func) {
      gen_func_decl(decl);
      buf_printf(&gen_buf, " ");
      gen_stmt_block(decl.function.block);
      genln();
    } else if (decl.kind == Decl.Var) {
      if (decl.var_decl.type && !is_incomplete_array_typespec(decl.var_decl.type)) {
        genln(); buf_printf(&gen_buf, "%s", typespec_to_cdecl(decl.var_decl.type, get_gen_name(sym)));
      } else {
        genln(); buf_printf(&gen_buf, "%s", type_to_cdecl(sym.type, get_gen_name(sym)));
      }
      if (decl.var_decl.expr) {
        buf_printf(&gen_buf, " = ");
        gen_expr(decl.var_decl.expr);
      }
      buf_printf(&gen_buf, ";");
    }
  }
}

let gen_foreign_headers_map: Map;
let gen_foreign_headers_buf: **const char;

fn add_foreign_header(name: *const char) {
  name = str_intern(name);
  if (!map_get(&gen_foreign_headers_map, name)) {
    map_put(&gen_foreign_headers_map, name, (:&void)1);
    buf_push((:*&void)&gen_foreign_headers_buf, &name, sizeof(name));
  }
}

let gen_foreign_sources_buf: **const char;

fn add_foreign_source(name: *const char) {
  let interned = str_intern(name);
  buf_push((:*&void)&gen_foreign_sources_buf, &interned, sizeof(interned));
}

fn gen_include(path: *const char) {
  genln(); buf_printf(&gen_buf, "#include ");
  if (*path == '<') {
    buf_printf(&gen_buf, "%s", path);
  } else {
    gen_str(path, false);
  }
}

fn gen_foreign_headers() {
  if (gen_foreign_headers_buf) {
    genln(); buf_printf(&gen_buf, "// Foreign header files");
    for (let i: usize = 0; i < buf_len(gen_foreign_headers_buf); i++) {
      gen_include(gen_foreign_headers_buf[i]);
    }
  }
}

fn gen_foreign_sources() {
  for (let i: usize = 0; i < buf_len(gen_foreign_sources_buf); i++) {
    gen_include(gen_foreign_sources_buf[i]);
  }
}

let gen_sources_buf: **const char;

fn put_include_path(path: [MAX_PATH]char, package: &Package, filename: *const char) {
  if (*filename == '<') {
    path_copy(path, filename);
  } else {
    path_copy(path, package.full_path);
    path_join(path, filename);
    path_absolute(path);
  }
}

let gen_preamble_buf: *char;
let gen_postamble_buf: *char;

fn preprocess_package(package: &Package) {
  if (!package.external_name) {
    let external_name: *char = NULL;
    for (let ptr: *const char = package.path; *ptr; ptr++) {
      buf_printf(&external_name, "%c", *ptr == '/' ? '_' : *ptr);
    }
    buf_printf(&external_name, "_");
    package.external_name = str_intern(external_name);
  }
  let header_name = str_intern("header");
  let source_name = str_intern("source");
  let preamble_name = str_intern("preamble");
  let postamble_name = str_intern("postamble");
  for (let i: usize = 0; i < package.num_decls; i++) {
    let decl = package.decls[i];
    if (decl.kind != Decl.Note) {
      continue;
    }
    let note = decl.note;
    if (note.name == foreign_name) {
      for (let k: usize = 0; k < note.num_args; k++) {
        let arg = note.args[k];
        let expr = note.args[k].expr;
        if (expr.kind != ExprKind.Str) {
          fatal_error(decl.pos, "#foreign argument must be a string");
        }
        let str = expr.str_lit.val;
        if (arg.name == header_name) {
          let path: [MAX_PATH]char;
          put_include_path(path, package, str);
          add_foreign_header(path);
        } else if (arg.name == source_name) {
          let path: [MAX_PATH]char;
          put_include_path(path, package, str);
          add_foreign_source(path);
        } else if (arg.name == preamble_name) {
          buf_printf(&gen_preamble_buf, "%s\n", str);
        } else if (arg.name == postamble_name) {
          buf_printf(&gen_postamble_buf, "%s\n", str);
        } else {
          fatal_error(decl.pos, "Unknown #foreign named argument '%s'", arg.name);
        }
      }
    }
  }
}

fn preprocess_packages() {
  for (let i: usize = 0; i < buf_len(package_list); i++) {
    preprocess_package(package_list[i]);
  }
}

fn gen_typeinfo_header(kind: *const char, type: &Type) {
  if (type_sizeof(type) == 0) {
    buf_printf(&gen_buf, "&(TypeInfo){%s, .size = 0, .align = 0", kind);
  } else {
    let ctype = type_to_cdecl(type, "");
    buf_printf(&gen_buf, "&(TypeInfo){%s, .size = sizeof(%s), .align = alignof(%s)", kind, ctype, ctype);
  }
}

fn gen_typeinfo_fields(type: &Type) {
  gen_indent++;
  for (let i: usize = 0; i < type.aggregate.num_fields; i++) {
    let field = type.aggregate.fields[i];
    genln(); buf_printf(&gen_buf, "{");
    gen_str(field.name, false);
    buf_printf(&gen_buf, ", .type = ");
    gen_typeid(field.type);
    buf_printf(&gen_buf, ", .offset = offsetof(%s, %s)},", get_gen_name(type.sym), field.name);
  }
  gen_indent--;
}

// #define CASE(kind, name) \
//   case kind:
//     buf_printf(&gen_buf, "&(TypeInfo){$1, .size = sizeof($2), .align = sizeof($2), .name = ");
//     gen_str($2, false);
//     buf_printf(&gen_buf, "},");

fn gen_typeinfo(type: &Type) {
  switch (type.kind) {
  case CompilerTypeKind.Bool:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Bool, .size = sizeof(bool), .align = sizeof(bool), .name = ");
     gen_str("bool", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Char:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Char, .size = sizeof(char), .align = sizeof(char), .name = ");
     gen_str("char", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.UChar:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_UChar, .size = sizeof(uchar), .align = sizeof(uchar), .name = ");
     gen_str("uchar", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.SChar:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_SChar, .size = sizeof(schar), .align = sizeof(schar), .name = ");
     gen_str("schar", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Short:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Short, .size = sizeof(short), .align = sizeof(short), .name = ");
     gen_str("short", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.UShort:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_UShort, .size = sizeof(ushort), .align = sizeof(ushort), .name = ");
     gen_str("ushort", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Int:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Int, .size = sizeof(int), .align = sizeof(int), .name = ");
     gen_str("int", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.UInt:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_UInt, .size = sizeof(uint), .align = sizeof(uint), .name = ");
     gen_str("uint", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Long:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Long, .size = sizeof(long), .align = sizeof(long), .name = ");
     gen_str("long", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.ULong:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_ULong, .size = sizeof(ulong), .align = sizeof(ulong), .name = ");
     gen_str("ulong", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.LLong:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_LLong, .size = sizeof(llong), .align = sizeof(llong), .name = ");
     gen_str("llong", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.ULLong:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_ULLong, .size = sizeof(ullong), .align = sizeof(ullong), .name = ");
     gen_str("ullong", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Float:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Float, .size = sizeof(float), .align = sizeof(float), .name = ");
     gen_str("float", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Double:
     buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Double, .size = sizeof(double), .align = sizeof(double), .name = ");
     gen_str("double", false);
     buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Void:
    buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Void, .name = \"void\", .size = 0, .align = 0},");
  case CompilerTypeKind.Ptr:
    buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Ptr, .size = sizeof(void *), .align = alignof(void *), .base = ");
    gen_typeid(type.base);
    buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Ref:
    buf_printf(&gen_buf, "&(TypeInfo){TypeKind_Ref, .size = sizeof(void *), .align = alignof(void *), .base = ");
    gen_typeid(type.base);
    buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Const:
    gen_typeinfo_header("TypeKind_Const", type);
    buf_printf(&gen_buf, ", .base = ");
    gen_typeid(type.base);
    buf_printf(&gen_buf, "},");
  case CompilerTypeKind.Array:
    if (is_incomplete_array_type(type)) {
      buf_printf(&gen_buf, "NULL, // Incomplete array type");
    } else {
      gen_typeinfo_header("TypeKind_Array", type);
      buf_printf(&gen_buf, ", .base = ");
      gen_typeid(type.base);
      buf_printf(&gen_buf, ", .count = %d},", type.num_elems);
    }
  case CompilerTypeKind.Struct:
  case CompilerTypeKind.Union:
    gen_typeinfo_header(type.kind == CompilerTypeKind.Struct ? "TypeKind_Struct" : "TypeKind_Union", type);
    buf_printf(&gen_buf, ", .name = ");
    gen_str(get_gen_name(type.sym), false);
    buf_printf(&gen_buf, ", .num_fields = %d, .fields = (TypeFieldInfo[]) {", type.aggregate.num_fields);
    gen_typeinfo_fields(type);
    genln(); buf_printf(&gen_buf, "}},");
  case CompilerTypeKind.Func:
    buf_printf(&gen_buf, "NULL, // Function");
  case CompilerTypeKind.Enum:
    buf_printf(&gen_buf, "NULL, // Enum");
  case CompilerTypeKind.Incomplete:
    buf_printf(&gen_buf, "NULL, // Incomplete: %s", get_gen_name(type.sym));
  default:
    buf_printf(&gen_buf, "NULL, // Unhandled");
  }
}

// #undef CASE

fn gen_typeinfos() {
  genln(); buf_printf(&gen_buf, "#define TYPEID0(index, kind) ((ullong)(index) | ((ullong)(kind) << 24))");
  genln(); buf_printf(&gen_buf, "#define TYPEID(index, kind, ...) ((ullong)(index) | ((ullong)sizeof(__VA_ARGS__) << 32) | ((ullong)(kind) << 24))");
  genln();
  if (flag_notypeinfo) {
    genln(); buf_printf(&gen_buf, "int num_typeinfos;");
    genln(); buf_printf(&gen_buf, "const TypeInfo **typeinfos;");
  } else {
    let num_typeinfos = next_typeid;
    genln(); buf_printf(&gen_buf, "const TypeInfo *typeinfo_table[%d] = {", num_typeinfos);
    gen_indent++;
    for (let typeid: int = 0; typeid < num_typeinfos; typeid++) {
      genln(); buf_printf(&gen_buf, "[%d] = ", typeid);
      let type = get_type_from_typeid(typeid);
      if (type && !is_excluded_typeinfo(type)) {
        gen_typeinfo(type);
      } else {
        buf_printf(&gen_buf, "NULL, // No associated type");
      }
    }
    gen_indent--;
    genln(); buf_printf(&gen_buf, "};");
    genln();
    genln(); buf_printf(&gen_buf, "int num_typeinfos = %d;", num_typeinfos);
    genln(); buf_printf(&gen_buf, "const TypeInfo **typeinfos = (const TypeInfo **)typeinfo_table;");
  }
}

fn gen_package_external_names() {
  for (let i: usize = 0; i < buf_len(package_list); i++) {
  }
}

fn gen_preamble() {
  buf_printf(&gen_buf, "%s", gen_preamble_str);
  if (gen_preamble_buf) {
    genln();
    genln(); buf_printf(&gen_buf, "// Foreign preamble");
    genln(); buf_printf(&gen_buf, "%s", gen_preamble_buf);
  }
}

fn gen_postamble() {
  buf_printf(&gen_buf, "%s", gen_postamble_str);
  if (gen_postamble_buf) {
    genln();
    genln(); buf_printf(&gen_buf, "// Foreign postamble");
    genln(); buf_printf(&gen_buf, "%s", gen_postamble_buf);
  }
}

fn gen_all() {
  preprocess_packages();
  gen_buf = NULL;
  gen_preamble();
  gen_foreign_headers();
  genln();
  genln(); buf_printf(&gen_buf, "// Forward declarations");
  gen_forward_decls();
  genln();
  genln(); buf_printf(&gen_buf, "// Sorted declarations");
  gen_sorted_decls();
  genln(); buf_printf(&gen_buf, "// Typeinfo");
  gen_typeinfos();
  genln();
  genln(); buf_printf(&gen_buf, "// Definitions");
  gen_defs();
  genln(); buf_printf(&gen_buf, "// Foreign source files");
  gen_foreign_sources();
  genln();
  gen_postamble();
}
