enum SymState {
  Unresolved,
  Resolving,
  Resolved,
}

struct Sym {
  name: *const char;
  home_package: &Package;
  state: SymState;
  reachable: ReachablePhase;
  decl: &Decl;
  external_name: *const char;
  union switch {
    None => :void;
    Const, Func, Type, Var => struct {
      type: &Type;
      val: Val;
    }
    Package => package: &Package;
  }
}

struct Package {
  path: *const char;
  full_path: [MAX_PATH]char;
  decls: Slice<&Decl>;
  syms_map: Map;
  syms: *&Sym;
  external_name: *const char;
  always_reachable: bool;
}

const MAX_LOCAL_SYMS = 1024;

let mut current_package: &Package;
let mut builtin_package: &Package;
let mut package_map: Map;
let mut package_list: *&Package;

enum ReachablePhase = uint8 {
  None,
  Natural,
  Forced,
}

let mut reachable_phase = ReachablePhase.Natural;

def get_package_sym(package: &Package, name: *const char) -> &Sym {
  return map_get(&package.syms_map, name);
}

def add_package(package: &Package) {
  let mut old_package: &Package = map_get(&package_map, package.path);
  if (old_package != package) {
    #assert(!old_package);
    map_put(&package_map, package.path, package);
    buf_push(&package_list as &&void, &package, sizeof(package));
  }
}

def enter_package(new_package: &Package) -> &Package {
  let mut old_package = current_package;
  current_package = new_package;
  return old_package;
}

def leave_package(old_package: &Package) {
  current_package = old_package;
}

let mut reachable_syms: *&Sym;
let mut sorted_syms: *&Sym;
let mut local_syms: [MAX_LOCAL_SYMS]Sym;
let mut local_syms_end: *Sym = local_syms;

def is_local_sym(sym: &Sym) -> bool {
  return local_syms <= sym && sym < local_syms_end;
}

def sym_new(kind: Sym.Kind, name: *const char, decl: &Decl) -> &Sym {
  let mut sym: &Sym = xcalloc(1, sizeof(Sym));
  sym.kind = kind;
  sym.name = name;
  sym.decl = decl;
  sym.home_package = current_package;
  set_resolved_sym(sym, sym);
  return sym;
}

def process_decl_notes(decl: &Decl, sym: &Sym) {
  let mut foreign_note = get_decl_note(decl, foreign_name);
  if (foreign_note) {
    if (foreign_note.args.length > 1) {
      fatal_error(decl.pos, "@foreign takes 0 or 1 argument");
    }
    let mut external_name: *const char;
    if (foreign_note.args.length == 0) {
      external_name = sym.name;
    } else {
      let mut arg = foreign_note.args[0].expr;
      if (arg.kind != Expr.Str) {
        fatal_error(decl.pos, "@foreign argument 1 must be a string literal");
      }
      external_name = arg.str_lit.val;
    }
    sym.external_name = external_name;
  }
}

def sym_decl(decl: &Decl) -> &Sym {
  let mut kind = Sym.None;
  @complete
  switch (decl.kind) {
    Struct, Union, Typedef, Enum => kind = Sym.Type;
    Var => kind = Sym.Var;
    Const => kind = Sym.Const;
    Func => kind = Sym.Func;
  }
  let mut sym = sym_new(kind, decl.name, decl);
  set_resolved_sym(decl, sym);
  process_decl_notes(decl, sym);
  return sym;
}

def sym_get_local(name: *const char) -> &Sym {
  for (let mut it = local_syms_end; it != local_syms; it--) {
    let mut sym = it-1;
    if (sym.name == name) {
      return sym;
    }
  }
  return NULL;
}

def sym_get(name: *const char) -> &Sym {
  let mut sym = sym_get_local(name);
  return sym ? sym : get_package_sym(current_package, name);
}

def sym_push_var(name: *const char, type: &Type) -> bool {
  return sym_push_local(Sym.Var, name, type, NULL);
}

def sym_push_local(
  kind: Sym.Kind, name: *const char, type: &Type, decl: &Decl,
) -> bool {
  if (sym_get_local(name)) {
    return false;
  }
  if (local_syms_end == local_syms + MAX_LOCAL_SYMS) {
    fatal("Too many local symbols");
  }
  *local_syms_end++ = Sym {
    kind: kind,
    name: name,
    state: SymState.Resolved,
    decl: decl,
    type: type,
  };
  return true;
}

def sym_enter() -> &Sym {
  return local_syms_end;
}

def sym_leave(sym: &Sym) {
  local_syms_end = sym;
}

def sym_global_put(name: *const char, sym: &Sym) {
  let mut old_sym: &Sym = map_get(&current_package.syms_map, name);
  if (old_sym) {
    if (sym == old_sym) {
      return;
    }
    if (sym.kind == Sym.Package && old_sym.kind == Sym.Package && sym.package == old_sym.package) {
      return;
    }
    let mut pos = sym.decl ? sym.decl.pos : pos_builtin;
    if (old_sym.decl) {
      warning(old_sym.decl.pos, "Previous definition of '%s'", name);
    }
    fatal_error(pos, "Duplicate definition of global symbol '%s'.", name);
  }
  map_put(&current_package.syms_map, name, sym);
  buf_push(&current_package.syms as &&void, &sym, sizeof(sym));
}

def sym_global_type(name: *const char, type: &Type) -> &Sym {
  name = str_intern(name);
  let mut sym = sym_new(Sym.Type, name, NULL);
  sym.state = SymState.Resolved;
  sym.type = type;
  sym.external_name = name;
  sym_global_put(name, sym);
  return sym;
}

def sym_track_ref_type(sym: &Sym, type: &Typespec) {
  let mut decl = sym.decl;
  if (!decl) {
    return;
  }
  if (type.kind == Typespec.Name) {
    type.decl = decl;
  }
  buf_push(&decl.refs.items as &&void, &type, sizeof(type));
  ++decl.refs.length;
}

def build_scoped_name(space: *const char, name: *const char) -> *const char {
  let mut scoped_name_buf: *char;
  buf_printf(&scoped_name_buf, "%s_%s", space, name);
  let mut scoped_name = str_intern(scoped_name_buf);
  buf_free(&scoped_name_buf as &&void);
  return scoped_name;
}

def sym_global_decl(decl: &Decl, scope: *const char) -> &Sym {
  let mut sym: &Sym = NULL;
  if (decl.name) {
    sym = sym_decl(decl);
    sym_global_put(sym.name, sym);
    if (!scope) {
      scope = decl.name;
    }
  }
  if (decl.kind == Decl.Struct && decl.aggregate.union_enum_decl) {
    // Declare global symbols from the implicit enum, if not done already.
    // Generics can cause a pass through here again.
    // TODO Some way to avoid later passes before we get here?
    let mut done = false;
    let mut enum_name = decl.aggregate.union_enum_decl.name;
    if (enum_name) {
      let mut enum_sym = resolve_name(enum_name);
      done =
        enum_sym && enum_sym.decl &&
        enum_sym.decl == decl.aggregate.union_enum_decl;
    }
    if (!done) {
      sym_global_decl(decl.aggregate.union_enum_decl, decl.name);
    }
  } else if (decl.kind == Decl.Enum) {
    // TODO Extract function.
    let mut unscoped =
      !decl.name ||
      get_decl_note(decl, foreign_name) ||
      get_decl_note(decl, unscoped_name);
    let mut name = sym ? sym.name : str_intern("int");
    let mut enum_typespec = new_typespec_name1(decl.pos, name);
    let mut prev_item_name: *const char = NULL;
    let mut prev_scoped_name: *const char = NULL;
    for (decl.enum_decl.items) do(item) {
      let mut init: &Expr;
      if (item.init) {
        init = item.init;
      } else if (prev_item_name) {
        init = new_expr_binary(
          item.pos, TokenKind.Add, new_expr_name(item.pos, prev_item_name),
          new_expr_int(item.pos, 1, 0, 0),
        );
      } else {
        init = new_expr_int(item.pos, 0, 0, 0);
      }
      if (unscoped) {
        let mut item_decl =
          new_decl_const(item.pos, item.name, enum_typespec, init);
        item_decl.notes = decl.notes;
        sym_global_decl(item_decl, NULL);
        prev_item_name = item.name;
      } else {
        // Type-name-qualified version.
        // Even if generating outside C, we need namespace conflicts at this
        // level, because this is the canonical top-level namespace
        // interpretation.
        decl.enum_decl.scope = scope;
        let mut scoped_name = build_scoped_name(scope, item.name);
        if (prev_scoped_name) {
          init = new_expr_binary(
            item.pos,
            TokenKind.Add,
            new_expr_name(item.pos, prev_scoped_name),
            new_expr_int(item.pos, 1, 0, 0),
          );
        }
        let mut scoped_decl =
          new_decl_const(item.pos, scoped_name, enum_typespec, init);
        scoped_decl.notes = decl.notes;
        sym_global_decl(scoped_decl, NULL);
        prev_scoped_name = scoped_name;
      }
    }
  }
  return sym;
}

def put_type_name(buf: **char, type: &Type) {
  let mut type_name = type_names[type.kind];
  if (type_name) {
    buf_printf(buf, "%s", type_name);
  } else {
    @complete
    switch (type.kind) {
      Struct, Union, Enum, Incomplete => {
        #assert(type.sym);
        buf_printf(buf, "%s", type.sym.name);
      }
      Const => {
        buf_printf(buf, "const ");
        put_type_name(buf, type.base);
      }
      Ptr => {
        buf_printf(buf, "*");
        put_type_name(buf, type.base);
      }
      Ref => {
        buf_printf(buf, "&");
        put_type_name(buf, type.base);
      }
      Array => {
        buf_printf(buf, "[%zu]", type.num_elems);
        put_type_name(buf, type.base);
      }
      Func => {
        buf_printf(buf, "do(");
        for (type.function.params) do(param, i) {
          if (i) {
            buf_printf(buf, ", ");
          }
          put_type_name(buf, param);
        }
        if (type.function.has_varargs) {
          buf_printf(buf, "...");
        }
        buf_printf(buf, ")");
        if (type.function.ret != type_void) {
          buf_printf(buf, " -> ");
          put_type_name(buf, type.function.ret);
        }
      }
    } switch;
  } if;
}

def get_type_name(type: &Type) -> *char {
  let mut buf: *char = NULL;
  put_type_name(&buf, type);
  return buf;
}

struct Operand {
  type: &Type;
  type_orig: &Type;
  is_lvalue: bool;
  is_const: bool;
  is_type: bool;
  val: Val;
}

let mut operand_null: Operand;

def operand_rvalue(type: &Type) -> Operand {
  return Operand {
    type: unqualify_type(type),
    type_orig: type,
  };
}

def operand_lvalue(type: &Type) -> Operand {
  return Operand {
    type: type,
    type_orig: type,
    is_lvalue: true,
  };
}

def operand_const(type: &Type, val: Val) -> Operand {
  return Operand {
    type: unqualify_type(type),
    type_orig: type,
    is_const: true,
    val: val,
  };
}

def type_decay(type: &Type) -> &Type {
  type = unqualify_type(type);
  if (type.kind == CompilerTypeKind.Array) {
    type = type_ptr(type.base);
  }
  return type;
}

def operand_decay(operand: Operand) -> Operand {
  operand.type = type_decay(operand.type);
  operand.is_lvalue = false;
  return operand;
}

def operand_type(type: &Type) -> Operand {
  // TODO Make sure other uses fail (like i = type, or type = blah, or ...).
  return Operand {
    type: type,
    type_orig: type,
    is_type: true,
  };
}

// #define CASE(k, t)

def is_convertible(operand: &Operand, dest: &Type) -> bool {
  dest = unqualify_type(dest);
  let mut src = unqualify_type(operand.type);
  if (dest == src) {
    return true;
  } else if (is_arithmetic_type(dest) && is_arithmetic_type(src)) {
    return true;
  } else if (is_ptr_like_type(dest) && is_null_ptr(*operand)) {
    return true;
  } else if (is_ptr_type(dest) && is_ptr_type(src)) {
    if (is_const_type(dest.base) && is_const_type(src.base)) {
      return dest.base.base == src.base.base || dest.base.base == type_void || src.base.base == type_void;
    } else {
      let mut unqual_dest_base = unqualify_type(dest.base);
      if (unqual_dest_base == src.base) {
        return true;
      } else if (unqual_dest_base == type_void) {
        return is_const_type(dest.base) || !is_const_type(src.base);
      } else {
        return src.base == type_void;
      }
    } if;
  } else {
    return false;
  }
}

def is_castable(operand: &Operand, dest: &Type) -> bool {
  let mut src = operand.type;
  if (is_convertible(operand, dest)) {
    return true;
  } else if (is_integer_type(dest)) {
    return is_ptr_like_type(src);
  } else if (is_integer_type(src)) {
    return is_ptr_like_type(dest);
  } else if (is_ptr_like_type(dest) && is_ptr_like_type(src)) {
    return true;
  } else {
    return false;
  }
}

@foreign
def cast_operand(operand: &Operand, type: &Type) -> bool;

def convert_operand(operand: &Operand, type: &Type) -> bool {
  if (is_convertible(operand, type)) {
    cast_operand(operand, type);
    operand.type = unqualify_type(operand.type);
    operand.is_lvalue = false;
    return true;
  }
  return false;
}

// #undef CASE

def is_null_ptr(operand: Operand) -> bool {
  if (operand.is_const && (is_ptr_type(operand.type) || is_integer_type(operand.type))) {
    cast_operand(&operand, type_ullong);
    return operand.val.ull == 0;
  } else {
    return false;
  }
}

def promote_operand(operand: &Operand) {
  switch (operand.type.kind) {
    Bool, Char, SChar, UChar, Short, UShort, Enum => {
      cast_operand(operand, type_int);
    }
    default => {}
  }
}

def unify_arithmetic_operands(left: &Operand, right: &Operand) {
  if (left.type == type_double) {
    cast_operand(right, type_double);
  } else if (right.type == type_double) {
    cast_operand(left, type_double);
  } else if (left.type == type_float) {
    cast_operand(right, type_float);
  } else if (right.type == type_float) {
    cast_operand(left, type_float);
  } else {
    #assert(is_integer_type(left.type));
    #assert(is_integer_type(right.type));
    promote_operand(left);
    promote_operand(right);
    if (left.type != right.type) {
      if (is_signed_type(left.type) == is_signed_type(right.type)) {
        if (type_rank(left.type) <= type_rank(right.type)) {
          cast_operand(left, right.type);
        } else {
          cast_operand(right, left.type);
        }
      } else if (is_signed_type(left.type) && type_rank(right.type) >= type_rank(left.type)) {
        cast_operand(left, right.type);
      } else if (is_signed_type(right.type) && type_rank(left.type) >= type_rank(right.type)) {
        cast_operand(right, left.type);
      } else if (is_signed_type(left.type) && type_sizeof(left.type) > type_sizeof(right.type)) {
        cast_operand(right, left.type);
      } else if (is_signed_type(right.type) && type_sizeof(right.type) > type_sizeof(left.type)) {
        cast_operand(left, right.type);
      } else {
        let mut type = unsigned_type(is_signed_type(left.type) ? left.type : right.type);
        cast_operand(left, type);
        cast_operand(right, type);
      }
    } if;
  } if;
  #assert(left.type == right.type);
}

let mut resolved_val_map: Map;

def get_resolved_val(ptr: &void) -> Val {
  let mut u64: uint64 = map_get_uint64(&resolved_val_map, ptr);
  let mut val: Val;
  #assert(sizeof(val) == sizeof(u64));
  memcpy(&val, &u64, sizeof(u64));
  return val;
}

def set_resolved_val(ptr: &void, val: Val) {
  let mut u64: uint64;
  #assert(sizeof(val) == sizeof(u64));
  memcpy(&u64, &val, sizeof(val));
  map_put_uint64(&resolved_val_map, ptr, u64);
}

let mut resolved_type_map: Map;

def get_resolved_type(ptr: &void) -> &Type {
  return map_get(&resolved_type_map, ptr);
}

def set_resolved_type(ptr: &void, type: &Type) {
  map_put(&resolved_type_map, ptr, type);
}

let mut resolved_type_orig_map: Map;

def get_resolved_type_orig(ptr: &void) -> &Type {
  return map_get(&resolved_type_orig_map, ptr);
}

def set_resolved_type_orig(ptr: &void, type: &Type) {
  map_put(&resolved_type_orig_map, ptr, type);
}

let mut resolved_sym_map: Map;

def get_resolved_sym(ptr: &const void) -> &Sym {
  return map_get(&resolved_sym_map, ptr);
}

def set_resolved_sym(ptr: &const void, sym: &Sym) {
  if (!is_local_sym(sym)) {
    map_put(&resolved_sym_map, ptr, sym);
  }
}

let mut resolved_expected_type_map: Map;

def get_resolved_expected_type(expr: &Expr) -> &Type {
  return map_get(&resolved_expected_type_map, expr);
}

def set_resolved_expected_type(expr: &Expr, type: &Type) {
  if (expr && type) {
    map_put(&resolved_expected_type_map, expr, type);
  }
}

def resolve_expr(expr: &Expr) -> Operand {
  return resolve_expected_expr(expr, NULL);
}

def resolve_expr_rvalue(expr: &Expr) -> Operand {
  return operand_decay(resolve_expr(expr));
}

def resolve_expected_expr_rvalue(expr: &Expr, expected_type: &Type) -> Operand {
  return operand_decay(resolve_expected_expr(expr, expected_type));
}

def get_nested_type_sym(
  scope_sym: &Sym, num_names: usize, names: *TypespecName,
) -> &Sym {
  // Just check for simple union enum Kind for now, but go more general later.
  // TODO Build generic subtype collection for each (aggregate?) type.
  if (scope_sym.decl) {
    switch (scope_sym.decl.kind) {
      Struct, Union => {
        if (scope_sym.decl.aggregate.union_enum_decl) {
          if (num_names == 1 && !strcmp(names[0].name, "Kind")) {
            let mut enum_decl = scope_sym.decl.aggregate.union_enum_decl.enum_decl;
            let mut sym = resolve_name(build_scoped_name(enum_decl.scope, "Kind"));
            return sym;
          }
        }
      }
      default => {}
    }
  } if;
  return NULL;
}

def resolve_specialized_decl(
  pos: SrcPos, sym: &Sym, type_args: Slice<TypeArg>, shallow: bool,
) -> &Sym {
  if (!(sym.decl && sym.decl.name)) {
    fatal_error(pos, "Undeclared generic type");
    return NULL;
  }
  let mut decl = sym.decl;
  let mut type_params = decl.type_params;
  if (type_args.length != type_params.length) {
    fatal_error(pos, "Typespec with wrong number of arguments");
    return NULL;
  }
  // Choose name.
  // Base name on type names, even if typedef'd, so's to allow some name choice.
  // Clever could be to make them typedefs to a common struct definition or
  // such.
  let mut name = decl.name;
  for &(type_args) do(type_arg) {
    // If this is a specialized type, its type args will have been resolved
    // before we get here.
    let mut arg_typespec = type_arg.val;
    let mut arg_name = get_typespec_sym_name(arg_typespec);
    // TODO Worth the effort of varargs to avoid repeated substrings?
    name = build_scoped_name(name, arg_name);
    buf_free(&arg_name as &&void);
  }
  let mut is_generic = false;
  for &(type_args) do(type_arg) {
    if (find_generic(type_arg.val)) {
      // printf("Found generic type arg under: %s\n", name);
      is_generic = true;
      break;
    }
  }
  // TODO Check for previous resolution for this name before rebuilding.
  let mut dupe_sym = resolve_name(name);
  if (dupe_sym) {
    if (shallow || !dupe_sym.decl.shallow) {
      return dupe_sym;
    }
  }
  let mut type_map = TypeMap{type_args, type_params};
  let mut map = MapClosure{self: &type_map, call: map_type_args as MapClosureCall};
  let mut dupe: &Decl;
  switch (decl.kind) {
    Func => {
      // TODO Simplify some of the code based on what we decided and assert.
      #assert(shallow);
      dupe = new_decl(Decl.Func, decl.pos, name);
      dupe.function = dupe_function(decl.function, shallow, &map);
    }
    Struct, Union => {
      let mut dupe_agg = dupe_aggregate(decl.aggregate, &map);
      dupe = new_decl_aggregate(
        decl.pos, decl.kind, name, <Slice<Decl>>{}, dupe_agg,
      );
    }
    default => {
      fatal_error(pos, "Unsupported generic construct");
      return NULL;
    }
  }
  dupe.is_generic = is_generic;
  dupe.generic_base = decl;
  dupe.type_args = type_args;
  dupe.shallow = shallow;
  dupe_sym = sym_global_decl(dupe, NULL);
  resolve_sym(dupe_sym);
  return dupe_sym;
}

def resolve_typespec(typespec: &Typespec) -> &Type {
  if (!typespec) {
    return type_void;
  }
  let mut result: &Type;
  switch (typespec.kind) {
    Name => {
      let mut sym: &Sym;
      let mut name: *const char;
      let mut typespec_name: &TypespecName;
      // Track references to type params.
      if (typespec.names.length == 1) {
        // See if it's a type parameter.
        // TODO Also allow locally defined types (?), so support num_names > 1.
        // TODO Requires better node tree of types rather than slice of names.
        typespec_name = &typespec.names[0];
        name = typespec_name.name;
        // if (!strcmp(name, "Numb")) {
        //   printf("Try'n'a find it at line %d\n", typespec.pos.line);
        // }
        sym = sym_get_local(name);
        if (sym) {
          // if (!strcmp(name, "Numb")) {
          //   printf("Did find it.\n");
          // }
          sym_track_ref_type(sym, typespec);
        }
      }
      // Now move on.
      if (!sym) {
        let mut package = current_package;
        for (let mut i: usize = 0; i < typespec.names.length - 1; ++i) {
          let mut scope = typespec.names[i].name;
          let mut scope_sym = get_package_sym(package, scope);
          if (!scope_sym) {
            fatal_error(typespec.pos, "Unresolved scope '%s'", scope);
            return NULL;
          }
          if (scope_sym.kind == Sym.Type) {
            // TODO Check type args before continuing!
            package = NULL;
            sym = get_nested_type_sym(
              scope_sym,
              typespec.names.length - i - 1,
              typespec.names.items + i + 1,
            );
            break;
          } else if (scope_sym.kind != Sym.Package) {
            fatal_error(
              typespec.pos, "%s must denote a type or a package", scope,
            );
            return NULL;
          }
          package = scope_sym.package;
        } for;
        typespec_name = &typespec.names[typespec.names.length - 1];
        name = typespec_name.name;
        if (package) {
          sym = get_package_sym(package, name);
        }
      } if;
      if (!sym) {
        // TODO Report full type string here, not just final.
        fatal_error(typespec.pos, "Unresolved type name '%s'", name);
        return NULL;
      }
      if (sym.kind != Sym.Type) {
        // TODO Report full type string here, not just final.
        fatal_error(typespec.pos, "%s must denote a type", name);
        return NULL;
      }
      // Resolve the outer sym.
      resolve_sym(sym);
      // And maybe go deeper before done.
      if (typespec_name.type_args.length) {
        // Recursively resolve type args.
        for (typespec_name.type_args) do(type_arg) {
          resolve_typespec(type_arg.val);
        }
        // Complete the type, so we can create the custom version.
        // TODO Can we defer type completion past here?
        complete_type(sym.type);
        sym = resolve_specialized_decl(
          typespec.pos, sym, typespec_name.type_args, false,
        );
      }
      set_resolved_sym(typespec, sym);
      result = sym.type;
    }
    Const => result = type_const(resolve_typespec(typespec.base));
    Ptr => result = type_ptr(resolve_typespec(typespec.base));
    Ref => result = type_ref(resolve_typespec(typespec.base));
    Array => {
      let mut size = 0;
      if (typespec.num_elems) {
        let mut operand = resolve_const_expr(typespec.num_elems);
        if (!is_integer_type(operand.type)) {
          fatal_error(typespec.pos, "Array size constant expression must have integer type");
        }
        cast_operand(&operand, type_int);
        size = operand.val.i;
        if (size <= 0) {
          fatal_error(typespec.num_elems.pos, "Non-positive array size");
        }
      } if;
      result = type_array(resolve_typespec(typespec.base), size);
    }
    Func => {
      let mut args: *&Type = NULL;
      for (typespec.function.args) do(arg) {
        let mut arg_type = resolve_typespec(arg);
        if (arg_type == type_void) {
          fatal_error(typespec.pos, "Function parameter type cannot be void");
        }
        buf_push(&args as &&void, &arg_type, sizeof(arg_type));
      } for;
      let mut ret = type_void;
      if (typespec.function.ret) {
        ret = resolve_typespec(typespec.function.ret);
      }
      if (is_array_type(ret)) {
        fatal_error(typespec.pos, "Function return type cannot be array");
      }
      result = type_func(args, buf_len(args), ret, false);
    }
    default => {
      #assert(0);
      return NULL;
    }
  }
  set_resolved_type(typespec, result);
  return result;
}

def push_type_params(decl: &Decl) {
  let mut params = decl.type_params;
  for &(params) do(param) {
    #assert(param.kind == Decl.Typedef);
    // TODO If constraint is null, use val as constraint.
    let mut constraint = resolve_typespec(param.typedef_decl.constraint);
    // TODO Make a new type for this param itself, so we can remember it later.
    // if (!strcmp(param.name, "Num")) {
    //   printf("Pushed it.\n");
    // }
    sym_push_local(Sym.Type, param.name, constraint, param);
  }
}

def complete_aggregate(type: &Type, aggregate: &Aggregate) -> &Type {
  let mut fields: *TypeField;
  let mut scope = sym_enter();
  // TODO Extract a function of this.
  if (type && type.sym && type.sym.decl) {
    push_type_params(type.sym.decl);
  }
  for (aggregate.members) do(member) {
    if (member.kind == Member.Field) {
      let mut member_type = resolve_typespec(member.type);
      complete_type(member_type);
      // if (type_sizeof(member_type) == 0) {
      //   fatal_error(member.pos, "Field type of size 0 is not allowed");
      // }
      let mut type_field = TypeField{member.name, type: member_type};
      buf_push(&fields as &&void, &type_field, sizeof(type_field));
    } else {
      #assert(member.kind == Member.Subaggregate);
      let mut member_type = complete_aggregate(NULL, member.subaggregate);
      let mut type_field = TypeField{type: member_type};
      buf_push(&fields as &&void, &type_field, sizeof(type_field));
    }
  } for;
  if (!type) {
    type = type_incomplete(NULL);
    type.kind = CompilerTypeKind.Completing;
  }
  if (aggregate.kind == AggregateKind.Struct) {
    type_complete_struct(type, fields, buf_len(fields));
  } else {
    #assert(aggregate.kind == AggregateKind.Union);
    type_complete_union(type, fields, buf_len(fields));
  }
  if (type.aggregate.fields.length == 0) {
    fatal_error(aggregate.pos, "No fields");
  }
  if (has_duplicate_fields(type)) {
    fatal_error(aggregate.pos, "Duplicate fields");
  }
  // TODO Move arg resolution here-ish?
  sym_leave(scope);
  return type;
}

def complete_type(type: &Type) {
  if (type.kind == CompilerTypeKind.Completing) {
    fatal_error(type.sym.decl.pos, "Type completion cycle");
    return;
  } else if (type.kind != CompilerTypeKind.Incomplete) {
    return;
  }
  let mut sym = type.sym;
  let mut old_package = enter_package(sym.home_package);
  let mut decl = sym.decl;
  if (decl.is_incomplete) {
    fatal_error(decl.pos, "Trying to use incomplete type as complete type");
  }
  type.kind = CompilerTypeKind.Completing;
  #assert(decl.kind == Decl.Struct || decl.kind == Decl.Union);
  complete_aggregate(type, decl.aggregate);
  buf_push(&sorted_syms as &&void, &type.sym, sizeof(type.sym));
  leave_package(old_package);
}

def resolve_typed_init(pos: SrcPos, type: &Type, expr: &Expr) -> &Type {
  let mut expected_type = unqualify_type(type);
  let mut operand: Operand = resolve_expected_expr(expr, expected_type);
  if (is_incomplete_array_type(type) && is_array_type(operand.type) && type.base == operand.type.base) {
    // Incomplete array size, so infer the size from the initializer expression's type.
  } else {
    if (type && is_ptr_type(type)) {
      operand = operand_decay(operand);
    }
    if (!convert_operand(&operand, expected_type)) {
      return NULL;
    }
  }
  set_resolved_expected_type(expr, operand.type);
  return operand.type;
}

def resolve_init(pos: SrcPos, typespec: &Typespec, expr: &Expr) -> &Type {
  let mut type: &Type;
  if (typespec) {
    let mut declared_type = resolve_typespec(typespec);
    type = declared_type;
    if (expr) {
      let mut expr_type = resolve_typed_init(pos, declared_type, expr);
      if (!expr_type) {
        fatal_error(pos, "Invalid type in initialization. Expected %s", get_type_name(declared_type));
      }
      // Hack to support inferred array sizes, but we might also be losing
      // things from the declared type.
      // TODO Make a new declared type with the size added in.
      if (expr_type.kind == CompilerTypeKind.Array) {
        type = expr_type;
      }
    } if;
  } else {
    #assert(expr);
    type = unqualify_type(resolve_expr(expr).type);
    if (is_array_type(type) && expr.kind != Expr.Compound) {
      type = type_decay(type);
      set_resolved_type(expr, type);
    }
    set_resolved_expected_type(expr, type);
  }
  complete_type(type);
  // TODO Move arg resolution here-ish?
  if (!type.size) {
    if (is_generic_type(type)) {
      fatal_error(pos, "Cannot declare variable of raw generic type");
    } else {
      fatal_error(pos, "Cannot declare variable of size 0");
    }
  }
  return type;
}

def resolve_decl_var(decl: &Decl) -> &Type {
  #assert(decl.kind == Decl.Var);
  return resolve_init(decl.pos, decl.var_decl.type, decl.var_decl.expr);
}

def resolve_decl_const(decl: &Decl, val: &Val) -> &Type {
  #assert(decl.kind == Decl.Const);
  let mut result = resolve_const_expr(decl.const_decl.expr);
  if (!is_scalar_type(result.type)) {
    fatal_error(decl.pos, "Const declarations must have scalar type");
  }
  if (decl.const_decl.type) {
    let mut type = resolve_typespec(decl.const_decl.type);
    if (!convert_operand(&result, type)) {
      fatal_error(decl.pos, "Invalid type in constant declaration. Expected %s, got %s", get_type_name(type), get_type_name(result.type));
    }
  }
  *val = result.val;
  return result.type;
}

def resolve_decl_func(decl: &Decl) -> &Type {
  #assert(decl.kind == Decl.Func);
  let mut scope = sym_enter();
  let mut has_type_params = !!decl.type_params.length;
  // if (!strcmp(decl.name, "sum")) {
  //   printf("I'm at sum ...\n");
  // }
  // if (has_type_params) {
  //   printf("Should be pushin'.\n");
  // }
  push_type_params(decl);
  let mut params: *&Type = NULL;
  for &(decl.function.params) do(param) {
    let mut param_type = resolve_typespec(param.type);
    complete_type(param_type);
    if (!has_type_params && param_type == type_void) {
      fatal_error(decl.pos, "Function parameter type cannot be void");
    }
    buf_push(&params as &&void, &param_type, sizeof(param_type));
  } for;
  let mut ret_type = type_void;
  if (decl.function.ret_type) {
    ret_type = resolve_typespec(decl.function.ret_type);
    complete_type(ret_type);
  }
  if (is_array_type(ret_type)) {
    fatal_error(decl.pos, "Function return type cannot be array");
  }
  sym_leave(scope);
  // if (has_type_params) {
  //   printf("Should'a popped.\n");
  // }
  return type_func(params, buf_len(params), ret_type, decl.function.has_varargs);
}

struct StmtCtx {
  is_break_legal: bool;
  is_continue_legal: bool;
}

struct Label {
  name: *const char;
  pos: SrcPos;
  referenced: bool;
  defined: bool;
}

const MAX_LABELS = 256;

let mut labels: [MAX_LABELS]Label;
let mut labels_end: *Label = labels;

def get_label(pos: SrcPos, name: *const char) -> &Label {
  let mut label: *Label;
  for (label = labels; label != labels_end; label++) {
    if (label.name == name) {
      return label;
    }
  }
  if (label == labels + MAX_LABELS) {
    fatal_error(pos, "Too many labels");
  }
  *label = {name, pos};
  labels_end++;
  return label;
}

def reference_label(pos: SrcPos, name: *const char) {
  let mut label = get_label(pos, name);
  label.referenced = true;
}

def define_label(pos: SrcPos, name: *const char) {
  let mut label = get_label(pos, name);
  if (label.defined) {
    fatal_error(pos, "Multiple definitions of label '%s'", name);
  }
  label.defined = true;
}

def resolve_labels() {
  for (let mut label = labels; label != labels_end; label++) {
    if (label.referenced && !label.defined) {
      fatal_error(label.pos, "Label '%s' referenced but not defined", label.name);
    }
    if (label.defined && !label.referenced) {
      warning(label.pos, "Label '%s' defined but not referenced", label.name);
    }
  } for;
  labels_end = labels;
}

def is_cond_operand(operand: Operand) -> bool {
  operand = operand_decay(operand);
  return is_scalar_type(operand.type);
}

def resolve_cond_expr(expr: &Expr) {
  let mut cond = resolve_expr_rvalue(expr);
  if (!is_cond_operand(cond)) {
    fatal_error(expr.pos, "Conditional expression must have scalar type");
  }
}

def resolve_stmt_block(block: StmtList, ret_type: &Type, ctx: StmtCtx) -> bool {
  let mut scope = sym_enter();
  let mut returns = false;
  let mut prev_stmt: &Stmt;
  for (block.stmts) do(stmt) {
    if (stmt.kind == Stmt.Close) {
      if (stmt.tag != prev_stmt.kind && !(
        stmt.tag == Stmt.For && prev_stmt.kind == Stmt.ForEach
      )) {
        fatal_error(stmt.pos, "Non-matching close tag");
        return false;
      }
      // Also doesn't return.
    } else {
      returns = resolve_stmt(stmt, ret_type, ctx) || returns;
    }
    prev_stmt = stmt;
  } for;
  sym_leave(scope);
  return returns;
}

def resolve_stmt_assign(stmt: &Stmt) {
  #assert(stmt.kind == Stmt.Assign);
  let mut left = resolve_expr(stmt.assign.left);
  if (!left.is_lvalue) {
    fatal_error(stmt.pos, "Cannot assign to non-lvalue");
  }
  if (is_array_type(left.type)) {
    fatal_error(stmt.pos, "Cannot assign to array");
  }
  if (left.type.nonmodifiable) {
    fatal_error(stmt.pos, "Left-hand side of assignment has non-modifiable type");
  }
  let mut assign_op_name = token_kind_name(stmt.assign.op);
  let mut binary_op = assign_token_to_binary_token[stmt.assign.op];
  let mut right = resolve_expected_expr_rvalue(stmt.assign.right, left.type);
  let mut result: Operand;
  if (stmt.assign.op == TokenKind.Assign) {
    result = right;
  } else if (stmt.assign.op == TokenKind.AddAssign || stmt.assign.op == TokenKind.SubAssign) {
    if (is_ptr_type(left.type) && is_integer_type(right.type)) {
      result = operand_rvalue(left.type);
    } else if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
      result = resolve_expr_binary_op(binary_op, assign_op_name, stmt.pos, left, right);
    } else {
      fatal_error(stmt.pos, "Invalid operand types for %s", assign_op_name);
    }
  } else {
    result = resolve_expr_binary_op(binary_op, assign_op_name, stmt.pos, left, right);
  }
  if (!convert_operand(&result, left.type)) {
    fatal_error(stmt.pos, "Invalid type in assignment. Expected %s, got %s", get_type_name(left.type), get_type_name(result.type));
  }
}

def resolve_stmt_init(stmt: &Stmt) {
  #assert(stmt.kind == Stmt.Init);
  let mut type = resolve_init(stmt.pos, stmt.init.type, stmt.init.expr);
  if (!stmt.init.is_mut) {
    // type.nonmodifiable = true;
  }
  if (!sym_push_var(stmt.init.name, type)) {
    fatal_error(stmt.pos, "Shadowed definition of local symbol");
  }
}

def resolve_static_assert(note: Note) {
  if (note.args.length != 1) {
    fatal_error(note.pos, "#static_assert takes 1 argument");
  }
  let mut operand = resolve_const_expr(note.args[0].expr);
  if (!operand.val.ull) {
    fatal_error(note.pos, "#static_assert failed");
  }
}

def resolve_stmt(stmt: &Stmt, ret_type: &Type, ctx: StmtCtx) -> bool {
  @complete
  switch (stmt.kind) {
    Return => {
      if (stmt.expr) {
        let mut operand = resolve_expected_expr_rvalue(stmt.expr, ret_type);
        if (!convert_operand(&operand, ret_type)) {
          fatal_error(stmt.pos, "Invalid type in return expression. Expected %s, got %s", get_type_name(ret_type), get_type_name(operand.type));
        }
      } else if (ret_type != type_void) {
        fatal_error(stmt.pos, "Empty return expression for function with non-void return type");
      }
      return true;
    }
    Break => {
      if (!ctx.is_break_legal) {
        fatal_error(stmt.pos, "Illegal break");
      }
      return false;
    }
    Continue => {
      if (!ctx.is_continue_legal) {
        fatal_error(stmt.pos, "Illegal continue");
      }
      return false;
    }
    Block => {
      return resolve_stmt_block(stmt.block, ret_type, ctx);
    }
    Close => {
      fatal_error(stmt.pos, "Illegal close tag");
      return false;
    }
    Note => {
      if (stmt.note.name == assert_name) {
        if (stmt.note.args.length != 1) {
          fatal_error(stmt.pos, "#assert takes 1 argument");
        }
        resolve_cond_expr(stmt.note.args[0].expr);
      } else if (stmt.note.name == static_assert_name) {
        resolve_static_assert(stmt.note);
      } else {
        warning(stmt.pos, "Unknown statement #directive '%s'", stmt.note.name);
      }
      return false;
    }
    If => {
      let mut scope = sym_enter();
      if (stmt.if_stmt.init) {
        resolve_stmt_init(stmt.if_stmt.init);
      }
      if (stmt.if_stmt.cond) {
        resolve_cond_expr(stmt.if_stmt.cond);
      } else if (!is_cond_operand(resolve_name_operand(stmt.pos, stmt.if_stmt.init.init.name))) {
        fatal_error(stmt.pos, "Conditional expression must have scalar type");
      }
      let mut returns: bool = resolve_stmt_block(stmt.if_stmt.then_block, ret_type, ctx);
      for (stmt.if_stmt.elseifs) do(elseif) {
        resolve_cond_expr(elseif.cond);
        returns = resolve_stmt_block(elseif.block, ret_type, ctx) && returns;
      }
      if (stmt.if_stmt.else_block.stmts.length) {
        returns =
          resolve_stmt_block(stmt.if_stmt.else_block, ret_type, ctx) && returns;
      } else {
        returns = false;
      }
      sym_leave(scope);
      return returns;
    }
    While, DoWhile => {
      resolve_cond_expr(stmt.while_stmt.cond);
      ctx.is_break_legal = true;
      ctx.is_continue_legal = true;
      resolve_stmt_block(stmt.while_stmt.block, ret_type, ctx);
      return false;
    }
    ForEach => {
      resolve_for_each(stmt, ret_type, ctx);
      return false;
    }
    For => {
      let mut scope = sym_enter();
      if (stmt.for_stmt.init) {
        resolve_stmt(stmt.for_stmt.init, ret_type, ctx);
      }
      if (stmt.for_stmt.cond) {
        resolve_cond_expr(stmt.for_stmt.cond);
      }
      if (stmt.for_stmt.next) {
        resolve_stmt(stmt.for_stmt.next, ret_type, ctx);
      }
      ctx.is_break_legal = true;
      ctx.is_continue_legal = true;
      resolve_stmt_block(stmt.for_stmt.block, ret_type, ctx);
      sym_leave(scope);
      return false;
    }
    Switch => {
      let mut operand = resolve_expr_rvalue(stmt.switch_stmt.expr);
      let mut enum_decl = get_type_enum_decl(operand.type);
      // TODO Support switching directly on switch aggregates, which implies
      // TODO switching on their kind.
      if (!is_integer_type(operand.type)) {
        fatal_error(stmt.pos, "Switch expression must have integer type");
      }
      ctx.is_break_legal = true;
      let mut returns = true;
      let mut has_default = false;
      for (stmt.switch_stmt.cases) do(switch_case) {
        for (switch_case.patterns) do(pattern) {
          if (pattern.is_default) {
            if (has_default) {
              fatal_error(stmt.pos, "Switch statement has multiple default clauses");
            }
            has_default = true;
            continue;
          }
          let mut start_expr = pattern.start;
          let mut start_operand =
            resolve_enum_item_or_const_expr(enum_decl, start_expr);
          if (!convert_operand(&start_operand, operand.type)) {
            fatal_error(start_expr.pos, "Invalid type in switch case expression. Expected %s, got %s", get_type_name(operand.type), get_type_name(start_operand.type));
          }
          let mut end_expr = pattern.end;
          if (end_expr) {
            let mut end_operand =
              resolve_enum_item_or_const_expr(enum_decl, end_expr);
            if (!convert_operand(&end_operand, operand.type)) {
              fatal_error(end_expr.pos, "Invalid type in switch case expression. Expected %s, got %s", get_type_name(operand.type), get_type_name(end_operand.type));
            }
            convert_operand(&start_operand, type_llong);
            set_resolved_val(start_expr, start_operand.val);
            convert_operand(&end_operand, type_llong);
            set_resolved_val(end_expr, end_operand.val);
            if (end_operand.val.ll < start_operand.val.ll) {
              fatal_error(start_expr.pos, "Case range end value cannot be less thn start value");
            }
            if (end_operand.val.ll - start_operand.val.ll >= 256) {
              fatal_error(start_expr.pos, "Case range cannot span more than 256 values");
            }
          } if;
        } for;
        if (switch_case.block.stmts.length > 1) {
          let mut last_stmt = switch_case.block.stmts[switch_case.block.stmts.length - 1];
          if (last_stmt.kind == Stmt.Break) {
            warning(last_stmt.pos, "Case blocks already end with an implicit break");
          }
        }
        returns = resolve_stmt_block(switch_case.block, ret_type, ctx) && returns;
      }
      return returns && has_default;
    }
    Assign => {
      resolve_stmt_assign(stmt);
      return false;
    }
    Init => {
      resolve_stmt_init(stmt);
      return false;
    }
    Expr => {
      resolve_expr(stmt.expr);
      return false;
    }
    Label => {
      define_label(stmt.pos, stmt.label);
      return false;
    }
    Goto => {
      reference_label(stmt.pos, stmt.label);
      return false;
    }
  }
  return false;
}

def resolve_for_each(stmt: &Stmt, ret_type: &Type, ctx: StmtCtx) {
  #assert(stmt.kind == Stmt.ForEach);
  let mut scope = sym_enter();
  // Resolve expr.
  let mut operand = resolve_expr(stmt.for_each.expr);
  set_resolved_type_orig(stmt.for_each.expr, operand.type_orig);
  let mut func = &stmt.for_each.func;
  // Assert and validate.
  #assert(!func.has_varargs);
  #assert(!func.ret_type);
  if (func.params.length > 2) {
    fatal_error(stmt.pos, "Max of 2 params allowed in for-each block");
  }
  // Infer item type, even if we don't have a var for it, since that also lets
  // us validate the iterable type.
  // TODO Allow explicit typespec influence, too.
  let mut iterable_type = resolve_for_each_type(stmt.pos, operand.type_orig, false);
  let mut item_type: &Type;
  let mut length_type: &Type;
  @complete
  switch (iterable_type.kind) {
    Array => {
      item_type = iterable_type.base;
      length_type = type_usize;
    }
    Struct => {
      let mut pos = stmt.for_each.expr.pos;
      item_type = resolve_item_type(pos, operand);
      length_type = resolve_length_type(pos, operand);
    }
  }
  if (stmt.for_each.get_ref) {
    item_type = type_ref(item_type);
  }
  if (func.params.length) {
    let mut item = &func.params[0];
    sym_push_var(item.name, item_type);
    set_resolved_type(item, item_type);
  }
  if (func.params.length > 1) {
    // TODO Validate usize if explicit typespec?
    let mut index = &func.params[1];
    sym_push_var(index.name, length_type);
  }
  stmt.for_each.length_type = length_type;
  // Resolve block.
  ctx.is_break_legal = true;
  ctx.is_continue_legal = true;
  resolve_stmt_block(func.block, ret_type, ctx);
  sym_leave(scope);
}

def resolve_item_type(pos: SrcPos, operand: Operand) -> &Type {
  // TODO Pre-intern these strings!!!
  let mut items = resolve_expr_aggregate_field(pos, operand, str_intern("items"));
  if (items.type.kind != CompilerTypeKind.Ptr) {
    fatal_error(pos, "Items collection must be a pointer");
  }
  return items.type.base;
}

def resolve_length_type(pos: SrcPos, operand: Operand) -> &Type {
  // TODO Pre-intern these strings!!!
  let mut length_type =
    resolve_expr_aggregate_field(pos, operand, str_intern("length")).type;
  // TODO Be narrower than just integer?
  if (!is_integer_type(length_type)) {
    fatal_error(pos, "Length must have integer type");
  }
  return length_type;
}

def resolve_for_each_type(pos: SrcPos, type: &Type, had_ref: bool) -> &Type {
  switch (type.kind) {
    Array => {
      // We have a fixed size, so we can make this work.
      if (had_ref) {
        // TODO Does this ever make sense?
        fatal_error(pos, "Unsupported array ref in for each loop");
      } else {
        return type;
      }
    }
    Const => {
      return resolve_for_each_type(pos, type.base, had_ref);
    }
    Ref => {
      if (had_ref) {
        // TODO Support deep dereffing?
        fatal_error(pos, "Unsupported nested refs in for each loop");
      } else {
        return resolve_for_each_type(pos, type.base, true);
      }
    }
    Struct => {
      // Presume it's slice-compatible for now.
      return type;
    }
    default => {
      fatal_error(pos, "Unsupported type in for each loop");
    }
  }
  return NULL;
}

def resolve_func_body(sym: &Sym) {
  let mut decl = sym.decl;
  #assert(decl.kind == Decl.Func);
  #assert(sym.state == SymState.Resolved);
  if (decl.is_incomplete) {
    return;
  }
  if (decl.generic_base && decl.shallow) {
    // resolve_specialized_decl
    // printf("Need to specialize: %s\n", decl.name);
    let mut type_map = TypeMap{
      type_args: decl.type_args,
      type_params: decl.generic_base.type_params,
    };
    let mut map = MapClosure{
      self: &type_map,
      call: map_type_args as MapClosureCall,
    };
    decl.function.block = dupe_block(decl.function.block, &map);
    decl.shallow = false;
  }
  let mut old_package = enter_package(sym.home_package);
  let mut scope = sym_enter();
  // Even resolution of generic form makes sense for checking constraints.
  let mut has_type_params = !!decl.type_params.length;
  // if (starts_with(decl.name, "sum_slice")) {
  //   printf("I'm at %s ...\n", decl.name);
  // }
  // if (has_type_params) {
  //   printf("Should be pushin'.\n");
  // }
  push_type_params(decl);
  for (decl.function.params) do(param) {
    let mut param_type = resolve_typespec(param.type);
    if (is_array_type(param_type)) {
      param_type = type_ptr(param_type.base);
    }
    sym_push_var(param.name, param_type);
  } for;
  let mut ret_type = resolve_typespec(decl.function.ret_type);
  #assert(!is_array_type(ret_type));
  let mut returns = resolve_stmt_block(decl.function.block, ret_type, ());
  resolve_labels();
  sym_leave(scope);
  // if (has_type_params) {
  //   printf("Should'a popped.\n");
  // }
  if (ret_type != type_void && !returns) {
    fatal_error(decl.pos, "Not all control paths return values");
  }
  leave_package(old_package);
}

def resolve_sym(sym: &Sym) {
  if (sym.state == SymState.Resolved) {
    return;
  } else if (sym.state == SymState.Resolving) {
    fatal_error(sym.decl.pos, "Cyclic dependency");
    return;
  }
  #assert(sym.state == SymState.Unresolved);
  #assert(!sym.reachable);
  if (!is_local_sym(sym)) {
    buf_push(&reachable_syms as &&void, &sym, sizeof(sym));
    sym.reachable = reachable_phase;
  }
  sym.state = SymState.Resolving;
  let mut decl = sym.decl;
  let mut old_package = enter_package(sym.home_package);
  @complete
  switch (sym.kind) {
    Type => {
      if (decl && decl.kind == Decl.Typedef) {
        sym.type = resolve_typespec(decl.typedef_decl.val);
      } else if (decl.kind == Decl.Enum) {
        // Here's where the base type is set for enums.
        let mut base = decl.enum_decl.type ? resolve_typespec(decl.enum_decl.type) : type_int;
        if (!is_integer_type(base)) {
          fatal_error(decl.pos, "Base type of enum must be integer type");
        }
        sym.type = type_enum(sym, base);
      } else {
        sym.type = type_incomplete(sym);
      }
    }
    Var => sym.type = resolve_decl_var(decl);
    Const => sym.type = resolve_decl_const(decl, &sym.val);
    Func => sym.type = resolve_decl_func(decl);
    Package => {}
  }
  leave_package(old_package);
  sym.state = SymState.Resolved;
  if (decl.is_incomplete || (decl.kind != Decl.Struct && decl.kind != Decl.Union)) {
    buf_push(&sorted_syms as &&void, &sym, sizeof(sym));
  }
}

def finalize_sym(sym: &Sym) {
  #assert(sym.state == SymState.Resolved);
  if (sym.decl && !is_decl_foreign(sym.decl) && !sym.decl.is_incomplete) {
    if (sym.kind == Sym.Type) {
      complete_type(sym.type);
    } else if (sym.kind == Sym.Func) {
      resolve_func_body(sym);
    }
  }
}

def resolve_name(name: *const char) -> &Sym {
  let mut sym = sym_get(name);
  if (!sym) {
    return NULL;
  }
  resolve_sym(sym);
  return sym;
}

def try_resolve_package(expr: &Expr) -> &Package {
  if (expr.kind == Expr.Name) {
    let mut sym = resolve_name(expr.name);
    if (sym && sym.kind == Sym.Package) {
      return sym.package;
    }
  } else if (expr.kind == Expr.Field) {
    let mut package = try_resolve_package(expr.field.expr);
    if (package) {
      let mut sym = get_package_sym(package, expr.field.name);
      if (sym && sym.kind == Sym.Package) {
        return sym.package;
      }
    }
  } if;
  return NULL;
}

def get_type_enum_decl(type: &Type) -> &DeclEnum {
  // TODO Does sym imply sym.decl?
  if (type.sym && type.sym.decl) {
    let mut decl = type.sym.decl;
    switch (type.kind) {
      CompilerTypeKind.Enum => break;
      CompilerTypeKind.Struct, CompilerTypeKind.Union => {
        if (decl.aggregate.union_enum_decl) {
          decl = decl.aggregate.union_enum_decl;
        } else {
          decl = NULL;
        }
      }
      default => decl = NULL;
    }
    if (decl) {
      return &decl.enum_decl;
    }
  } if;
  return NULL;
}

def resolve_enum_item_or_const_expr(
  enum_decl: &DeclEnum, expr: &Expr,
) -> Operand {
  if (enum_decl && expr.kind == Expr.Name) {
    if (let mut item = resolve_enum_item(enum_decl, expr, expr.name); item.type) {
      return item;
    } else {
      fatal_error(expr.pos, "No enum item named '%s'", expr.name);
      return operand_null;
    }
  } if;
  return resolve_const_expr(expr);
}

def resolve_enum_item(
  enum_decl: &DeclEnum, expr: &Expr, name: *const char,
) -> Operand {
  for (enum_decl.items) do(item) {
    if (item.name == name) {
      let mut sym = resolve_name(build_scoped_name(enum_decl.scope, item.name));
      if (sym) {
        #assert(sym.kind == Sym.Const);
        set_resolved_sym(expr, sym);
        let mut item_operand = operand_const(sym.type, sym.val);
        return item_operand;
      }
    } if;
  } for;
  return operand_null;
}

def resolve_expr_field(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Field);
  let mut package = try_resolve_package(expr.field.expr);
  if (package) {
    let mut old_package = enter_package(package);
    let mut sym = resolve_name(expr.field.name);
    let mut operand = resolve_name_operand(expr.pos, expr.field.name);
    leave_package(old_package);
    set_resolved_sym(expr, sym);
    return operand;
  }
  let mut operand = resolve_expr(expr.field.expr);
  if (operand.is_type) {
    if (let mut enum_decl = get_type_enum_decl(operand.type)) {
      let mut item = resolve_enum_item(enum_decl, expr, expr.field.name);
      if (item.type) {
        return item;
      }
    }
    fatal_error(expr.pos, "No item named '%s'", expr.field.name);
    return operand_null;
  } if;
  return resolve_expr_aggregate_field(expr.pos, operand, expr.field.name);
}

def resolve_expr_aggregate_field(
  pos: SrcPos, operand: Operand, name: *const char,
) -> Operand {
  let mut was_const_type = is_const_type(operand.type);
  let mut base_type = unqualify_type(operand.type);
  complete_type(base_type);
  if (is_ptr_type(base_type)) {
    operand = operand_lvalue(base_type.base);
    was_const_type = is_const_type(operand.type);
    base_type = unqualify_type(operand.type);
    complete_type(base_type);
  }
  if (base_type.kind != CompilerTypeKind.Struct && base_type.kind != CompilerTypeKind.Union) {
    fatal_error(pos, "Can only access fields on aggregates or pointers to aggregates");
    return operand_null;
  }
  for (base_type.aggregate.fields) do(field) {
    if (field.name == name) {
      let mut field_operand = operand.is_lvalue ?
        operand_lvalue(field.type) :
        operand_rvalue(field.type);
      if (was_const_type) {
        field_operand.type = type_const(field_operand.type);
      }
      return field_operand;
    } if;
  } for;
  fatal_error(pos, "No field named '%s'", name);
  return operand_null;
}

def eval_unary_op_ll(op: TokenKind, val: llong) -> llong {
  @complete
  switch (op) {
    Add => return +val;
    Sub => return -val;
    Neg => return ~val;
    Not => return !val;
  }
  return 0;
}

def eval_unary_op_ull(op: TokenKind, val: ullong) -> ullong {
  @complete
  switch (op) {
    Add => return +val;
    Sub => return 0ull - val;
    Neg => return ~val;
    Not => return !val;
  }
  return 0;
}

def eval_binary_op_ll(op: TokenKind, left: llong, right: llong) -> llong {
  @complete
  switch (op) {
    Mul => return left * right;
    Div => return right != 0 ? left / right : 0;
    Mod => return right != 0 ? left % right : 0;
    And => return left & right;
    Lshift => return left << right;
    Rshift => return left >> right;
    Add => return left + right;
    Sub => return left - right;
    Or => return left | right;
    Xor => return left ^ right;
    Eq => return left == right;
    NotEq => return left != right;
    Lt => return left < right;
    LtEq => return left <= right;
    Gt => return left > right;
    GtEq => return left >= right;
  }
  return 0;
}

def eval_binary_op_ull(op: TokenKind, left: ullong, right: ullong) -> ullong {
  @complete
  switch (op) {
    Mul => return left * right;
    Div => return right != 0 ? left / right : 0;
    Mod => return right != 0 ? left % right : 0;
    And => return left & right;
    Lshift => return left << right;
    Rshift => return left >> right;
    Add => return left + right;
    Sub => return left - right;
    Or => return left | right;
    Xor => return left ^ right;
    Eq => return left == right;
    NotEq => return left != right;
    Lt => return left < right;
    LtEq => return left <= right;
    Gt => return left > right;
    GtEq => return left >= right;
  }
  return 0;
}

def eval_unary_op(op: TokenKind, type: &Type, val: Val) -> Val {
  if (is_integer_type(type)) {
    let mut operand = operand_const(type, val);
    if (is_signed_type(type)) {
      cast_operand(&operand, type_llong);
      operand.val.ll = eval_unary_op_ll(op, operand.val.ll);
    } else {
      cast_operand(&operand, type_ullong);
      operand.val.ll = eval_unary_op_ull(op, operand.val.ull);
    }
    cast_operand(&operand, type);
    return operand.val;
  } else {
    return {};
  }
}

def eval_binary_op(op: TokenKind, type: &Type, left: Val, right: Val) -> Val {
  if (is_integer_type(type)) {
    let mut left_operand = operand_const(type, left);
    let mut right_operand = operand_const(type, right);
    let mut result_operand: Operand;
    if (is_signed_type(type)) {
      cast_operand(&left_operand, type_llong);
      cast_operand(&right_operand, type_llong);
      result_operand = operand_const(type_llong, {ll: eval_binary_op_ll(op, left_operand.val.ll, right_operand.val.ll)});
    } else {
      cast_operand(&left_operand, type_ullong);
      cast_operand(&right_operand, type_ullong);
      result_operand = operand_const(type_ullong, {ull: eval_binary_op_ull(op, left_operand.val.ull, right_operand.val.ull)});
    }
    cast_operand(&result_operand, type);
    return result_operand.val;
  } else {
    return {};
  }
}

def resolve_name_operand(pos: SrcPos, name: *const char) -> Operand {
  let mut sym = resolve_name(name);
  if (!sym) {
    fatal_error(pos, "Unresolved name '%s'", name);
  }
  // let mut friends = !strcmp(name, "friends");
  // if (friends) {
  //   printf("%s: %d, %zu, %p\n", typeid_kind_name(sym.type), sym.type.kind, sym.type.num_elems, sym);
  // }
  if (sym.kind == Sym.Var) {
    let mut operand = operand_lvalue(sym.type);
    if (is_array_type(operand.type)) {
      operand = operand_decay(operand);
    }
    return operand;
  } else if (sym.kind == Sym.Const) {
    return operand_const(sym.type, sym.val);
  } else if (sym.kind == Sym.Func) {
    return operand_rvalue(sym.type);
  } else if (sym.kind == Sym.Type) {
    return operand_type(sym.type);
  } else {
    #assert(false);
    fatal_error(pos, "%s must be a let mut or const", name);
    return operand_null;
  }
}

def resolve_expr_name(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Name);
  return resolve_name_operand(expr.pos, expr.name);
}

def resolve_unary_op(op: TokenKind, operand: Operand) -> Operand {
  promote_operand(&operand);
  if (operand.is_const) {
    return operand_const(operand.type, eval_unary_op(op, operand.type, operand.val));
  } else {
    return operand;
  }
}

def resolve_expr_unary(expr: &Expr) -> Operand {
  let mut operand = resolve_expr_rvalue(expr.unary.expr);
  let mut type = operand.type;
  @complete
  switch (expr.unary.op) {
    Mul => {
      if (!is_ptr_type(type)) {
        fatal_error(expr.pos, "Cannot deref non-ptr type");
      }
      return operand_lvalue(type.base);
    }
    Add, Sub => {
      if (!is_arithmetic_type(type)) {
        fatal_error(expr.pos, "Can only use unary %s with arithmetic types", token_kind_name(expr.unary.op));
      }
      return resolve_unary_op(expr.unary.op, operand);
    }
    Neg => {
      if (!is_integer_type(type)) {
        fatal_error(expr.pos, "Can only use ~ with integer types");
      }
      return resolve_unary_op(expr.unary.op, operand);
    }
    Not => {
      if (!is_scalar_type(type)) {
        fatal_error(expr.pos," Can only use ! with scalar types");
      }
      return resolve_unary_op(expr.unary.op, operand);
    }
  }
  return {};
}

def resolve_binary_op(op: TokenKind, left: Operand, right: Operand) -> Operand {
  if (left.is_const && right.is_const) {
    return operand_const(left.type, eval_binary_op(op, left.type, left.val, right.val));
  } else {
    return operand_rvalue(left.type);
  }
}

def resolve_binary_arithmetic_op(op: TokenKind, left: Operand, right: Operand) -> Operand {
  unify_arithmetic_operands(&left, &right);
  return resolve_binary_op(op, left, right);
}

def resolve_expr_binary_op(op: TokenKind, op_name: *const char, pos: SrcPos, left: Operand, right: Operand) -> Operand {
  @complete
  switch (op) {
    Mul, Div => {
      if (!is_arithmetic_type(left.type)) {
        fatal_error(pos, "Left operand of %s must have arithmetic type", op_name);
      }
      if (!is_arithmetic_type(right.type)) {
        fatal_error(pos, "Right operand of %s must have arithmetic type", op_name);
      }
      return resolve_binary_arithmetic_op(op, left, right);
    }
    Mod => {
      if (!is_integer_type(left.type)) {
        fatal_error(pos, "Left operand of %% must have integer type");
      }
      if (!is_integer_type(right.type)) {
        fatal_error(pos, "Right operand of %% must have integer type");
      }
      return resolve_binary_arithmetic_op(op, left, right);
    }
    Add => {
      if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
        return resolve_binary_arithmetic_op(op, left, right);
      } else if (is_ptr_star_type(left.type) && is_integer_type(right.type)) {
        complete_type(left.type.base);
        if (type_sizeof(left.type.base) == 0) {
          fatal_error(pos, "Cannot do pointer arithmetic with size 0 base type");
        }
        return operand_rvalue(left.type);
      } else if (is_ptr_star_type(right.type) && is_integer_type(left.type)) {
        complete_type(right.type.base);
        if (type_sizeof(right.type.base) == 0) {
          fatal_error(pos, "Cannot do pointer arithmetic with size 0 base type");
        }
        return operand_rvalue(right.type);
      } else {
        fatal_error(pos, "Operands of + must both have arithmetic type, or star pointer and integer type");
      }
    }
    Sub => {
      if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
        return resolve_binary_arithmetic_op(op, left, right);
      } else if (is_ptr_star_type(left.type) && is_integer_type(right.type)) {
        return operand_rvalue(left.type);
      } else if (is_ptr_star_type(left.type) && is_ptr_star_type(right.type)) {
        if (left.type.base != right.type.base) {
          fatal_error(pos, "Cannot subtract pointers to different types");
        }
        return operand_rvalue(type_ssize);
      } else {
        fatal_error(pos, "Operands of - must both have arithmetic type, pointer and integer type, or compatible pointer types");
      }
    }
    Lshift, Rshift => {
      if (is_integer_type(left.type) && is_integer_type(right.type)) {
        promote_operand(&left);
        promote_operand(&right);
        let mut result_type = left.type;
        let mut result: Operand;
        if (is_signed_type(left.type)) {
          cast_operand(&left, type_llong);
          cast_operand(&right, type_llong);
        } else {
          cast_operand(&left, type_ullong);
          cast_operand(&right, type_ullong);
        }
        result = resolve_binary_op(op, left, right);
        cast_operand(&result, result_type);
        return result;
      } else {
        fatal_error(pos, "Operands of %s must both have integer type", op_name);
      }
    }
    Eq, NotEq => {
      if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
        let mut result = resolve_binary_arithmetic_op(op, left, right);
        cast_operand(&result, type_int);
        return result;
      } else if (is_ptr_type(left.type) && is_ptr_type(right.type)) {
        let mut unqual_left_base = unqualify_type(left.type.base);
        let mut unqual_right_base = unqualify_type(right.type.base);
        if (unqual_left_base != unqual_right_base && unqual_left_base != type_void && unqual_right_base != type_void) {
          fatal_error(pos, "Cannot compare pointers to different types");
        }
        return operand_rvalue(type_int);
      } else if ((is_null_ptr(left) && is_ptr_type(right.type)) || (is_null_ptr(right) && is_ptr_type(left.type))) {
        return operand_rvalue(type_int);
      } else {
        fatal_error(pos, "Operands of %s must be arithmetic types or compatible pointer types", op_name);
      }
    }
    Lt, LtEq, Gt, GtEq => {
      if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
        let mut result = resolve_binary_arithmetic_op(op, left, right);
        cast_operand(&result, type_int);
        return result;
      } else if (is_ptr_type(left.type) && is_ptr_type(right.type)) {
        if (unqualify_type(left.type.base) != unqualify_type(right.type.base)) {
          fatal_error(pos, "Cannot compare pointers to different types");
        }
        return operand_rvalue(type_int);
      } else if ((is_null_ptr(left) && is_ptr_type(right.type)) || (is_null_ptr(right) && is_ptr_type(left.type))) {
        return operand_rvalue(type_int);
      } else {
        fatal_error(pos, "Operands of %s must be arithmetic types or compatible pointer types", op_name);
      }
    }
    And, Xor, Or => {
      if (is_integer_type(left.type) && is_integer_type(right.type)) {
        return resolve_binary_arithmetic_op(op, left, right);
      } else {
        fatal_error(pos, "Operands of %s must have arithmetic types", op_name);
      }
    }
    AndAnd, OrOr => {
      if (is_scalar_type(left.type) && is_scalar_type(right.type)) {
        if (left.is_const && right.is_const) {
          cast_operand(&left, type_bool);
          cast_operand(&right, type_bool);
          let mut i: int;
          if (op == TokenKind.AndAnd) {
            i = left.val.b && right.val.b;
          } else {
            #assert(op == TokenKind.OrOr);
            i = left.val.b || right.val.b;
          }
          return operand_const(type_int, {i});
        } else {
          return operand_rvalue(type_int);
        }
      } else {
        fatal_error(pos, "Operands of %s must have scalar types", op_name);
      }
    }
  } switch;
  return {};
}

def resolve_expr_binary(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Binary);
  let mut left = resolve_expr_rvalue(expr.binary.left);
  let mut right = resolve_expr_rvalue(expr.binary.right);
  let mut op: TokenKind = expr.binary.op;
  let mut op_name = token_kind_name(op);
  return resolve_expr_binary_op(op, op_name, expr.pos, left, right);
}

// struct FieldOrder {
//   field: &CompoundField;
//   index: usize;
// }

def resolve_struct_fields(fields: Slice<CompoundField>, type: &Type) {
  let mut index = 0 as usize;
  let mut had_name = false;
  // Thoughts to find the right order and reorder them.
  // TODO How to preserve expression order in the face of reordered function
  // TODO args?
  // TODO What about default arg values with a different order?
  // let mut orders = xmalloc(fields.length * sizeof<FieldOrder>);
  let mut declared_fields = type.aggregate.fields;
  for (fields) do(field) {
    if (field.kind == CompoundField.Index) {
      fatal_error(field.pos, "Index field initializer not allowed for struct/union compound literal");
    } else if (field.kind == CompoundField.Name) {
      had_name = true;
      let mut found = aggregate_item_field_index(type, field.name);
      if (found < 0) {
        fatal_error(field.pos, "Named field in compound literal does not exist");
      }
      index = found as usize;
    } else if (had_name) {
      fatal_error(field.pos, "Positional field after named field");
    }
    if (index >= declared_fields.length as int) {
      fatal_error(field.pos, "Field initializer in struct/union compound literal out of range");
    }
    let mut field_type = declared_fields[index].type;
    if (!resolve_typed_init(field.pos, field_type, field.expr)) {
      fatal_error(field.pos, "Invalid type in compound literal initializer for aggregate type. Expected %s", get_type_name(field_type));
    }
    index++;
  } for;
  // free(orders);
}

def resolve_expr_compound(expr: &Expr, expected_type: &Type) -> Operand {
  #assert(expr.kind == Expr.Compound);
  if (!expected_type && !expr.compound.type) {
    fatal_error(expr.pos, "Implicitly typed compound literals used in context without expected type");
  }
  let mut type: &Type;
  if (expr.compound.type) {
    type = resolve_typespec(expr.compound.type);
  } else {
    type = expected_type;
  }
  complete_type(type);
  let mut is_const = is_const_type(type);
  type = unqualify_type(type);
  if (type.kind == CompilerTypeKind.Struct || type.kind == CompilerTypeKind.Union) {
    if (expr.compound.kind == ExprCompound.List) {
      // TODO Check tuple usage for non-tuple structs, too!
      fatal_error(
        expr.pos, "Must use struct or tuple literal for structs or unions",
      );
    }
    resolve_struct_fields(expr.compound.fields, type);
  } else if (type.kind == CompilerTypeKind.Array) {
    if (expr.compound.kind != ExprCompound.List) {
      fatal_error(expr.pos, "Must use list literal for arrays");
    }
    let mut index: usize = 0;
    let mut max_index: usize = 0;
    for (expr.compound.fields) do(field) {
      if (field.kind == CompoundField.Name) {
        fatal_error(field.pos, "Named field initializer not allowed for array compound literals");
      } else if (field.kind == CompoundField.Index) {
        let mut operand = resolve_const_expr(field.index);
        if (!is_integer_type(operand.type)) {
          fatal_error(field.pos, "Field initializer index expression must have type int");
        }
        if (!cast_operand(&operand, type_int)) {
          fatal_error(field.pos, "Invalid type in field initializer index. Expected integer type");
        }
        if (operand.val.i < 0) {
          fatal_error(field.pos, "Field initializer index cannot be negative");
        }
        index = operand.val.i;
      } if;
      if (type.num_elems && index >= type.num_elems as int) {
        fatal_error(field.pos, "Field initializer in array compound literal out of range");
      }
      if (!resolve_typed_init(field.pos, type.base, field.expr)) {
        fatal_error(field.pos, "Invalid type in compound literal initializer for array type. Expected %s", get_type_name(type.base));
      }
      max_index = max(max_index, index);
      index++;
    } for;
    if (type.num_elems == 0) {
      type = type_array(type.base, max_index + 1);
    }
  } else {
    #assert(is_scalar_type(type));
    if (expr.compound.fields.length > 1) {
      fatal_error(expr.pos, "Compound literal for scalar type cannot have more than one operand");
    }
    if (expr.compound.fields.length == 1) {
      let mut field = expr.compound.fields[0];
      let mut init = resolve_expected_expr_rvalue(field.expr, type);
      if (!convert_operand(&init, type)) {
        fatal_error(field.pos, "Invalid type in compound literal initializer. Expected %s, got %s", get_type_name(type), get_type_name(init.type));
      }
    }
  } if;
  return operand_lvalue(is_const ? type_const(type) : type);
}

def resolve_expr_call(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Call);
  let mut verbose = false;
  let mut sym: &Sym;
  let mut called_expr = expr.call.expr;
  // TODO Deal with dot names.
  let mut function = resolve_expr_rvalue(called_expr);
  if (function.type.kind != CompilerTypeKind.Func) {
    sym = function.type.sym;
  }
  // if (!strcmp(called_expr.name, "short")) {
  //   printf("Short or something? %p\n", sym);
  //   verbose = true;
  // }
  if (!sym && called_expr.kind == Expr.Name) {
    sym = resolve_name(called_expr.name);
  }
  if (
    sym && sym.decl && sym.decl.kind == Decl.Enum &&
    sym.decl.enum_decl.kind_aggregate_decl
  ) {
    sym = get_resolved_sym(sym.decl.enum_decl.kind_aggregate_decl);
    set_resolved_sym(called_expr, sym);
    if (!expr.call.prefixed) {
      // Insert a reference to the same enum item up front.
      // A shallow copy should be enough since deeper resolution should match.
      let mut dupe = ast_dup.<Expr>(called_expr);
      ast_unshift.<CompoundField>(&expr.call.args, {
        kind: CompoundField.Default, dupe.pos, expr: dupe
      });
      expr.call.prefixed = true;
    }
  }
  if (sym && sym.kind == Sym.Type) {
    // This borrows from resolve_expr_compound.
    // TODO Can we unify more with there?
    let mut type = sym.type;
    complete_type(type);
    let mut is_const = is_const_type(type);
    type = unqualify_type(type);
    let mut fields = expr.call.args;
    switch (type.kind) {
      Struct, Union => {
        resolve_struct_fields(fields, type);
      }
      default => {
        #assert(is_scalar_type(type));
        if (fields.length > 1) {
          fatal_error(
            expr.pos,
            "Compound literal for scalar type cannot have more than one operand"
          );
        }
        if (fields.length == 1) {
          let mut field = fields[0];
          let mut init = resolve_expected_expr_rvalue(field.expr, type);
          if (!convert_operand(&init, type)) {
            fatal_error(
              field.pos,
              "Invalid type in compound literal initializer. Expected %s, got %s",
              get_type_name(type), get_type_name(init.type),
            );
          }
        }
      }
    } switch;
    // set_resolved_sym(called_expr, sym);
    return operand_lvalue(is_const ? type_const(type) : type);
  } if;
  if (function.type.kind != CompilerTypeKind.Func) {
    fatal_error(expr.pos, "Cannot call non-function value");
  }
  let mut is_generic = false;
  let mut type_args: Slice<TypeArg>;
  let mut decl: &Decl;
  if (sym && sym.decl && sym.decl.kind == Decl.Func) {
    decl = sym.decl;
    if (decl.is_generic) {
      is_generic = true;
      // printf("Calling generic!\n");
      @complete
      switch (called_expr.kind) {
        Field => {
          type_args = called_expr.field.type_args;
        }
        Name => {
          type_args = called_expr.type_args;
        }
      }
      if (type_args.length) {
        // This creates only a shallow specialization.
        // TODO Is it possible the full function was resolved before we get to
        // TODO this point?
        sym = resolve_specialized_decl(decl.pos, sym, type_args, true);
        // if (verbose) {
        //   printf("Hey: %s\n", sym.decl.name);
        // }
        set_resolved_sym(called_expr, sym);
        function = operand_rvalue(sym.type);
      }
    }
  }
  let mut num_params = function.type.function.params.length;
  // TODO Default args go here.
  if (expr.call.args.length < num_params) {
    fatal_error(expr.pos, "Function call with too few arguments");
  }
  if (
    expr.call.args.length > num_params && !function.type.function.has_varargs
  ) {
    fatal_error(expr.pos, "Function call with too many arguments");
  }
  if (verbose) {
    printf("Check args.\n");
  }
  for (function.type.function.params) do(param_type, i) {
    // TODO Resolve named args differently!!
    let mut arg = resolve_expected_expr_rvalue(expr.call.args[i].expr, param_type);
    if (is_generic && !type_args.length) {
      // TODO Infer type args!
      // TODO Arg types resolve deep. Sometimes that's all we have.
      // TODO But other times, we should have a way for shallow resolution.
      // TODO Find the symbol that defines the deepest name, then get that var
      // TODO type or else return type for calls, and use that.
      // TODO Or an aggregate literal or some such.
      // TODO If just a primitive literal, go with what we got.
      // printf("Checking arg: %d -> %d: %s, %d, %zu \n", arg.type.kind, arg.type.kind == CompilerTypeKind.Int, get_type_name(arg.type), expr.call.expr.kind == Expr.Name, expr.call.expr.type_args.length);
      // if (arg.type) {
      //   printf("Maybe get somewhere???\n");
      // }
    }
    if (is_array_type(param_type)) {
      param_type = type_ptr(param_type.base);
    }
    if (!convert_operand(&arg, param_type)) {
      fatal_error(expr.call.args[i].pos, "Invalid type in function call argument. Expected %s, got %s", get_type_name(param_type), get_type_name(arg.type));
    }
  } for;
  if (verbose) {
    printf("Checked.\n");
  }
  // TODO Actual slice operators.
  // for (expr.call.args[num_params:]) do(arg) {
  for (let mut i: usize = num_params; i < expr.call.args.length; i++) {
    resolve_expr_rvalue(expr.call.args[i].expr);
  }
  if (verbose) {
    printf("Got here.\n");
  }
  return operand_rvalue(function.type.function.ret);
}

def resolve_expr_ternary(expr: &Expr, expected_type: &Type) -> Operand {
  #assert(expr.kind == Expr.Ternary);
  let mut cond = resolve_expr_rvalue(expr.ternary.cond);
  if (!is_scalar_type(cond.type)) {
    fatal_error(expr.pos, "Ternary conditional must have scalar type");
  }
  let mut left = resolve_expected_expr_rvalue(expr.ternary.then_expr, expected_type);
  let mut right = resolve_expected_expr_rvalue(expr.ternary.else_expr, expected_type);
  if (left.type == right.type) {
    return operand_rvalue(left.type);
  } else if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
    unify_arithmetic_operands(&left, &right);
    if (cond.is_const && left.is_const && right.is_const) {
      return operand_const(left.type, cond.val.i ? left.val : right.val);
    } else {
      return operand_rvalue(left.type);
    }
  } else if (is_ptr_type(left.type) && is_null_ptr(right)) {
    return operand_rvalue(left.type);
  } else if (is_ptr_type(right.type) && is_null_ptr(left)) {
    return operand_rvalue(right.type);
  } else {
    fatal_error(expr.pos, "Left and right operands of ternary expression must have arithmetic types or identical types");
  }
  // This is actually unreachable, but we need to make the compiler happy.
  // TODO: How to assert convince compiler that fatal_error doesn't return?
  return Operand {};
}

def resolve_expr_index(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Index);
  let mut operand = resolve_expr_rvalue(expr.index.expr);
  let mut item_type: &Type;
  if (is_ptr_star_type(operand.type)) {
    item_type = operand.type.base;
  } else {
    if (is_aggregate_type(deref_type(operand.type))) {
      item_type = resolve_item_type(expr.pos, operand);
    } else {
      fatal_error(expr.pos, "Can only index arrays, star pointers, and slices");
    }
  }
  let mut index = resolve_expr_rvalue(expr.index.index);
  if (!is_integer_type(index.type)) {
    fatal_error(expr.pos, "Index must have integer type");
  }
  return operand_lvalue(item_type);
}

def resolve_expr_cast(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Cast);
  let mut type = resolve_typespec(expr.cast.type);
  let mut operand = resolve_expr_rvalue(expr.cast.expr);
  if (!cast_operand(&operand, type)) {
    fatal_error(expr.pos, "Invalid type cast from %s to %s", get_type_name(operand.type), get_type_name(type));
  }
  return operand;
}

def resolve_expr_int(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Int);
  let mut int_max: ullong = type_metrics[CompilerTypeKind.Int].max;
  let mut uint_max: ullong = type_metrics[CompilerTypeKind.UInt].max;
  let mut long_max: ullong = type_metrics[CompilerTypeKind.Long].max;
  let mut ulong_max: ullong = type_metrics[CompilerTypeKind.ULong].max;
  let mut llong_max: ullong = type_metrics[CompilerTypeKind.LLong].max;
  let mut val: ullong = expr.int_lit.val;
  let mut operand = operand_const(type_ullong, {ull: val});
  let mut type = type_ullong;
  if (expr.int_lit.mod == TokenMod.None) {
    let mut overflow = false;
    @complete
    switch (expr.int_lit.suffix) {
      None => {
        type = type_int;
        if (val > int_max) {
          type = type_long;
          if (val > long_max) {
            type = type_llong;
            overflow = val > llong_max;
          }
        }
      }
      U => {
        type = type_uint;
        if (val > uint_max) {
          type = type_ulong;
          if (val > ulong_max) {
            type = type_ullong;
          }
        }
      }
      L => {
        type = type_long;
        if (val > long_max) {
          type = type_llong;
          overflow = val > llong_max;
        }
      }
      UL => {
        type = type_ulong;
        if (val > ulong_max) {
          type = type_ullong;
        }
      }
      LL => {
        type = type_llong;
        overflow = val > llong_max;
      }
      ULL => type = type_ullong;
    }
    if (overflow) {
      fatal_error(expr.pos, "Integer literal overflow");
    }
  } else {
    @complete
    switch (expr.int_lit.suffix) {
      None => {
        type = type_int;
        if (val > int_max) {
          type = type_uint;
          if (val > uint_max) {
            type = type_long;
            if (val > long_max) {
              type = type_ulong;
              if (val > ulong_max) {
                type = type_llong;
                if (val > llong_max) {
                  type = type_ullong;
                }
              }
            }
          }
        }
      }
      U => {
        type = type_uint;
        if (val > uint_max) {
          type = type_ulong;
          if (val > ulong_max) {
            type = type_ullong;
          }
        }
      }
      L => {
        type = type_long;
        if (val > long_max) {
          type = type_ulong;
          if (val > ulong_max) {
            type = type_llong;
            if (val > llong_max) {
              type = type_ullong;
            }
          }
        }
      }
      UL => {
        type = type_ulong;
        if (val > ulong_max) {
          type = type_ullong;
        }
      }
      LL => {
        type = type_llong;
        if (val > llong_max) {
          type = type_ullong;
        }
      }
      ULL => type = type_ullong;
    }
  } if;
  cast_operand(&operand, type);
  return operand;
}

def resolve_expr_modify(expr: &Expr) -> Operand {
  let mut operand = resolve_expr(expr.modify.expr);
  let mut type = operand.type;
  complete_type(type);
  if (!operand.is_lvalue) {
    fatal_error(expr.pos, "Cannot modify non-lvalue");
  }
  if (type.nonmodifiable) {
    fatal_error(expr.pos, "Cannot modify non-modifiable type");
  }
  if (!(is_integer_type(type) || type.kind == CompilerTypeKind.Ptr)) {
    fatal_error(expr.pos, "%s only valid for integer and pointer types", token_kind_name(expr.modify.op));
  }
  return operand_rvalue(type);
}

def resolve_expected_expr(expr: &Expr, expected_type: &Type) -> Operand {
  let mut result: Operand;
  @complete
  switch (expr.kind) {
    Paren => result = resolve_expected_expr(expr.arg, expected_type);
    Int => result = resolve_expr_int(expr);
    Float => result = operand_const(
      expr.float_lit.suffix == TokenSuffix.D ? type_double : type_float, {},
    );
    Str => result =
      operand_rvalue(type_array(type_char, strlen(expr.str_lit.val) + 1));
    Name => {
      result = resolve_expr_name(expr);
      set_resolved_sym(expr, resolve_name(expr.name));
    }
    Cast => result = resolve_expr_cast(expr);
    Call => result = resolve_expr_call(expr);
    Index => result = resolve_expr_index(expr);
    Field => result = resolve_expr_field(expr);
    Compound => result = resolve_expr_compound(expr, expected_type);
    Unary => {
      if (expr.unary.op == TokenKind.And) {
        let mut operand: Operand;
        if (expected_type && is_ptr_type(expected_type)) {
          operand = resolve_expected_expr(expr.unary.expr, expected_type.base);
        } else {
          operand = resolve_expr(expr.unary.expr);
        }
        if (!operand.is_lvalue) {
          fatal_error(expr.pos, "Cannot take address of non-lvalue");
        }
        result = operand_rvalue(type_ref(operand.type));
      } else {
        result = resolve_expr_unary(expr);
      }
    }
    Binary => result = resolve_expr_binary(expr);
    Ternary => result = resolve_expr_ternary(expr, expected_type);
    SizeofExpr => {
      if (expr.arg.kind == Expr.Name) {
        let mut sym = resolve_name(expr.arg.name);
        if (sym && sym.kind == Sym.Type) {
          complete_type(sym.type);
          result = operand_const(type_usize, {ull: type_sizeof(sym.type)});
          set_resolved_type(expr.arg, sym.type);
          set_resolved_sym(expr.arg, sym);
          break;
        }
      }
      let mut type = resolve_expr(expr.arg).type;
      complete_type(type);
      result = operand_const(type_usize, {ull: type_sizeof(type)});
    }
    SizeofType => {
      let mut type = resolve_typespec(expr.type_arg);
      complete_type(type);
      result = operand_const(type_usize, {ull: type_sizeof(type)});
    }
    AlignofExpr => {
      if (expr.arg.kind == Expr.Name) {
        let mut sym = resolve_name(expr.arg.name);
        if (sym && sym.kind == Sym.Type) {
          complete_type(sym.type);
          result =
            operand_const(type_usize, {ull: type_alignof(sym.type)});
          set_resolved_type(expr.arg, sym.type);
          set_resolved_sym(expr.arg, sym);
          break;
        }
      }
      let mut type = resolve_expr(expr.arg).type;
      complete_type(type);
      result = operand_const(type_usize, {ull: type_alignof(type)});
    }
    AlignofType => {
      let mut type = resolve_typespec(expr.type_arg);
      complete_type(type);
      result = operand_const(type_usize, {ull: type_alignof(type)});
    }
    TypeofType => {
      let mut type = resolve_typespec(expr.type_arg);
      result = operand_const(type_ullong, {ull: type.typeid});
    }
    TypeofExpr => {
      if (expr.arg.kind == Expr.Name) {
        let mut sym = resolve_name(expr.arg.name);
        if (sym && sym.kind == Sym.Type) {
          result = operand_const(type_ullong, {ull: sym.type.typeid});
          set_resolved_type(expr.arg, sym.type);
          set_resolved_sym(expr.arg, sym);
          break;
        }
      }
      let mut type = resolve_expr(expr.arg).type;
      result = operand_const(type_ullong, {ull: type.typeid});
    }
    Offsetof => {
      let mut type = resolve_typespec(expr.offsetof_field.type);
      complete_type(type);
      if (
        type.kind != CompilerTypeKind.Struct &&
        type.kind != CompilerTypeKind.Union
      ) {
        fatal_error(
          expr.pos, "offsetof can only be used with struct/union types",
        );
      }
      let mut index = aggregate_item_field_index(type, expr.offsetof_field.name);
      if (index < 0) {
        fatal_error(
          expr.pos, "No field '%s' in type", expr.offsetof_field.name,
        );
      }
      result = operand_const(
        type_usize, {ull: type.aggregate.fields[index].offset},
      );
    }
    Modify => result = resolve_expr_modify(expr);
  }
  set_resolved_type(expr, result.type);
  return result;
}

def resolve_const_expr(expr: &Expr) -> Operand {
  let mut operand = resolve_expr(expr);
  if (!operand.is_const) {
    fatal_error(expr.pos, "Expected constant expression");
  }
  return operand;
}

let mut decl_note_names: Map;

def init_builtin_syms() {
  #assert(current_package);
  sym_global_type("void", type_void);
  sym_global_type("bool", type_bool);
  sym_global_type("char", type_char);
  sym_global_type("schar", type_schar);
  sym_global_type("uchar", type_uchar);
  sym_global_type("short", type_short);
  sym_global_type("ushort", type_ushort);
  sym_global_type("int", type_int);
  sym_global_type("uint", type_uint);
  sym_global_type("long", type_long);
  sym_global_type("ulong", type_ulong);
  sym_global_type("llong", type_llong);
  sym_global_type("ullong", type_ullong);
  sym_global_type("float", type_float);
  sym_global_type("double", type_double);
}

def add_package_decls(package: &Package) {
  for (package.decls) do(decl) {
    if (decl.kind == Decl.Note) {
      if (!map_get(&decl_note_names, decl.note.name)) {
        warning(
          decl.pos, "Unknown declaration #directive '%s'", decl.note.name,
        );
      }
      if (decl.note.name == declare_note_name) {
        if (decl.note.args.length != 1) {
          fatal_error(decl.pos, "#declare_note takes 1 argument");
        }
        let mut arg = decl.note.args[0].expr;
        if (arg.kind != Expr.Name) {
          fatal_error(decl.pos, "#declare_note argument must be name");
        }
        map_put(&decl_note_names, arg.name, 1 as &void);
      } else if (decl.note.name == static_assert_name) {
        // TODO How to handle top-level static #asserts wrt laziness/tree
        // TODO shaking?
        if (!flag_lazy) {
          resolve_static_assert(decl.note);
        }
      }
    } else if (decl.kind == Decl.Import) {
      // Add to list of imports
    } else {
      sym_global_decl(decl, NULL);
    }
  } for;
}

def is_package_dir(search_path: *const char, package_path: *const char) -> bool {
  let mut path: [MAX_PATH]char;
  path_copy(path, search_path);
  path_join(path, package_path);
  let mut iter: DirListIter;
  for (dir_list(&iter, path); iter.valid; dir_list_next(&iter)) {
    let mut ext: *const char = path_ext(iter.name);
    if (ext != iter.name && !strcmp(ext, "rio")) {
      dir_list_free(&iter);
      return true;
    }
  }
  return false;
}

def copy_package_full_path(dest: [MAX_PATH]char, package_path: *const char) -> bool {
  for (let mut i = 0; i < num_package_search_paths; i++) {
    if (is_package_dir(package_search_paths[i], package_path)) {
      path_copy(dest, package_search_paths[i]);
      path_join(dest, package_path);
      return true;
    }
  }
  return false;
}

def import_package(package_path: *const char) -> &Package {
  package_path = str_intern(package_path);
  let mut package: &Package = map_get(&package_map, package_path);
  if (!package) {
    package = xcalloc(1, sizeof(Package));
    package.path = package_path;
    if (flag_verbose) {
      printf("Importing %s\n", package_path);
    }
    let mut full_path: [MAX_PATH]char;
    if (!copy_package_full_path(full_path, package_path)) {
      return NULL;
    }
    strcpy(package.full_path, full_path);
    add_package(package);
    compile_package(package);
  } if;
  return package;
}

def import_all_package_symbols(package: &Package) {
  // TODO: should have a more general mechanism
  let mut main_name: *const char = str_intern("main");
  for (let mut i: usize = 0; i < buf_len(package.syms); i++) {
    if (package.syms[i].home_package == package && package.syms[i].name != main_name) {
      sym_global_put(package.syms[i].name, package.syms[i]);
    }
  }
}

def import_package_symbols(decl: &Decl, package: &Package) {
  for (decl.import_decl.items) do(item) {
    let mut sym = get_package_sym(package, item.name);
    if (!sym) {
      fatal_error(
        decl.pos, "Symbol '%s' does not exist in package '%s'",
        item.name, package.path,
      );
    }
    sym_global_put(item.rename ? item.rename : item.name, sym);
  }
}

def process_package_imports(package: &Package) {
  for (package.decls) do(decl) {
    if (decl.kind == Decl.Note) {
      if (decl.note.name == always_name) {
        package.always_reachable = true;
      }
    } else if (decl.kind == Decl.Import) {
      let mut path_buf: *char = NULL;
      if (decl.import_decl.is_relative) {
        buf_printf(&path_buf, "%s/", package.path);
      }
      for (decl.import_decl.names) do(name, k) {
        if (!str_islower(name)) {
          fatal_error(decl.pos, "Import name must be lower case: '%s'", name);
        }
        buf_printf(&path_buf, "%s%s", k == 0 ? "" : "/", name);
      }
      let mut imported_package = import_package(path_buf);
      if (!imported_package) {
        fatal_error(decl.pos, "Failed to import package '%s'", path_buf);
      }
      buf_free(&path_buf as &&void);
      import_package_symbols(decl, imported_package);
      if (decl.import_decl.import_all) {
        import_all_package_symbols(imported_package);
      }
      let mut sym_name = decl.name ?
        decl.name :
        decl.import_decl.names[decl.import_decl.names.length - 1];
      let mut sym = sym_new(Sym.Package, sym_name, decl);
      sym.package = imported_package;
      sym_global_put(sym_name, sym);
    } if;
  } for;
}

def parse_package(package: &Package) -> bool {
  let mut decls: *&Decl = NULL;
  let mut iter: DirListIter;
  for (dir_list(&iter, package.full_path); iter.valid; dir_list_next(&iter)) {
    if (iter.is_dir || iter.name[0] == '_' || iter.name[0] == '.') {
      continue;
    }
    let mut name: [MAX_PATH]char;
    path_copy(name, iter.name);
    let mut ext: *char = path_ext(name);
    if (ext == name || strcmp(ext, "rio")) {
      continue;
    }
    ext[-1] = 0;
    if (is_excluded_target_filename(name)) {
      continue;
    }
    let mut path: [MAX_PATH]char;
    path_copy(path, iter.base);
    path_join(path, iter.name);
    path_absolute(path);
    let mut code: *const char = read_file(path);
    if (!code) {
      fatal_error({name: path}, "Failed to read source file");
    }
    init_stream(str_intern(path), code);
    let mut file_decls = parse_decls();
    for &(file_decls) do(decl) {
      buf_push(&decls as &&void, decl, sizeof(*decl));
    }
  } for;
  package.decls = (decls, buf_len(decls));
  return package != NULL;
}

def compile_package(package: &Package) -> bool {
  if (!parse_package(package)) {
    return false;
  }
  let mut old_package = enter_package(package);
  if (buf_len(package_list) == 1) {
    init_builtin_syms();
  }
  if (builtin_package) {
    import_all_package_symbols(builtin_package);
  }
  add_package_decls(package);
  process_package_imports(package);
  leave_package(old_package);
  return true;
}

def resolve_package_syms(package: &Package) {
  let mut old_package = enter_package(package);
  for (let mut i: usize = 0; i < buf_len(package.syms); i++) {
    if (package.syms[i].home_package == package) {
      resolve_sym(package.syms[i]);
    }
  }
  leave_package(old_package);
}

def finalize_reachable_syms() {
  if (flag_verbose) {
    printf("Finalizing reachable symbols\n");
  }
  let mut prev_num_reachable: usize = 0;
  let mut num_reachable = buf_len(reachable_syms);
  for (let mut i: usize = 0; i < num_reachable; i++) {
    finalize_sym(reachable_syms[i]);
    if (i == num_reachable - 1) {
      if (flag_verbose) {
        printf("New reachable symbols:");
        for (let mut k: usize = prev_num_reachable; k < num_reachable; k++) {
          printf(" %s/%s", reachable_syms[k].home_package.path, reachable_syms[k].name);
        }
        printf("\n");
      }
      prev_num_reachable = num_reachable;
      num_reachable = buf_len(reachable_syms);
    } if;
  } for;
}
