enum SymState {
  Unresolved,
  Resolving,
  Resolved,
}

struct Sym {
  name: *const char;
  home_package: &Package;
  state: SymState;
  reachable: ReachablePhase;
  decl: &Decl;
  external_name: *const char;
  union switch {
    None => :void;
    Const, Func, Type, Var => struct {
      type: &Type;
      val: Val;
    }
    Package => package: &Package;
  }
}

struct Package {
  path: *const char;
  full_path: [MAX_PATH]char;
  decls: *&Decl;
  num_decls: usize;
  syms_map: Map;
  syms: *&Sym;
  external_name: *const char;
  always_reachable: bool;
}

const MAX_LOCAL_SYMS = 1024;

let current_package: &Package;
let builtin_package: &Package;
let package_map: Map;
let package_list: *&Package;

enum ReachablePhase = uint8 {
  None,
  Natural,
  Forced,
}

let reachable_phase = ReachablePhase.Natural;

fn get_package_sym(package: &Package, name: *const char) -> &Sym {
  return map_get(&package.syms_map, name);
}

fn add_package(package: &Package) {
  let old_package: &Package = map_get(&package_map, package.path);
  if (old_package != package) {
    #assert(!old_package);
    map_put(&package_map, package.path, package);
    buf_push((:*&void)&package_list, &package, sizeof(package));
  }
}

fn enter_package(new_package: &Package) -> &Package {
  let old_package = current_package;
  current_package = new_package;
  return old_package;
}

fn leave_package(old_package: &Package) {
  current_package = old_package;
}

let reachable_syms: *&Sym;
let sorted_syms: *&Sym;
let local_syms: [MAX_LOCAL_SYMS]Sym;
let local_syms_end: *Sym = local_syms;

fn is_local_sym(sym: &Sym) -> bool {
  return local_syms <= sym && sym < local_syms_end;
}

fn sym_new(kind: Sym.Kind, name: *const char, decl: &Decl) -> &Sym {
  let sym: &Sym = xcalloc(1, sizeof(Sym));
  sym.kind = kind;
  sym.name = name;
  sym.decl = decl;
  sym.home_package = current_package;
  set_resolved_sym(sym, sym);
  return sym;
}

fn process_decl_notes(decl: &Decl, sym: &Sym) {
  let foreign_note = get_decl_note(decl, foreign_name);
  if (foreign_note) {
    if (foreign_note.num_args > 1) {
      fatal_error(decl.pos, "@foreign takes 0 or 1 argument");
    }
    let external_name: *const char;
    if (foreign_note.num_args == 0) {
      external_name = sym.name;
    } else {
      let arg = foreign_note.args[0].expr;
      if (arg.kind != Expr.Str) {
        fatal_error(decl.pos, "@foreign argument 1 must be a string literal");
      }
      external_name = arg.str_lit.val;
    }
    sym.external_name = external_name;
  }
}

fn sym_decl(decl: &Decl) -> &Sym {
  let kind = Sym.None;
  @complete
  switch (decl.kind) {
  case Decl.Struct:
  case Decl.Union:
  case Decl.Typedef:
  case Decl.Enum:
    kind = Sym.Type;
  case Decl.Var:
    kind = Sym.Var;
  case Decl.Const:
    kind = Sym.Const;
  case Decl.Func:
    kind = Sym.Func;
  }
  let sym = sym_new(kind, decl.name, decl);
  set_resolved_sym(decl, sym);
  process_decl_notes(decl, sym);
  return sym;
}

fn sym_get_local(name: *const char) -> &Sym {
  for (let it = local_syms_end; it != local_syms; it--) {
    let sym = it-1;
    if (sym.name == name) {
      return sym;
    }
  }
  return NULL;
}

fn sym_get(name: *const char) -> &Sym {
  let sym = sym_get_local(name);
  return sym ? sym : get_package_sym(current_package, name);
}

fn sym_push_var(name: *const char, type: &Type) -> bool {
  if (sym_get_local(name)) {
    return false;
  }
  if (local_syms_end == local_syms + MAX_LOCAL_SYMS) {
    fatal("Too many local symbols");
  }
  *local_syms_end++ = Sym {
    kind = Sym.Var,
    name = name,
    state = SymState.Resolved,
    type = type,
  };
  return true;
}

fn sym_enter() -> &Sym {
  return local_syms_end;
}

fn sym_leave(sym: &Sym) {
  local_syms_end = sym;
}

fn sym_global_put(name: *const char, sym: &Sym) {
  let old_sym: &Sym = map_get(&current_package.syms_map, name);
  if (old_sym) {
    if (sym == old_sym) {
      return;
    }
    if (sym.kind == Sym.Package && old_sym.kind == Sym.Package && sym.package == old_sym.package) {
      return;
    }
    let pos = sym.decl ? sym.decl.pos : pos_builtin;
    if (old_sym.decl) {
      warning(old_sym.decl.pos, "Previous definition of '%s'", name);
    }
    fatal_error(pos, "Duplicate definition of global symbol '%s'.", name);
  }
  map_put(&current_package.syms_map, name, sym);
  buf_push((:*&void)&current_package.syms, &sym, sizeof(sym));
}

fn sym_global_type(name: *const char, type: &Type) -> &Sym {
  name = str_intern(name);
  let sym = sym_new(Sym.Type, name, NULL);
  sym.state = SymState.Resolved;
  sym.type = type;
  sym.external_name = name;
  sym_global_put(name, sym);
  return sym;
}

fn build_scoped_name(space: *const char, name: *const char) -> *const char {
  let scoped_name_buf: *char;
  buf_printf(&scoped_name_buf, "%s_%s", space, name);
  let scoped_name = str_intern(scoped_name_buf);
  buf_free((:*&void)&scoped_name_buf);
  return scoped_name;
}

fn sym_global_decl(decl: &Decl, scope: *const char) -> &Sym {
  let sym: &Sym = NULL;
  if (decl.name) {
    sym = sym_decl(decl);
    sym_global_put(sym.name, sym);
    if (!scope) {
      scope = decl.name;
    }
  }
  if (decl.kind == Decl.Struct && decl.aggregate.union_enum_decl) {
    // Declare global symbols from the implicit enum.
    sym_global_decl(decl.aggregate.union_enum_decl, decl.name);
  } else if (decl.kind == Decl.Enum) {
    // TODO Extract function.
    let unscoped =
      !decl.name ||
      get_decl_note(decl, foreign_name) ||
      get_decl_note(decl, unscoped_name);
    let name = sym ? sym.name : str_intern("int");
    let enum_typespec = new_typespec_name(decl.pos, &name, 1);
    let prev_item_name: *const char = NULL;
    let prev_scoped_name: *const char = NULL;
    for (let i: usize = 0; i < decl.enum_decl.num_items; i++) {
      let item = decl.enum_decl.items[i];
      let init: &Expr;
      if (item.init) {
        init = item.init;
      } else if (prev_item_name) {
        init = new_expr_binary(item.pos, TokenKind.Add, new_expr_name(item.pos, prev_item_name), new_expr_int(item.pos, 1, 0, 0));
      } else {
        init = new_expr_int(item.pos, 0, 0, 0);
      }
      if (unscoped) {
        let item_decl =
          new_decl_const(item.pos, item.name, enum_typespec, init);
        item_decl.notes = decl.notes;
        sym_global_decl(item_decl, NULL);
        prev_item_name = item.name;
      } else {
        // Type-name-qualified version.
        // Even if generating outside C, we need namespace conflicts at this
        // level, because this is the canonical top-level namespace
        // interpretation.
        decl.enum_decl.scope = scope;
        let scoped_name = build_scoped_name(scope, item.name);
        if (prev_scoped_name) {
          init = new_expr_binary(
            item.pos,
            TokenKind.Add,
            new_expr_name(item.pos, prev_scoped_name),
            new_expr_int(item.pos, 1, 0, 0),
          );
        }
        let scoped_decl =
          new_decl_const(item.pos, scoped_name, enum_typespec, init);
        scoped_decl.notes = decl.notes;
        sym_global_decl(scoped_decl, NULL);
        prev_scoped_name = scoped_name;
      }
    }
  }
  return sym;
}

fn put_type_name(buf: **char, type: &Type) {
  let type_name = type_names[type.kind];
  if (type_name) {
    buf_printf(buf, "%s", type_name);
  } else {
    @complete
    switch (type.kind) {
    case CompilerTypeKind.Struct:
    case CompilerTypeKind.Union:
    case CompilerTypeKind.Enum:
    case CompilerTypeKind.Incomplete:
      #assert(type.sym);
      buf_printf(buf, "%s", type.sym.name);
    case CompilerTypeKind.Const:
      put_type_name(buf, type.base);
      buf_printf(buf, " const");
    case CompilerTypeKind.Ptr:
      put_type_name(buf, type.base);
      buf_printf(buf, "*");
    case CompilerTypeKind.Ref:
      put_type_name(buf, type.base);
      buf_printf(buf, "&");
    case CompilerTypeKind.Array:
      put_type_name(buf, type.base);
      buf_printf(buf, "[%zu]", type.num_elems);
    case CompilerTypeKind.Func:
      buf_printf(buf, "fn(");
      for (let i: usize = 0; i < type.function.num_params; i++) {
        if (i != 0) {
          buf_printf(buf, ", ");
        }
        put_type_name(buf, type.function.params[i]);
      }
      if (type.function.has_varargs) {
        buf_printf(buf, "...");
      }
      buf_printf(buf, ")");
      if (type.function.ret != type_void) {
        buf_printf(buf, ": ");
        put_type_name(buf, type.function.ret);
      }
    }
  }
}

fn get_type_name(type: &Type) -> *char {
  let buf: *char = NULL;
  put_type_name(&buf, type);
  return buf;
}

struct Operand {
  type: &Type;
  is_lvalue: bool;
  is_const: bool;
  is_type: bool;
  val: Val;
}

let operand_null: Operand;

fn operand_rvalue(type: &Type) -> Operand {
  return Operand {
    type = unqualify_type(type),
  };
}

fn operand_lvalue(type: &Type) -> Operand {
  return Operand {
    type = type,
    is_lvalue = true,
  };
}

fn operand_const(type: &Type, val: Val) -> Operand {
  return Operand {
    type = unqualify_type(type),
    is_const = true,
    val = val,
  };
}

fn type_decay(type: &Type) -> &Type {
  type = unqualify_type(type);
  if (type.kind == CompilerTypeKind.Array) {
    type = type_ptr(type.base);
  }
  return type;
}

fn operand_decay(operand: Operand) -> Operand {
  operand.type = type_decay(operand.type);
  operand.is_lvalue = false;
  return operand;
}

fn operand_type(type: &Type) -> Operand {
  // TODO Make sure other uses fail (like i = type, or type = blah, or ...).
  return Operand {
    type = type,
    is_type = true,
  };
}

// #define CASE(k, t)

fn is_convertible(operand: &Operand, dest: &Type) -> bool {
  dest = unqualify_type(dest);
  let src = unqualify_type(operand.type);
  if (dest == src) {
    return true;
  } else if (is_arithmetic_type(dest) && is_arithmetic_type(src)) {
    return true;
  } else if (is_ptr_like_type(dest) && is_null_ptr(*operand)) {
    return true;
  } else if (is_ptr_type(dest) && is_ptr_type(src)) {
    if (is_const_type(dest.base) && is_const_type(src.base)) {
      return dest.base.base == src.base.base || dest.base.base == type_void || src.base.base == type_void;
    } else {
      let unqual_dest_base = unqualify_type(dest.base);
      if (unqual_dest_base == src.base) {
        return true;
      } else if (unqual_dest_base == type_void) {
        return is_const_type(dest.base) || !is_const_type(src.base);
      } else {
        return src.base == type_void;
      }
    }
  } else {
    return false;
  }
}

fn is_castable(operand: &Operand, dest: &Type) -> bool {
  let src = operand.type;
  if (is_convertible(operand, dest)) {
    return true;
  } else if (is_integer_type(dest)) {
    return is_ptr_like_type(src);
  } else if (is_integer_type(src)) {
    return is_ptr_like_type(dest);
  } else if (is_ptr_like_type(dest) && is_ptr_like_type(src)) {
    return true;
  } else {
    return false;
  }
}

@foreign
fn cast_operand(operand: &Operand, type: &Type) -> bool;

fn convert_operand(operand: &Operand, type: &Type) -> bool {
  if (is_convertible(operand, type)) {
    cast_operand(operand, type);
    operand.type = unqualify_type(operand.type);
    operand.is_lvalue = false;
    return true;
  }
  return false;
}

// #undef CASE

fn is_null_ptr(operand: Operand) -> bool {
  if (operand.is_const && (is_ptr_type(operand.type) || is_integer_type(operand.type))) {
    cast_operand(&operand, type_ullong);
    return operand.val.ull == 0;
  } else {
    return false;
  }
}

fn promote_operand(operand: &Operand) {
  switch (operand.type.kind) {
  case CompilerTypeKind.Bool:
  case CompilerTypeKind.Char:
  case CompilerTypeKind.SChar:
  case CompilerTypeKind.UChar:
  case CompilerTypeKind.Short:
  case CompilerTypeKind.UShort:
  case CompilerTypeKind.Enum:
    cast_operand(operand, type_int);
  default:
    // Do nothing
  }
}

fn unify_arithmetic_operands(left: &Operand, right: &Operand) {
  if (left.type == type_double) {
    cast_operand(right, type_double);
  } else if (right.type == type_double) {
    cast_operand(left, type_double);
  } else if (left.type == type_float) {
    cast_operand(right, type_float);
  } else if (right.type == type_float) {
    cast_operand(left, type_float);
  } else {
    #assert(is_integer_type(left.type));
    #assert(is_integer_type(right.type));
    promote_operand(left);
    promote_operand(right);
    if (left.type != right.type) {
      if (is_signed_type(left.type) == is_signed_type(right.type)) {
        if (type_rank(left.type) <= type_rank(right.type)) {
          cast_operand(left, right.type);
        } else {
          cast_operand(right, left.type);
        }
      } else if (is_signed_type(left.type) && type_rank(right.type) >= type_rank(left.type)) {
        cast_operand(left, right.type);
      } else if (is_signed_type(right.type) && type_rank(left.type) >= type_rank(right.type)) {
        cast_operand(right, left.type);
      } else if (is_signed_type(left.type) && type_sizeof(left.type) > type_sizeof(right.type)) {
        cast_operand(right, left.type);
      } else if (is_signed_type(right.type) && type_sizeof(right.type) > type_sizeof(left.type)) {
        cast_operand(left, right.type);
      } else {
        let type = unsigned_type(is_signed_type(left.type) ? left.type : right.type);
        cast_operand(left, type);
        cast_operand(right, type);
      }
    }
  }
  #assert(left.type == right.type);
}

let resolved_val_map: Map;

fn get_resolved_val(ptr: &void) -> Val {
  let u64: uint64 = map_get_uint64(&resolved_val_map, ptr);
  let val: Val;
  #assert(sizeof(val) == sizeof(u64));
  memcpy(&val, &u64, sizeof(u64));
  return val;
}

fn set_resolved_val(ptr: &void, val: Val) {
  let u64: uint64;
  #assert(sizeof(val) == sizeof(u64));
  memcpy(&u64, &val, sizeof(val));
  map_put_uint64(&resolved_val_map, ptr, u64);
}

let resolved_type_map: Map;

fn get_resolved_type(ptr: &void) -> &Type {
  return map_get(&resolved_type_map, ptr);
}

fn set_resolved_type(ptr: &void, type: &Type) {
  map_put(&resolved_type_map, ptr, type);
}

let resolved_sym_map: Map;

fn get_resolved_sym(ptr: &const void) -> &Sym {
  return map_get(&resolved_sym_map, ptr);
}

fn set_resolved_sym(ptr: &const void, sym: &Sym) {
  if (!is_local_sym(sym)) {
    map_put(&resolved_sym_map, ptr, sym);
  }
}

let resolved_expected_type_map: Map;

fn get_resolved_expected_type(expr: &Expr) -> &Type {
  return map_get(&resolved_expected_type_map, expr);
}

fn set_resolved_expected_type(expr: &Expr, type: &Type) {
  if (expr && type) {
    map_put(&resolved_expected_type_map, expr, type);
  }
}

fn resolve_expr(expr: &Expr) -> Operand {
  return resolve_expected_expr(expr, NULL);
}

fn resolve_expr_rvalue(expr: &Expr) -> Operand {
  return operand_decay(resolve_expr(expr));
}

fn resolve_expected_expr_rvalue(expr: &Expr, expected_type: &Type) -> Operand {
  return operand_decay(resolve_expected_expr(expr, expected_type));
}

fn get_nested_type_sym(
  scope_sym: &Sym, num_names: usize, names: **const char,
) -> &Sym {
  // Just check for simple union enum Kind for now, but go more general later.
  // TODO Build generic subtype collection for each (aggregate?) type.
  if (scope_sym.decl) {
    switch (scope_sym.decl.kind) {
      case Decl.Struct:
      case Decl.Union:
        if (scope_sym.decl.aggregate.union_enum_decl) {
          if (num_names == 1 && !strcmp(names[0], "Kind")) {
            let enum_decl = scope_sym.decl.aggregate.union_enum_decl.enum_decl;
            let sym = resolve_name(build_scoped_name(enum_decl.scope, "Kind"));
            return sym;
          }
        }
      default:
    }
  }
  return NULL;
}

fn resolve_typespec(typespec: &Typespec) -> &Type {
  if (!typespec) {
    return type_void;
  }
  let result: &Type;
  switch (typespec.kind) {
  case Typespec.Name: {
    let sym: &Sym;
    let package = current_package;
    for (let i: usize = 0; i < typespec.num_names - 1; ++i) {
      let scope = typespec.names[i];
      let scope_sym = get_package_sym(package, scope);
      if (!scope_sym) {
        fatal_error(typespec.pos, "Unresolved scope '%s'", scope);
        return NULL;
      }
      if (scope_sym.kind == Sym.Type) {
        package = NULL;
        sym = get_nested_type_sym(
          scope_sym, typespec.num_names - i - 1, typespec.names + i + 1,
        );
        break;
      } else if (scope_sym.kind != Sym.Package) {
        fatal_error(typespec.pos, "%s must denote a type or a package", scope);
        return NULL;
      }
      package = scope_sym.package;
    }
    let name = typespec.names[typespec.num_names - 1];
    if (package) {
      sym = get_package_sym(package, name);
    }
    if (!sym) {
      // TODO Report full type string here, not just final.
      fatal_error(typespec.pos, "Unresolved type name '%s'", name);
      return NULL;
    }
    if (sym.kind != Sym.Type) {
      // TODO Report full type string here, not just final.
      fatal_error(typespec.pos, "%s must denote a type", name);
      return NULL;
    }
    resolve_sym(sym);
    set_resolved_sym(typespec, sym);
    result = sym.type;
  }
  case Typespec.Const:
    result = type_const(resolve_typespec(typespec.base));
  case Typespec.Ptr:
    result = type_ptr(resolve_typespec(typespec.base));
  case Typespec.Ref:
    result = type_ref(resolve_typespec(typespec.base));
  case Typespec.Array: {
    let size = 0;
    if (typespec.num_elems) {
      let operand = resolve_const_expr(typespec.num_elems);
      if (!is_integer_type(operand.type)) {
        fatal_error(typespec.pos, "Array size constant expression must have integer type");
      }
      cast_operand(&operand, type_int);
      size = operand.val.i;
      if (size <= 0) {
        fatal_error(typespec.num_elems.pos, "Non-positive array size");
      }
    }
    result = type_array(resolve_typespec(typespec.base), size);
  }
  case Typespec.Func: {
    let args: *&Type = NULL;
    for (let i: usize = 0; i < typespec.function.num_args; i++) {
      let arg = resolve_typespec(typespec.function.args[i]);
      if (arg == type_void) {
        fatal_error(typespec.pos, "Function parameter type cannot be void");
      }
      buf_push((:*&void)&args, &arg, sizeof(arg));
    }
    let ret = type_void;
    if (typespec.function.ret) {
      ret = resolve_typespec(typespec.function.ret);
    }
    if (is_array_type(ret)) {
      fatal_error(typespec.pos, "Function return type cannot be array");
    }
    result = type_func(args, buf_len(args), ret, false);
  }
  default:
    #assert(0);
    return NULL;
  }
  set_resolved_type(typespec, result);
  return result;
}

fn complete_aggregate(type: &Type, aggregate: &Aggregate) -> &Type {
  let fields: *TypeField;
  for (let i: usize = 0; i < aggregate.num_items; i++) {
    let item = aggregate.items[i];
    if (item.kind == AggregateItem.Field) {
      let item_type = resolve_typespec(item.type);
      complete_type(item_type);
      // if (type_sizeof(item_type) == 0) {
      //   fatal_error(item.pos, "Field type of size 0 is not allowed");
      // }
      for (let j: usize = 0; j < item.num_names; j++) {
        let type_field = TypeField {item.names[j], item_type};
        buf_push((:*&void)&fields, &type_field, sizeof(type_field));
      }
    } else {
      #assert(item.kind == AggregateItem.Subaggregate);
      let item_type = complete_aggregate(NULL, item.subaggregate);
      let type_field = TypeField {NULL, item_type};
      buf_push((:*&void)&fields, &type_field, sizeof(type_field));
    }
  }
  if (!type) {
    type = type_incomplete(NULL);
    type.kind = CompilerTypeKind.Completing;
  }
  if (aggregate.kind == AggregateKind.Struct) {
    type_complete_struct(type, fields, buf_len(fields));
  } else {
    #assert(aggregate.kind == AggregateKind.Union);
    type_complete_union(type, fields, buf_len(fields));
  }
  if (type.aggregate.num_fields == 0) {
    fatal_error(aggregate.pos, "No fields");
  }
  if (has_duplicate_fields(type)) {
    fatal_error(aggregate.pos, "Duplicate fields");
  }
  return type;
}

fn complete_type(type: &Type) {
  if (type.kind == CompilerTypeKind.Completing) {
    fatal_error(type.sym.decl.pos, "Type completion cycle");
    return;
  } else if (type.kind != CompilerTypeKind.Incomplete) {
    return;
  }
  let sym = type.sym;
  let old_package = enter_package(sym.home_package);
  let decl = sym.decl;
  if (decl.is_incomplete) {
    fatal_error(decl.pos, "Trying to use incomplete type as complete type");
  }
  type.kind = CompilerTypeKind.Completing;
  #assert(decl.kind == Decl.Struct || decl.kind == Decl.Union);
  complete_aggregate(type, decl.aggregate);
  buf_push((:*&void)&sorted_syms, &type.sym, sizeof(type.sym));
  leave_package(old_package);
}

fn resolve_typed_init(pos: SrcPos, type: &Type, expr: &Expr) -> &Type {
  let expected_type = unqualify_type(type);
  let operand: Operand = resolve_expected_expr(expr, expected_type);
  if (is_incomplete_array_type(type) && is_array_type(operand.type) && type.base == operand.type.base) {
    // Incomplete array size, so infer the size from the initializer expression's type.
  } else {
    if (type && is_ptr_type(type)) {
      operand = operand_decay(operand);
    }
    if (!convert_operand(&operand, expected_type)) {
      return NULL;
    }
  }
  set_resolved_expected_type(expr, operand.type);
  return operand.type;
}

fn resolve_init(pos: SrcPos, typespec: &Typespec, expr: &Expr) -> &Type {
  let type: &Type;
  if (typespec) {
    let declared_type = resolve_typespec(typespec);
    type = declared_type;
    if (expr) {
      let expr_type = resolve_typed_init(pos, declared_type, expr);
      if (!expr_type) {
        fatal_error(pos, "Invalid type in initialization. Expected %s", get_type_name(declared_type));
      }
      // Hack to support inferred array sizes, but we might also be losing
      // things from the declared type.
      // TODO Make a new declared type with the size added in.
      if (expr_type.kind == CompilerTypeKind.Array) {
        type = expr_type;
      }
    }
  } else {
    #assert(expr);
    type = unqualify_type(resolve_expr(expr).type);
    if (is_array_type(type) && expr.kind != Expr.Compound) {
      type = type_decay(type);
      set_resolved_type(expr, type);
    }
    set_resolved_expected_type(expr, type);
  }
  complete_type(type);
  if (type.size == 0) {
    fatal_error(pos, "Cannot declare variable of size 0");
  }
  return type;
}

fn resolve_decl_var(decl: &Decl) -> &Type {
  #assert(decl.kind == Decl.Var);
  return resolve_init(decl.pos, decl.var_decl.type, decl.var_decl.expr);
}

fn resolve_decl_const(decl: &Decl, val: &Val) -> &Type {
  #assert(decl.kind == Decl.Const);
  let result = resolve_const_expr(decl.const_decl.expr);
  if (!is_scalar_type(result.type)) {
    fatal_error(decl.pos, "Const declarations must have scalar type");
  }
  if (decl.const_decl.type) {
    let type = resolve_typespec(decl.const_decl.type);
    if (!convert_operand(&result, type)) {
      fatal_error(decl.pos, "Invalid type in constant declaration. Expected %s, got %s", get_type_name(type), get_type_name(result.type));
    }
  }
  *val = result.val;
  return result.type;
}

fn resolve_decl_func(decl: &Decl) -> &Type {
  #assert(decl.kind == Decl.Func);
  let params: *&Type = NULL;
  for (let i: usize = 0; i < decl.function.num_params; i++) {
    let param = resolve_typespec(decl.function.params[i].type);
    complete_type(param);
    if (param == type_void) {
      fatal_error(decl.pos, "Function parameter type cannot be void");
    }
    buf_push((:*&void)&params, &param, sizeof(param));
  }
  let ret_type = type_void;
  if (decl.function.ret_type) {
    ret_type = resolve_typespec(decl.function.ret_type);
    complete_type(ret_type);
  }
  if (is_array_type(ret_type)) {
    fatal_error(decl.pos, "Function return type cannot be array");
  }
  return type_func(params, buf_len(params), ret_type, decl.function.has_varargs);
}

struct StmtCtx {
  is_break_legal: bool;
  is_continue_legal: bool;
}

struct Label {
  name: *const char;
  pos: SrcPos;
  referenced: bool;
  defined: bool;
}

const MAX_LABELS = 256;

let labels: [MAX_LABELS]Label;
let labels_end: *Label = labels;

fn get_label(pos: SrcPos, name: *const char) -> &Label {
  let label: *Label;
  for (label = labels; label != labels_end; label++) {
    if (label.name == name) {
      return label;
    }
  }
  if (label == labels + MAX_LABELS) {
    fatal_error(pos, "Too many labels");
  }
  *label = Label {name = name, pos = pos};
  labels_end++;
  return label;
}

fn reference_label(pos: SrcPos, name: *const char) {
  let label = get_label(pos, name);
  label.referenced = true;
}

fn define_label(pos: SrcPos, name: *const char) {
  let label = get_label(pos, name);
  if (label.defined) {
    fatal_error(pos, "Multiple definitions of label '%s'", name);
  }
  label.defined = true;
}

fn resolve_labels() {
  for (let label = labels; label != labels_end; label++) {
    if (label.referenced && !label.defined) {
      fatal_error(label.pos, "Label '%s' referenced but not defined", label.name);
    }
    if (label.defined && !label.referenced) {
      warning(label.pos, "Label '%s' defined but not referenced", label.name);
    }
  }
  labels_end = labels;
}

fn is_cond_operand(operand: Operand) -> bool {
  operand = operand_decay(operand);
  return is_scalar_type(operand.type);
}

fn resolve_cond_expr(expr: &Expr) {
  let cond = resolve_expr_rvalue(expr);
  if (!is_cond_operand(cond)) {
    fatal_error(expr.pos, "Conditional expression must have scalar type");
  }
}

fn resolve_stmt_block(block: StmtList, ret_type: &Type, ctx: StmtCtx) -> bool {
  let scope = sym_enter();
  let returns = false;
  for (let i: usize = 0; i < block.num_stmts; i++) {
    returns = resolve_stmt(block.stmts[i], ret_type, ctx) || returns;
  }
  sym_leave(scope);
  return returns;
}

fn resolve_stmt_assign(stmt: &Stmt) {
  #assert(stmt.kind == Stmt.Assign);
  let left = resolve_expr(stmt.assign.left);
  if (!left.is_lvalue) {
    fatal_error(stmt.pos, "Cannot assign to non-lvalue");
  }
  if (is_array_type(left.type)) {
    fatal_error(stmt.pos, "Cannot assign to array");
  }
  if (left.type.nonmodifiable) {
    fatal_error(stmt.pos, "Left-hand side of assignment has non-modifiable type");
  }
  let assign_op_name = token_kind_name(stmt.assign.op);
  let binary_op = assign_token_to_binary_token[stmt.assign.op];
  let right = resolve_expected_expr_rvalue(stmt.assign.right, left.type);
  let result: Operand;
  if (stmt.assign.op == TokenKind.Assign) {
    result = right;
  } else if (stmt.assign.op == TokenKind.AddAssign || stmt.assign.op == TokenKind.SubAssign) {
    if (is_ptr_type(left.type) && is_integer_type(right.type)) {
      result = operand_rvalue(left.type);
    } else if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
      result = resolve_expr_binary_op(binary_op, assign_op_name, stmt.pos, left, right);
    } else {
      fatal_error(stmt.pos, "Invalid operand types for %s", assign_op_name);
    }
  } else {
    result = resolve_expr_binary_op(binary_op, assign_op_name, stmt.pos, left, right);
  }
  if (!convert_operand(&result, left.type)) {
    fatal_error(stmt.pos, "Invalid type in assignment. Expected %s, got %s", get_type_name(left.type), get_type_name(result.type));
  }
}

fn resolve_stmt_init(stmt: &Stmt) {
  #assert(stmt.kind == Stmt.Init);
  let type = resolve_init(stmt.pos, stmt.init.type, stmt.init.expr);
  if (!stmt.init.is_mut) {
    // type.nonmodifiable = true;
  }
  if (!sym_push_var(stmt.init.name, type)) {
    fatal_error(stmt.pos, "Shadowed definition of local symbol");
  }
}

fn resolve_static_assert(note: Note) {
  if (note.num_args != 1) {
    fatal_error(note.pos, "#static_assert takes 1 argument");
  }
  let operand = resolve_const_expr(note.args[0].expr);
  if (!operand.val.ull) {
    fatal_error(note.pos, "#static_assert failed");
  }
}

fn resolve_stmt(stmt: &Stmt, ret_type: &Type, ctx: StmtCtx) -> bool {
  switch (stmt.kind) {
  case Stmt.Return:
    if (stmt.expr) {
      let operand = resolve_expected_expr_rvalue(stmt.expr, ret_type);
      if (!convert_operand(&operand, ret_type)) {
        fatal_error(stmt.pos, "Invalid type in return expression. Expected %s, got %s", get_type_name(ret_type), get_type_name(operand.type));
      }
    } else if (ret_type != type_void) {
      fatal_error(stmt.pos, "Empty return expression for function with non-void return type");
    }
    return true;
  case Stmt.Break:
    if (!ctx.is_break_legal) {
      fatal_error(stmt.pos, "Illegal break");
    }
    return false;
  case Stmt.Continue:
    if (!ctx.is_continue_legal) {
      fatal_error(stmt.pos, "Illegal continue");
    }
    return false;
  case Stmt.Block:
    return resolve_stmt_block(stmt.block, ret_type, ctx);
  case Stmt.Note:
    if (stmt.note.name == assert_name) {
      if (stmt.note.num_args != 1) {
        fatal_error(stmt.pos, "#assert takes 1 argument");
      }
      resolve_cond_expr(stmt.note.args[0].expr);
    } else if (stmt.note.name == static_assert_name) {
      resolve_static_assert(stmt.note);
    } else {
      warning(stmt.pos, "Unknown statement #directive '%s'", stmt.note.name);
    }
    return false;
  case Stmt.If: {
    let scope = sym_enter();
    if (stmt.if_stmt.init) {
      resolve_stmt_init(stmt.if_stmt.init);
    }
    if (stmt.if_stmt.cond) {
      resolve_cond_expr(stmt.if_stmt.cond);
    } else if (!is_cond_operand(resolve_name_operand(stmt.pos, stmt.if_stmt.init.init.name))) {
      fatal_error(stmt.pos, "Conditional expression must have scalar type");
    }
    let returns: bool = resolve_stmt_block(stmt.if_stmt.then_block, ret_type, ctx);
    for (let i: usize = 0; i < stmt.if_stmt.num_elseifs; i++) {
      let elseif: ElseIf = stmt.if_stmt.elseifs[i];
      resolve_cond_expr(elseif.cond);
      returns = resolve_stmt_block(elseif.block, ret_type, ctx) && returns;
    }
    if (stmt.if_stmt.else_block.stmts) {
      returns = resolve_stmt_block(stmt.if_stmt.else_block, ret_type, ctx) && returns;
    } else {
      returns = false;
    }
    sym_leave(scope);
    return returns;
  }
  case Stmt.While:
  case Stmt.DoWhile:
    resolve_cond_expr(stmt.while_stmt.cond);
    ctx.is_break_legal = true;
    ctx.is_continue_legal = true;
    resolve_stmt_block(stmt.while_stmt.block, ret_type, ctx);
    return false;
  case Stmt.For: {
    let scope = sym_enter();
    if (stmt.for_stmt.init) {
      resolve_stmt(stmt.for_stmt.init, ret_type, ctx);
    }
    if (stmt.for_stmt.cond) {
      resolve_cond_expr(stmt.for_stmt.cond);
    }
    if (stmt.for_stmt.next) {
      resolve_stmt(stmt.for_stmt.next, ret_type, ctx);
    }
    ctx.is_break_legal = true;
    ctx.is_continue_legal = true;
    resolve_stmt_block(stmt.for_stmt.block, ret_type, ctx);
    sym_leave(scope);
    return false;
  }
  case Stmt.Switch: {
    let operand = resolve_expr_rvalue(stmt.switch_stmt.expr);
    let enum_decl = get_type_enum_decl(operand.type);
    // TODO Support switching directly on switch aggregates, which implies
    // TODO switching on their kind.
    if (!is_integer_type(operand.type)) {
      fatal_error(stmt.pos, "Switch expression must have integer type");
    }
    ctx.is_break_legal = true;
    let returns = true;
    let has_default = false;
    for (let i: usize = 0; i < stmt.switch_stmt.num_cases; i++) {
      let switch_case: SwitchCase = stmt.switch_stmt.cases[i];
      for (let j: usize = 0; j < switch_case.num_patterns; j++) {
        let pattern: SwitchCasePattern = switch_case.patterns[j];
        if (pattern.is_default) {
          if (has_default) {
            fatal_error(stmt.pos, "Switch statement has multiple default clauses");
          }
          has_default = true;
          continue;
        }
        let start_expr = pattern.start;
        let start_operand =
          resolve_enum_item_or_const_expr(enum_decl, start_expr);
        if (!convert_operand(&start_operand, operand.type)) {
          fatal_error(start_expr.pos, "Invalid type in switch case expression. Expected %s, got %s", get_type_name(operand.type), get_type_name(start_operand.type));
        }
        let end_expr = pattern.end;
        if (end_expr) {
          let end_operand =
            resolve_enum_item_or_const_expr(enum_decl, end_expr);
          if (!convert_operand(&end_operand, operand.type)) {
            fatal_error(end_expr.pos, "Invalid type in switch case expression. Expected %s, got %s", get_type_name(operand.type), get_type_name(end_operand.type));
          }
          convert_operand(&start_operand, type_llong);
          set_resolved_val(start_expr, start_operand.val);
          convert_operand(&end_operand, type_llong);
          set_resolved_val(end_expr, end_operand.val);
          if (end_operand.val.ll < start_operand.val.ll) {
            fatal_error(start_expr.pos, "Case range end value cannot be less thn start value");
          }
          if (end_operand.val.ll - start_operand.val.ll >= 256) {
            fatal_error(start_expr.pos, "Case range cannot span more than 256 values");
          }
        }
      }
      if (switch_case.is_default) {
        if (has_default) {
          fatal_error(stmt.pos, "Switch statement has multiple default clauses");
        }
        has_default = true;
      }
      if (switch_case.block.num_stmts > 1) {
        let last_stmt = switch_case.block.stmts[switch_case.block.num_stmts - 1];
        if (last_stmt.kind == Stmt.Break) {
          warning(last_stmt.pos, "Case blocks already end with an implicit break");
        }
      }
      returns = resolve_stmt_block(switch_case.block, ret_type, ctx) && returns;
    }
    return returns && has_default;
  }
  case Stmt.Assign:
    resolve_stmt_assign(stmt);
    return false;
  case Stmt.Init:
    resolve_stmt_init(stmt);
    return false;
  case Stmt.Expr:
    resolve_expr(stmt.expr);
    return false;
  case Stmt.Label:
    define_label(stmt.pos, stmt.label);
    return false;
  case Stmt.Goto:
    reference_label(stmt.pos, stmt.label);
    return false;
  default:
    #assert(0);
    return false;
  }
}

fn resolve_func_body(sym: &Sym) {
  let decl = sym.decl;
  #assert(decl.kind == Decl.Func);
  #assert(sym.state == SymState.Resolved);
  if (decl.is_incomplete) {
    return;
  }
  let old_package = enter_package(sym.home_package);
  let scope = sym_enter();
  for (let i: usize = 0; i < decl.function.num_params; i++) {
    let param = decl.function.params[i];
    let param_type = resolve_typespec(param.type);
    if (is_array_type(param_type)) {
      param_type = type_ptr(param_type.base);
    }
    sym_push_var(param.name, param_type);
  }
  let ret_type = resolve_typespec(decl.function.ret_type);
  #assert(!is_array_type(ret_type));
  let returns = resolve_stmt_block(decl.function.block, ret_type, StmtCtx {0});
  resolve_labels();
  sym_leave(scope);
  if (ret_type != type_void && !returns) {
    fatal_error(decl.pos, "Not all control paths return values");
  }
  leave_package(old_package);
}

fn resolve_sym(sym: &Sym) {
  if (sym.state == SymState.Resolved) {
    return;
  } else if (sym.state == SymState.Resolving) {
    fatal_error(sym.decl.pos, "Cyclic dependency");
    return;
  }
  #assert(sym.state == SymState.Unresolved);
  #assert(!sym.reachable);
  if (!is_local_sym(sym)) {
    buf_push((:*&void)&reachable_syms, &sym, sizeof(sym));
    sym.reachable = reachable_phase;
  }
  sym.state = SymState.Resolving;
  let decl = sym.decl;
  let old_package = enter_package(sym.home_package);
  @complete
  switch (sym.kind) {
  case Sym.Type:
    if (decl && decl.kind == Decl.Typedef) {
      sym.type = resolve_typespec(decl.typedef_decl.type);
    } else if (decl.kind == Decl.Enum) {
      // Here's where the base type is set for enums.
      let base = decl.enum_decl.type ? resolve_typespec(decl.enum_decl.type) : type_int;
      if (!is_integer_type(base)) {
        fatal_error(decl.pos, "Base type of enum must be integer type");
      }
      sym.type = type_enum(sym, base);
    } else {
      sym.type = type_incomplete(sym);
    }
  case Sym.Var:
    sym.type = resolve_decl_var(decl);
  case Sym.Const:
    sym.type = resolve_decl_const(decl, &sym.val);
  case Sym.Func:
    sym.type = resolve_decl_func(decl);
  case Sym.Package:
    // Do nothing
    break;
  }
  leave_package(old_package);
  sym.state = SymState.Resolved;
  if (decl.is_incomplete || (decl.kind != Decl.Struct && decl.kind != Decl.Union)) {
    buf_push((:*&void)&sorted_syms, &sym, sizeof(sym));
  }
}

fn finalize_sym(sym: &Sym) {
  #assert(sym.state == SymState.Resolved);
  if (sym.decl && !is_decl_foreign(sym.decl) && !sym.decl.is_incomplete) {
    if (sym.kind == Sym.Type) {
      complete_type(sym.type);
    } else if (sym.kind == Sym.Func) {
      resolve_func_body(sym);
    }
  }
}

fn resolve_name(name: *const char) -> &Sym {
  let sym = sym_get(name);
  if (!sym) {
    return NULL;
  }
  resolve_sym(sym);
  return sym;
}

fn try_resolve_package(expr: &Expr) -> &Package {
  if (expr.kind == Expr.Name) {
    let sym = resolve_name(expr.name);
    if (sym && sym.kind == Sym.Package) {
      return sym.package;
    }
  } else if (expr.kind == Expr.Field) {
    let package = try_resolve_package(expr.field.expr);
    if (package) {
      let sym = get_package_sym(package, expr.field.name);
      if (sym && sym.kind == Sym.Package) {
        return sym.package;
      }
    }
  }
  return NULL;
}

fn get_type_enum_decl(type: &Type) -> &DeclEnum {
  // TODO Does sym imply sym.decl?
  if (type.sym && type.sym.decl) {
    let decl = type.sym.decl;
    switch (type.kind) {
      CompilerTypeKind.Enum => break;
      CompilerTypeKind.Struct, CompilerTypeKind.Union => {
        if (decl.aggregate.union_enum_decl) {
          decl = decl.aggregate.union_enum_decl;
        } else {
          decl = NULL;
        }
      }
      else => decl = NULL;
    }
    if (decl) {
      return &decl.enum_decl;
    }
  }
  return NULL;
}

fn resolve_enum_item_or_const_expr(
  enum_decl: &DeclEnum, expr: &Expr,
) -> Operand {
  if (enum_decl && expr.kind == Expr.Name) {
    if (let item = resolve_enum_item(enum_decl, expr, expr.name); item.type) {
      return item;
    } else {
      fatal_error(expr.pos, "No enum item named '%s'", expr.name);
      return operand_null;
    }
  }
  return resolve_const_expr(expr);
}

fn resolve_enum_item(
  enum_decl: &DeclEnum, expr: &Expr, name: *const char,
) -> Operand {
  for (let i: usize = 0; i < enum_decl.num_items; ++i) {
    let item = enum_decl.items[i];
    if (item.name == name) {
      let sym = resolve_name(build_scoped_name(enum_decl.scope, item.name));
      if (sym) {
        #assert(sym.kind == Sym.Const);
        set_resolved_sym(expr, sym);
        let item_operand = operand_const(sym.type, sym.val);
        return item_operand;
      }
    }
  }
  return operand_null;
}

fn resolve_expr_field(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Field);
  let package = try_resolve_package(expr.field.expr);
  if (package) {
    let old_package = enter_package(package);
    let sym = resolve_name(expr.field.name);
    let operand = resolve_name_operand(expr.pos, expr.field.name);
    leave_package(old_package);
    set_resolved_sym(expr, sym);
    return operand;
  }
  let operand = resolve_expr(expr.field.expr);
  if (operand.is_type) {
    if (let enum_decl = get_type_enum_decl(operand.type)) {
      let item = resolve_enum_item(enum_decl, expr, expr.field.name);
      if (item.type) {
        return item;
      }
    }
    fatal_error(expr.pos, "No item named '%s'", expr.field.name);
    return operand_null;
  }
  let was_const_type = is_const_type(operand.type);
  let type = unqualify_type(operand.type);
  complete_type(type);
  if (is_ptr_type(type)) {
    operand = operand_lvalue(type.base);
    was_const_type = is_const_type(operand.type);
    type = unqualify_type(operand.type);
    complete_type(type);
  }
  if (type.kind != CompilerTypeKind.Struct && type.kind != CompilerTypeKind.Union) {
    fatal_error(expr.pos, "Can only access fields on aggregates or pointers to aggregates");
    return operand_null;
  }
  for (let i: usize = 0; i < type.aggregate.num_fields; i++) {
    let field = type.aggregate.fields[i];
    if (field.name == expr.field.name) {
      let field_operand = operand.is_lvalue ? operand_lvalue(field.type) : operand_rvalue(field.type);
      if (was_const_type) {
        field_operand.type = type_const(field_operand.type);
      }
      return field_operand;
    }
  }
  fatal_error(expr.pos, "No field named '%s'", expr.field.name);
  return operand_null;
}

fn eval_unary_op_ll(op: TokenKind, val: llong) -> llong {
  @complete
  switch (op) {
  case TokenKind.Add:
    return +val;
  case TokenKind.Sub:
    return -val;
  case TokenKind.Neg:
    return ~val;
  case TokenKind.Not:
    return !val;
  }
  return 0;
}

fn eval_unary_op_ull(op: TokenKind, val: ullong) -> ullong {
  @complete
  switch (op) {
  case TokenKind.Add:
    return +val;
  case TokenKind.Sub:
    return 0ull - val;
  case TokenKind.Neg:
    return ~val;
  case TokenKind.Not:
    return !val;
  }
  return 0;
}

fn eval_binary_op_ll(op: TokenKind, left: llong, right: llong) -> llong {
  @complete
  switch (op) {
  case TokenKind.Mul:
    return left * right;
  case TokenKind.Div:
    return right != 0 ? left / right : 0;
  case TokenKind.Mod:
    return right != 0 ? left % right : 0;
  case TokenKind.And:
    return left & right;
  case TokenKind.Lshift:
    return left << right;
  case TokenKind.Rshift:
    return left >> right;
  case TokenKind.Add:
    return left + right;
  case TokenKind.Sub:
    return left - right;
  case TokenKind.Or:
    return left | right;
  case TokenKind.Xor:
    return left ^ right;
  case TokenKind.Eq:
    return left == right;
  case TokenKind.NotEq:
    return left != right;
  case TokenKind.Lt:
    return left < right;
  case TokenKind.LtEq:
    return left <= right;
  case TokenKind.Gt:
    return left > right;
  case TokenKind.GtEq:
    return left >= right;
  }
  return 0;
}

fn eval_binary_op_ull(op: TokenKind, left: ullong, right: ullong) -> ullong {
  @complete
  switch (op) {
  case TokenKind.Mul:
    return left * right;
  case TokenKind.Div:
    return right != 0 ? left / right : 0;
  case TokenKind.Mod:
    return right != 0 ? left % right : 0;
  case TokenKind.And:
    return left & right;
  case TokenKind.Lshift:
    return left << right;
  case TokenKind.Rshift:
    return left >> right;
  case TokenKind.Add:
    return left + right;
  case TokenKind.Sub:
    return left - right;
  case TokenKind.Or:
    return left | right;
  case TokenKind.Xor:
    return left ^ right;
  case TokenKind.Eq:
    return left == right;
  case TokenKind.NotEq:
    return left != right;
  case TokenKind.Lt:
    return left < right;
  case TokenKind.LtEq:
    return left <= right;
  case TokenKind.Gt:
    return left > right;
  case TokenKind.GtEq:
    return left >= right;
  }
  return 0;
}

fn eval_unary_op(op: TokenKind, type: &Type, val: Val) -> Val {
  if (is_integer_type(type)) {
    let operand = operand_const(type, val);
    if (is_signed_type(type)) {
      cast_operand(&operand, type_llong);
      operand.val.ll = eval_unary_op_ll(op, operand.val.ll);
    } else {
      cast_operand(&operand, type_ullong);
      operand.val.ll = eval_unary_op_ull(op, operand.val.ull);
    }
    cast_operand(&operand, type);
    return operand.val;
  } else {
    return Val {0};
  }
}

fn eval_binary_op(op: TokenKind, type: &Type, left: Val, right: Val) -> Val {
  if (is_integer_type(type)) {
    let left_operand = operand_const(type, left);
    let right_operand = operand_const(type, right);
    let result_operand: Operand;
    if (is_signed_type(type)) {
      cast_operand(&left_operand, type_llong);
      cast_operand(&right_operand, type_llong);
      result_operand = operand_const(type_llong, Val {ll = eval_binary_op_ll(op, left_operand.val.ll, right_operand.val.ll)});
    } else {
      cast_operand(&left_operand, type_ullong);
      cast_operand(&right_operand, type_ullong);
      result_operand = operand_const(type_ullong, Val {ull = eval_binary_op_ull(op, left_operand.val.ull, right_operand.val.ull)});
    }
    cast_operand(&result_operand, type);
    return result_operand.val;
  } else {
    return Val {0};
  }
}

fn resolve_name_operand(pos: SrcPos, name: *const char) -> Operand {
  let sym = resolve_name(name);
  if (!sym) {
    fatal_error(pos, "Unresolved name '%s'", name);
  }
  if (sym.kind == Sym.Var) {
    let operand = operand_lvalue(sym.type);
    if (is_array_type(operand.type)) {
      operand = operand_decay(operand);
    }
    return operand;
  } else if (sym.kind == Sym.Const) {
    return operand_const(sym.type, sym.val);
  } else if (sym.kind == Sym.Func) {
    return operand_rvalue(sym.type);
  } else if (sym.kind == Sym.Type) {
    return operand_type(sym.type);
  } else {
    #assert(false);
    fatal_error(pos, "%s must be a let or const", name);
    return operand_null;
  }
}

fn resolve_expr_name(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Name);
  return resolve_name_operand(expr.pos, expr.name);
}

fn resolve_unary_op(op: TokenKind, operand: Operand) -> Operand {
  promote_operand(&operand);
  if (operand.is_const) {
    return operand_const(operand.type, eval_unary_op(op, operand.type, operand.val));
  } else {
    return operand;
  }
}

fn resolve_expr_unary(expr: &Expr) -> Operand {
  let operand = resolve_expr_rvalue(expr.unary.expr);
  let type = operand.type;
  @complete
  switch (expr.unary.op) {
  case TokenKind.Mul:
    if (!is_ptr_type(type)) {
      fatal_error(expr.pos, "Cannot deref non-ptr type");
    }
    return operand_lvalue(type.base);
  case TokenKind.Add:
  case TokenKind.Sub:
    if (!is_arithmetic_type(type)) {
      fatal_error(expr.pos, "Can only use unary %s with arithmetic types", token_kind_name(expr.unary.op));
    }
    return resolve_unary_op(expr.unary.op, operand);
  case TokenKind.Neg:
    if (!is_integer_type(type)) {
      fatal_error(expr.pos, "Can only use ~ with integer types");
    }
    return resolve_unary_op(expr.unary.op, operand);
  case TokenKind.Not:
    if (!is_scalar_type(type)) {
      fatal_error(expr.pos," Can only use ! with scalar types");
    }
    return resolve_unary_op(expr.unary.op, operand);
  }
  return Operand {0};
}

fn resolve_binary_op(op: TokenKind, left: Operand, right: Operand) -> Operand {
  if (left.is_const && right.is_const) {
    return operand_const(left.type, eval_binary_op(op, left.type, left.val, right.val));
  } else {
    return operand_rvalue(left.type);
  }
}

fn resolve_binary_arithmetic_op(op: TokenKind, left: Operand, right: Operand) -> Operand {
  unify_arithmetic_operands(&left, &right);
  return resolve_binary_op(op, left, right);
}

fn resolve_expr_binary_op(op: TokenKind, op_name: *const char, pos: SrcPos, left: Operand, right: Operand) -> Operand {
  @complete
  switch (op) {
  case TokenKind.Mul:
  case TokenKind.Div:
    if (!is_arithmetic_type(left.type)) {
      fatal_error(pos, "Left operand of %s must have arithmetic type", op_name);
    }
    if (!is_arithmetic_type(right.type)) {
      fatal_error(pos, "Right operand of %s must have arithmetic type", op_name);
    }
    return resolve_binary_arithmetic_op(op, left, right);
  case TokenKind.Mod:
    if (!is_integer_type(left.type)) {
      fatal_error(pos, "Left operand of %% must have integer type");
    }
    if (!is_integer_type(right.type)) {
      fatal_error(pos, "Right operand of %% must have integer type");
    }
    return resolve_binary_arithmetic_op(op, left, right);
  case TokenKind.Add:
    if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
      return resolve_binary_arithmetic_op(op, left, right);
    } else if (is_ptr_star_type(left.type) && is_integer_type(right.type)) {
      complete_type(left.type.base);
      if (type_sizeof(left.type.base) == 0) {
        fatal_error(pos, "Cannot do pointer arithmetic with size 0 base type");
      }
      return operand_rvalue(left.type);
    } else if (is_ptr_star_type(right.type) && is_integer_type(left.type)) {
      complete_type(right.type.base);
      if (type_sizeof(right.type.base) == 0) {
        fatal_error(pos, "Cannot do pointer arithmetic with size 0 base type");
      }
      return operand_rvalue(right.type);
    } else {
      fatal_error(pos, "Operands of + must both have arithmetic type, or star pointer and integer type");
    }
  case TokenKind.Sub:
    if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
      return resolve_binary_arithmetic_op(op, left, right);
    } else if (is_ptr_star_type(left.type) && is_integer_type(right.type)) {
      return operand_rvalue(left.type);
    } else if (is_ptr_star_type(left.type) && is_ptr_star_type(right.type)) {
      if (left.type.base != right.type.base) {
        fatal_error(pos, "Cannot subtract pointers to different types");
      }
      return operand_rvalue(type_ssize);
    } else {
      fatal_error(pos, "Operands of - must both have arithmetic type, pointer and integer type, or compatible pointer types");
    }
  case TokenKind.Lshift:
  case TokenKind.Rshift:
    if (is_integer_type(left.type) && is_integer_type(right.type)) {
      promote_operand(&left);
      promote_operand(&right);
      let result_type = left.type;
      let result: Operand;
      if (is_signed_type(left.type)) {
        cast_operand(&left, type_llong);
        cast_operand(&right, type_llong);
      } else {
        cast_operand(&left, type_ullong);
        cast_operand(&right, type_ullong);
      }
      result = resolve_binary_op(op, left, right);
      cast_operand(&result, result_type);
      return result;
    } else {
      fatal_error(pos, "Operands of %s must both have integer type", op_name);
    }
  case TokenKind.Eq:
  case TokenKind.NotEq:
    if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
      let result = resolve_binary_arithmetic_op(op, left, right);
      cast_operand(&result, type_int);
      return result;
    } else if (is_ptr_type(left.type) && is_ptr_type(right.type)) {
      let unqual_left_base = unqualify_type(left.type.base);
      let unqual_right_base = unqualify_type(right.type.base);
      if (unqual_left_base != unqual_right_base && unqual_left_base != type_void && unqual_right_base != type_void) {
        fatal_error(pos, "Cannot compare pointers to different types");
      }
      return operand_rvalue(type_int);
    } else if ((is_null_ptr(left) && is_ptr_type(right.type)) || (is_null_ptr(right) && is_ptr_type(left.type))) {
      return operand_rvalue(type_int);
    } else {
      fatal_error(pos, "Operands of %s must be arithmetic types or compatible pointer types", op_name);
    }
  case TokenKind.Lt:
  case TokenKind.LtEq:
  case TokenKind.Gt:
  case TokenKind.GtEq:
    if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
      let result = resolve_binary_arithmetic_op(op, left, right);
      cast_operand(&result, type_int);
      return result;
    } else if (is_ptr_type(left.type) && is_ptr_type(right.type)) {
      if (unqualify_type(left.type.base) != unqualify_type(right.type.base)) {
        fatal_error(pos, "Cannot compare pointers to different types");
      }
      return operand_rvalue(type_int);
    } else if ((is_null_ptr(left) && is_ptr_type(right.type)) || (is_null_ptr(right) && is_ptr_type(left.type))) {
      return operand_rvalue(type_int);
    } else {
      fatal_error(pos, "Operands of %s must be arithmetic types or compatible pointer types", op_name);
    }
  case TokenKind.And:
  case TokenKind.Xor:
  case TokenKind.Or:
    if (is_integer_type(left.type) && is_integer_type(right.type)) {
      return resolve_binary_arithmetic_op(op, left, right);
    } else {
      fatal_error(pos, "Operands of %s must have arithmetic types", op_name);
    }
  case TokenKind.AndAnd:
  case TokenKind.OrOr:
    if (is_scalar_type(left.type) && is_scalar_type(right.type)) {
      if (left.is_const && right.is_const) {
        cast_operand(&left, type_bool);
        cast_operand(&right, type_bool);
        let i: int;
        if (op == TokenKind.AndAnd) {
          i = left.val.b && right.val.b;
        } else {
          #assert(op == TokenKind.OrOr);
          i = left.val.b || right.val.b;
        }
        return operand_const(type_int, Val {i = i});
      } else {
        return operand_rvalue(type_int);
      }
    } else {
      fatal_error(pos, "Operands of %s must have scalar types", op_name);
    }
  }
  return Operand {0};
}

fn resolve_expr_binary(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Binary);
  let left = resolve_expr_rvalue(expr.binary.left);
  let right = resolve_expr_rvalue(expr.binary.right);
  let op: TokenKind = expr.binary.op;
  let op_name = token_kind_name(op);
  return resolve_expr_binary_op(op, op_name, expr.pos, left, right);
}

fn resolve_expr_compound(expr: &Expr, expected_type: &Type) -> Operand {
  #assert(expr.kind == Expr.Compound);
  if (!expected_type && !expr.compound.type) {
    fatal_error(expr.pos, "Implicitly typed compound literals used in context without expected type");
  }
  let type: &Type = NULL;
  if (expr.compound.type) {
    type = resolve_typespec(expr.compound.type);
  } else {
    type = expected_type;
  }
  complete_type(type);
  let is_const = is_const_type(type);
  type = unqualify_type(type);
  if (type.kind == CompilerTypeKind.Struct || type.kind == CompilerTypeKind.Union) {
    let index = 0;
    for (let i: usize = 0; i < expr.compound.num_fields; i++) {
      let field: CompoundField = expr.compound.fields[i];
      if (field.kind == CompoundField.Index) {
        fatal_error(field.pos, "Index field initializer not allowed for struct/union compound literal");
      } else if (field.kind == CompoundField.Name) {
        index = aggregate_item_field_index(type, field.name);
        if (index == -1) {
          fatal_error(field.pos, "Named field in compound literal does not exist");
        }
      }
      if (index >= (:int)type.aggregate.num_fields) {
        fatal_error(field.pos, "Field initializer in struct/union compound literal out of range");
      }
      let field_type = type.aggregate.fields[index].type;
      if (!resolve_typed_init(field.pos, field_type, field.init)) {
        fatal_error(field.pos, "Invalid type in compound literal initializer for aggregate type. Expected %s", get_type_name(field_type));
      }
      index++;
    }
  } else if (type.kind == CompilerTypeKind.Array) {
    // These were int, but can't be negative below.
    let index: usize = 0;
    let max_index: usize = 0;
    for (let i: usize = 0; i < expr.compound.num_fields; i++) {
      let field = expr.compound.fields[i];
      if (field.kind == CompoundField.Name) {
        fatal_error(field.pos, "Named field initializer not allowed for array compound literals");
      } else if (field.kind == CompoundField.Index) {
        let operand = resolve_const_expr(field.index);
        if (!is_integer_type(operand.type)) {
          fatal_error(field.pos, "Field initializer index expression must have type int");
        }
        if (!cast_operand(&operand, type_int)) {
          fatal_error(field.pos, "Invalid type in field initializer index. Expected integer type");
        }
        if (operand.val.i < 0) {
          fatal_error(field.pos, "Field initializer index cannot be negative");
        }
        index = operand.val.i;
      }
      if (type.num_elems && index >= (:int)type.num_elems) {
        fatal_error(field.pos, "Field initializer in array compound literal out of range");
      }
      if (!resolve_typed_init(field.pos, type.base, field.init)) {
        fatal_error(field.pos, "Invalid type in compound literal initializer for array type. Expected %s", get_type_name(type.base));
      }
      max_index = max(max_index, index);
      index++;
    }
    if (type.num_elems == 0) {
      type = type_array(type.base, max_index + 1);
    }
  } else {
    #assert(is_scalar_type(type));
    if (expr.compound.num_fields > 1) {
      fatal_error(expr.pos, "Compound literal for scalar type cannot have more than one operand");
    }
    if (expr.compound.num_fields == 1) {
      let field = expr.compound.fields[0];
      let init = resolve_expected_expr_rvalue(field.init, type);
      if (!convert_operand(&init, type)) {
        fatal_error(field.pos, "Invalid type in compound literal initializer. Expected %s, got %s", get_type_name(type), get_type_name(init.type));
      }
    }
  }
  return operand_lvalue(is_const ? type_const(type) : type);
}

fn resolve_expr_call(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Call);
  if (expr.call.expr.kind == Expr.Name) {
    let sym = resolve_name(expr.call.expr.name);
    if (sym && sym.kind == Sym.Type) {
      if (expr.call.num_args != 1) {
        fatal_error(expr.pos, "Type conversion operator takes 1 argument");
      }
      let operand = resolve_expr_rvalue(expr.call.args[0]);
      if (!cast_operand(&operand, sym.type)) {
        fatal_error(expr.pos, "Invalid type cast from %s to %s", get_type_name(operand.type), get_type_name(sym.type));
      }
      set_resolved_sym(expr.call.expr, sym);
      return operand;
    }
  }
  let function = resolve_expr_rvalue(expr.call.expr);
  if (function.type.kind != CompilerTypeKind.Func) {
    fatal_error(expr.pos, "Cannot call non-function value");
  }
  let num_params: usize = function.type.function.num_params;
  if (expr.call.num_args < num_params) {
    fatal_error(expr.pos, "Function call with too few arguments");
  }
  if (expr.call.num_args > num_params && !function.type.function.has_varargs) {
    fatal_error(expr.pos, "Function call with too many arguments");
  }
  for (let i: usize = 0; i < num_params; i++) {
    let param_type = function.type.function.params[i];
    let arg = resolve_expected_expr_rvalue(expr.call.args[i], param_type);
    if (is_array_type(param_type)) {
      param_type = type_ptr(param_type.base);
    }
    if (!convert_operand(&arg, param_type)) {
      fatal_error(expr.call.args[i].pos, "Invalid type in function call argument. Expected %s, got %s", get_type_name(param_type), get_type_name(arg.type));
    }
  }
  for (let i: usize = num_params; i < expr.call.num_args; i++) {
    resolve_expr_rvalue(expr.call.args[i]);
  }
  return operand_rvalue(function.type.function.ret);
}

fn resolve_expr_ternary(expr: &Expr, expected_type: &Type) -> Operand {
  #assert(expr.kind == Expr.Ternary);
  let cond = resolve_expr_rvalue(expr.ternary.cond);
  if (!is_scalar_type(cond.type)) {
    fatal_error(expr.pos, "Ternary conditional must have scalar type");
  }
  let left = resolve_expected_expr_rvalue(expr.ternary.then_expr, expected_type);
  let right = resolve_expected_expr_rvalue(expr.ternary.else_expr, expected_type);
  if (left.type == right.type) {
    return operand_rvalue(left.type);
  } else if (is_arithmetic_type(left.type) && is_arithmetic_type(right.type)) {
    unify_arithmetic_operands(&left, &right);
    if (cond.is_const && left.is_const && right.is_const) {
      return operand_const(left.type, cond.val.i ? left.val : right.val);
    } else {
      return operand_rvalue(left.type);
    }
  } else if (is_ptr_type(left.type) && is_null_ptr(right)) {
    return operand_rvalue(left.type);
  } else if (is_ptr_type(right.type) && is_null_ptr(left)) {
    return operand_rvalue(right.type);
  } else {
    fatal_error(expr.pos, "Left and right operands of ternary expression must have arithmetic types or identical types");
  }
  // This is actually unreachable, but we need to make the compiler happy.
  // TODO: How to assert convince compiler that fatal_error doesn't return?
  return Operand {};
}

fn resolve_expr_index(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Index);
  let operand = resolve_expr_rvalue(expr.index.expr);
  if (!is_ptr_star_type(operand.type)) {
    fatal_error(expr.pos, "Can only index arrays and star pointers");
  }
  let index = resolve_expr_rvalue(expr.index.index);
  if (!is_integer_type(index.type)) {
    fatal_error(expr.pos, "Index must have integer type");
  }
  return operand_lvalue(operand.type.base);
}

fn resolve_expr_cast(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Cast);
  let type = resolve_typespec(expr.cast.type);
  let operand = resolve_expr_rvalue(expr.cast.expr);
  if (!cast_operand(&operand, type)) {
    fatal_error(expr.pos, "Invalid type cast from %s to %s", get_type_name(operand.type), get_type_name(type));
  }
  return operand;
}

fn resolve_expr_int(expr: &Expr) -> Operand {
  #assert(expr.kind == Expr.Int);
  let int_max: ullong = type_metrics[CompilerTypeKind.Int].max;
  let uint_max: ullong = type_metrics[CompilerTypeKind.UInt].max;
  let long_max: ullong = type_metrics[CompilerTypeKind.Long].max;
  let ulong_max: ullong = type_metrics[CompilerTypeKind.ULong].max;
  let llong_max: ullong = type_metrics[CompilerTypeKind.LLong].max;
  let val: ullong = expr.int_lit.val;
  let operand = operand_const(type_ullong, Val {ull = val});
  let type = type_ullong;
  if (expr.int_lit.mod == TokenMod.None) {
    let overflow = false;
    @complete
    switch (expr.int_lit.suffix) {
    case TokenSuffix.None:
      type = type_int;
      if (val > int_max) {
        type = type_long;
        if (val > long_max) {
          type = type_llong;
          overflow = val > llong_max;
        }
      }
    case TokenSuffix.U:
      type = type_uint;
      if (val > uint_max) {
        type = type_ulong;
        if (val > ulong_max) {
          type = type_ullong;
        }
      }
    case TokenSuffix.L:
      type = type_long;
      if (val > long_max) {
        type = type_llong;
        overflow = val > llong_max;
      }
    case TokenSuffix.UL:
      type = type_ulong;
      if (val > ulong_max) {
        type = type_ullong;
      }
    case TokenSuffix.LL:
      type = type_llong;
      overflow = val > llong_max;
    case TokenSuffix.ULL:
      type = type_ullong;
    }
    if (overflow) {
      fatal_error(expr.pos, "Integer literal overflow");
    }
  } else {
    @complete
    switch (expr.int_lit.suffix) {
    case TokenSuffix.None:
      type = type_int;
      if (val > int_max) {
        type = type_uint;
        if (val > uint_max) {
          type = type_long;
          if (val > long_max) {
            type = type_ulong;
            if (val > ulong_max) {
              type = type_llong;
              if (val > llong_max) {
                type = type_ullong;
              }
            }
          }
        }
      }
    case TokenSuffix.U:
      type = type_uint;
      if (val > uint_max) {
        type = type_ulong;
        if (val > ulong_max) {
          type = type_ullong;
        }
      }
    case TokenSuffix.L:
      type = type_long;
      if (val > long_max) {
        type = type_ulong;
        if (val > ulong_max) {
          type = type_llong;
          if (val > llong_max) {
            type = type_ullong;
          }
        }
      }
    case TokenSuffix.UL:
      type = type_ulong;
      if (val > ulong_max) {
        type = type_ullong;
      }
    case TokenSuffix.LL:
      type = type_llong;
      if (val > llong_max) {
        type = type_ullong;
      }
    case TokenSuffix.ULL:
      type = type_ullong;
    }
  }
  cast_operand(&operand, type);
  return operand;
}

fn resolve_expr_modify(expr: &Expr) -> Operand {
  let operand = resolve_expr(expr.modify.expr);
  let type = operand.type;
  complete_type(type);
  if (!operand.is_lvalue) {
    fatal_error(expr.pos, "Cannot modify non-lvalue");
  }
  if (type.nonmodifiable) {
    fatal_error(expr.pos, "Cannot modify non-modifiable type");
  }
  if (!(is_integer_type(type) || type.kind == CompilerTypeKind.Ptr)) {
    fatal_error(expr.pos, "%s only valid for integer and pointer types", token_kind_name(expr.modify.op));
  }
  return operand_rvalue(type);
}

fn resolve_expected_expr(expr: &Expr, expected_type: &Type) -> Operand {
  let result: Operand;
  switch (expr.kind) {
  case Expr.Paren:
    result = resolve_expected_expr(expr.paren.expr, expected_type);
  case Expr.Int:
    result = resolve_expr_int(expr);
  case Expr.Float:
    result = operand_const(expr.float_lit.suffix == TokenSuffix.D ? type_double : type_float, Val {0});
  case Expr.Str:
    result = operand_rvalue(type_array(type_char, strlen(expr.str_lit.val) + 1));
  case Expr.Name:
    result = resolve_expr_name(expr);
    set_resolved_sym(expr, resolve_name(expr.name));
  case Expr.Cast:
    result = resolve_expr_cast(expr);
  case Expr.Call:
    result = resolve_expr_call(expr);
  case Expr.Index:
    result = resolve_expr_index(expr);
  case Expr.Field:
    result = resolve_expr_field(expr);
  case Expr.Compound:
    result = resolve_expr_compound(expr, expected_type);
  case Expr.Unary:
    if (expr.unary.op == TokenKind.And) {
      let operand: Operand;
      if (expected_type && is_ptr_type(expected_type)) {
        operand = resolve_expected_expr(expr.unary.expr, expected_type.base);
      } else {
        operand = resolve_expr(expr.unary.expr);
      }
      if (!operand.is_lvalue) {
        fatal_error(expr.pos, "Cannot take address of non-lvalue");
      }
      result = operand_rvalue(type_ref(operand.type));
    } else {
      result = resolve_expr_unary(expr);
    }
  case Expr.Binary:
    result = resolve_expr_binary(expr);
  case Expr.Ternary:
    result = resolve_expr_ternary(expr, expected_type);
  case Expr.SizeofExpr: {
    if (expr.sizeof_expr.kind == Expr.Name) {
      let sym = resolve_name(expr.sizeof_expr.name);
      if (sym && sym.kind == Sym.Type) {
        complete_type(sym.type);
        result = operand_const(type_usize, Val {ull = type_sizeof(sym.type)});
        set_resolved_type(expr.sizeof_expr, sym.type);
        set_resolved_sym(expr.sizeof_expr, sym);
        break;
      }
    }
    let type = resolve_expr(expr.sizeof_expr).type;
    complete_type(type);
    result = operand_const(type_usize, Val {ull = type_sizeof(type)});
  }
  case Expr.SizeofType: {
    let type = resolve_typespec(expr.sizeof_type);
    complete_type(type);
    result = operand_const(type_usize, Val {ull = type_sizeof(type)});
  }
  case Expr.AlignofExpr: {
    if (expr.sizeof_expr.kind == Expr.Name) {
      let sym = resolve_name(expr.alignof_expr.name);
      if (sym && sym.kind == Sym.Type) {
        complete_type(sym.type);
        result = operand_const(type_usize, Val {ull = type_alignof(sym.type)});
        set_resolved_type(expr.alignof_expr, sym.type);
        set_resolved_sym(expr.alignof_expr, sym);
        break;
      }
    }
    let type = resolve_expr(expr.alignof_expr).type;
    complete_type(type);
    result = operand_const(type_usize, Val {ull = type_alignof(type)});
  }
  case Expr.AlignofType: {
    let type = resolve_typespec(expr.alignof_type);
    complete_type(type);
    result = operand_const(type_usize, Val {ull = type_alignof(type)});
  }
  case Expr.TypeofType: {
    let type = resolve_typespec(expr.typeof_type);
    result = operand_const(type_ullong, Val {ull = type.typeid});
  }
  case Expr.TypeofExpr: {
    if (expr.typeof_expr.kind == Expr.Name) {
      let sym = resolve_name(expr.typeof_expr.name);
      if (sym && sym.kind == Sym.Type) {
        result = operand_const(type_ullong, Val {ull = sym.type.typeid});
        set_resolved_type(expr.typeof_expr, sym.type);
        set_resolved_sym(expr.typeof_expr, sym);
        break;
      }
    }
    let type = resolve_expr(expr.typeof_expr).type;
    result = operand_const(type_ullong, Val {ull = type.typeid});
  }
  case Expr.Offsetof: {
    let type = resolve_typespec(expr.offsetof_field.type);
    complete_type(type);
    if (type.kind != CompilerTypeKind.Struct && type.kind != CompilerTypeKind.Union) {
      fatal_error(expr.pos, "offsetof can only be used with struct/union types");
    }
    let field = aggregate_item_field_index(type, expr.offsetof_field.name);
    if (field < 0) {
      fatal_error(expr.pos, "No field '%s' in type", expr.offsetof_field.name);
    }
    result = operand_const(type_usize, Val {ull = type.aggregate.fields[field].offset});
  }
  case Expr.Modify:
    result = resolve_expr_modify(expr);
  default:
    #assert(0);
    result = operand_null;
  }
  set_resolved_type(expr, result.type);
  return result;
}

fn resolve_const_expr(expr: &Expr) -> Operand {
  let operand = resolve_expr(expr);
  if (!operand.is_const) {
    fatal_error(expr.pos, "Expected constant expression");
  }
  return operand;
}

let decl_note_names: Map;

fn init_builtin_syms() {
  #assert(current_package);
  sym_global_type("void", type_void);
  sym_global_type("bool", type_bool);
  sym_global_type("char", type_char);
  sym_global_type("schar", type_schar);
  sym_global_type("uchar", type_uchar);
  sym_global_type("short", type_short);
  sym_global_type("ushort", type_ushort);
  sym_global_type("int", type_int);
  sym_global_type("uint", type_uint);
  sym_global_type("long", type_long);
  sym_global_type("ulong", type_ulong);
  sym_global_type("llong", type_llong);
  sym_global_type("ullong", type_ullong);
  sym_global_type("float", type_float);
  sym_global_type("double", type_double);
}

fn add_package_decls(package: &Package) {
  for (let i: usize = 0; i < package.num_decls; i++) {
    let decl = package.decls[i];
    if (decl.kind == Decl.Note) {
      if (!map_get(&decl_note_names, decl.note.name)) {
        warning(decl.pos, "Unknown declaration #directive '%s'", decl.note.name);
      }
      if (decl.note.name == declare_note_name) {
        if (decl.note.num_args != 1) {
          fatal_error(decl.pos, "#declare_note takes 1 argument");
        }
        let arg = decl.note.args[0].expr;
        if (arg.kind != Expr.Name) {
          fatal_error(decl.pos, "#declare_note argument must be name");
        }
        map_put(&decl_note_names, arg.name, (:&void)1);
      } else if (decl.note.name == static_assert_name) {
        // TODO: decide how to handle top-level static #asserts wrt laziness/tree shaking
        if (!flag_lazy) {
          resolve_static_assert(decl.note);
        }
      }
    } else if (decl.kind == Decl.Import) {
      // Add to list of imports
    } else {
      sym_global_decl(decl, NULL);
    }
  }
}

fn is_package_dir(search_path: *const char, package_path: *const char) -> bool {
  let path: [MAX_PATH]char;
  path_copy(path, search_path);
  path_join(path, package_path);
  let iter: DirListIter;
  for (dir_list(&iter, path); iter.valid; dir_list_next(&iter)) {
    let ext: *const char = path_ext(iter.name);
    if (ext != iter.name && !strcmp(ext, "rio")) {
      dir_list_free(&iter);
      return true;
    }
  }
  return false;
}

fn copy_package_full_path(dest: [MAX_PATH]char, package_path: *const char) -> bool {
  for (let i = 0; i < num_package_search_paths; i++) {
    if (is_package_dir(package_search_paths[i], package_path)) {
      path_copy(dest, package_search_paths[i]);
      path_join(dest, package_path);
      return true;
    }
  }
  return false;
}

fn import_package(package_path: *const char) -> &Package {
  package_path = str_intern(package_path);
  let package: &Package = map_get(&package_map, package_path);
  if (!package) {
    package = xcalloc(1, sizeof(Package));
    package.path = package_path;
    if (flag_verbose) {
      printf("Importing %s\n", package_path);
    }
    let full_path: [MAX_PATH]char;
    if (!copy_package_full_path(full_path, package_path)) {
      return NULL;
    }
    strcpy(package.full_path, full_path);
    add_package(package);
    compile_package(package);
  }
  return package;
}

fn import_all_package_symbols(package: &Package) {
  // TODO: should have a more general mechanism
  let main_name: *const char = str_intern("main");
  for (let i: usize = 0; i < buf_len(package.syms); i++) {
    if (package.syms[i].home_package == package && package.syms[i].name != main_name) {
      sym_global_put(package.syms[i].name, package.syms[i]);
    }
  }
}

fn import_package_symbols(decl: &Decl, package: &Package) {
  for (let i: usize = 0; i < decl.import_decl.num_items; i++) {
    let item = decl.import_decl.items[i];
    let sym = get_package_sym(package, item.name);
    if (!sym) {
      fatal_error(decl.pos, "Symbol '%s' does not exist in package '%s'", item.name, package.path);
    }
    sym_global_put(item.rename ? item.rename : item.name, sym);
  }
}

fn process_package_imports(package: &Package) {
  for (let i: usize = 0; i < package.num_decls; i++) {
    let decl = package.decls[i];
    if (decl.kind == Decl.Note) {
      if (decl.note.name == always_name) {
        package.always_reachable = true;
      }
    } else if (decl.kind == Decl.Import) {
      let path_buf: *char = NULL;
      if (decl.import_decl.is_relative) {
        buf_printf(&path_buf, "%s/", package.path);
      }
      for (let k: usize = 0; k < decl.import_decl.num_names; k++) {
        if (!str_islower(decl.import_decl.names[k])) {
          fatal_error(decl.pos, "Import name must be lower case: '%s'", decl.import_decl.names[k]);
        }
        buf_printf(&path_buf, "%s%s", k == 0 ? "" : "/", decl.import_decl.names[k]);
      }
      let imported_package = import_package(path_buf);
      if (!imported_package) {
        fatal_error(decl.pos, "Failed to import package '%s'", path_buf);
      }
      buf_free((:*&void)&path_buf);
      import_package_symbols(decl, imported_package);
      if (decl.import_decl.import_all) {
        import_all_package_symbols(imported_package);
      }
      let sym_name = decl.name ? decl.name : decl.import_decl.names[decl.import_decl.num_names - 1];
      let sym = sym_new(Sym.Package, sym_name, decl);
      sym.package = imported_package;
      sym_global_put(sym_name, sym);
    }
  }
}

fn parse_package(package: &Package) -> bool {
  let decls: *&Decl = NULL;
  let iter: DirListIter;
  for (dir_list(&iter, package.full_path); iter.valid; dir_list_next(&iter)) {
    if (iter.is_dir || iter.name[0] == '_' || iter.name[0] == '.') {
      continue;
    }
    let name: [MAX_PATH]char;
    path_copy(name, iter.name);
    let ext: *char = path_ext(name);
    if (ext == name || strcmp(ext, "rio")) {
      continue;
    }
    ext[-1] = 0;
    if (is_excluded_target_filename(name)) {
      continue;
    }
    let path: [MAX_PATH]char;
    path_copy(path, iter.base);
    path_join(path, iter.name);
    path_absolute(path);
    let code: *const char = read_file(path);
    if (!code) {
      fatal_error(SrcPos {name = path}, "Failed to read source file");
    }
    init_stream(str_intern(path), code);
    let file_decls: *Decls = parse_decls();
    for (let i: usize = 0; i < file_decls.num_decls; i++) {
      buf_push((:*&void)&decls, &file_decls.decls[i], sizeof(file_decls.decls[i]));
    }
  }
  package.decls = decls;
  package.num_decls = (:int)buf_len(decls);
  return package != NULL;
}

fn compile_package(package: &Package) -> bool {
  if (!parse_package(package)) {
    return false;
  }
  let old_package = enter_package(package);
  if (buf_len(package_list) == 1) {
    init_builtin_syms();
  }
  if (builtin_package) {
    import_all_package_symbols(builtin_package);
  }
  add_package_decls(package);
  process_package_imports(package);
  leave_package(old_package);
  return true;
}

fn resolve_package_syms(package: &Package) {
  let old_package = enter_package(package);
  for (let i: usize = 0; i < buf_len(package.syms); i++) {
    if (package.syms[i].home_package == package) {
      resolve_sym(package.syms[i]);
    }
  }
  leave_package(old_package);
}

fn finalize_reachable_syms() {
  if (flag_verbose) {
    printf("Finalizing reachable symbols\n");
  }
  let prev_num_reachable: usize = 0;
  let num_reachable = buf_len(reachable_syms);
  for (let i: usize = 0; i < num_reachable; i++) {
    finalize_sym(reachable_syms[i]);
    if (i == num_reachable - 1) {
      if (flag_verbose) {
        printf("New reachable symbols:");
        for (let k: usize = prev_num_reachable; k < num_reachable; k++) {
          printf(" %s/%s", reachable_syms[k].home_package.path, reachable_syms[k].name);
        }
        printf("\n");
      }
      prev_num_reachable = num_reachable;
      num_reachable = buf_len(reachable_syms);
    }
  }
}
