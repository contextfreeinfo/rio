// Kept separate from ast.rio for easier diffing with original source split.

struct NoteArg {
  pos: SrcPos;
  name: *const char;
  expr: &Expr;
}

struct Note {
  pos: SrcPos;
  name: *const char;
  args: *NoteArg;
  num_args: usize;
}

struct Notes {
  notes: *Note;
  num_notes: usize;
}

struct StmtList {
  pos: SrcPos;
  stmts: *&Stmt;
  num_stmts: usize;
}

struct Typespec {
  pos: SrcPos;
  base: &Typespec;
  is_owned: bool;
  union switch {
    None | Const | Ptr | Ref => :void;
    Name => name: *const char;
    Func => function: TypespecFunc;
    Array => num_elems: *Expr;
  }
}

struct TypespecFunc {
  args: *&Typespec;
  num_args: usize;
  has_varargs: bool;
  ret: &Typespec;
}

struct FuncParam {
  pos: SrcPos;
  name: *const char;
  type: &Typespec;
}

struct AggregateItem {
  pos: SrcPos;
  // Kind names apply only to unions ...
  struct {
    kind_names: **const char;
    num_kind_names: usize;
  }
  union switch {
    None => :void;
    Field => struct {
      names: **const char;
      num_names: usize;
      type: &Typespec;
    }
    Subaggregate => subaggregate: &Aggregate;
  }
}

struct EnumItem {
  pos: SrcPos;
  name: *const char;
  init: &Expr;
}

struct ImportItem {
  name: *const char;
  rename: *const char;
}

enum AggregateKind {
  None,
  Struct,
  Union,
}

struct Aggregate {
  pos: SrcPos;
  kind: AggregateKind;
  items: *AggregateItem;
  num_items: usize;
  union_enum_decl: &Decl;
}

struct Decl {
  pos: SrcPos;
  name: *const char;
  notes: Notes;
  is_incomplete: bool;
  union switch {
    None => :void;
    Note => note: Note;
    Enum => enum_decl: DeclEnum;
    Struct | Union => aggregate: &Aggregate;
    Func => function: DeclFunc;
    Typedef => typedef_decl: DeclTypedef;
    // This is an example of wanting different names for the same thing ...
    Var => var_decl: DeclVar;
    Const => const_decl: DeclVar;
    Import => import_decl: DeclImport;
  }
}

struct DeclEnum {
  type: &Typespec;
  items: *EnumItem;
  num_items: usize;
  scope: *const char;
}

struct DeclFunc {
  params: *FuncParam;
  num_params: usize;
  ret_type: &Typespec;
  has_varargs: bool;
  block: StmtList;
}

struct DeclTypedef {
  type: &Typespec;
}

struct DeclVar {
  type: &Typespec;
  expr: &Expr;
}

struct DeclImport {
  is_relative: bool;
  names: **const char;
  num_names: usize;
  import_all: bool;
  items: *ImportItem;
  num_items: usize;
}

struct Decls {
  decls: *&Decl;
  num_decls: usize;
}

struct CompoundField {
  pos: SrcPos;
  init: &Expr;
  union switch {
    Default => :void;
    Name => name: *const char;
    Index => index: &Expr;
  }
}

struct Expr {
  pos: SrcPos;
  union switch {
    None => :void;
    Paren => paren: ExprParen;
    Int => int_lit: ExprIntLit;
    Float => float_lit: ExprFloatLit;
    Str => str_lit: ExprStrLit;
    Name => name: *const char;
    SizeofExpr => sizeof_expr: &Expr;
    SizeofType => sizeof_type: &Typespec;
    TypeofExpr => typeof_expr: &Expr;
    TypeofType => typeof_type: &Typespec;
    AlignofExpr => alignof_expr: &Expr;
    AlignofType => alignof_type: &Typespec;
    Offsetof => offsetof_field: ExprOffsetofField;
    Compound => compound: ExprCompound;
    Cast => cast: ExprCast;
    Modify => modify: ExprModify;
    Unary => unary: ExprUnary;
    Binary => binary: ExprBinary;
    Ternary => ternary: ExprTernary;
    Call => call: ExprCall;
    Index => index: ExprIndex;
    Field => field: ExprField;
  }
}

struct ExprParen {
  expr: &Expr;
}

struct ExprIntLit {
  val: ullong;
  mod: TokenMod;
  suffix: TokenSuffix;
}

struct ExprFloatLit {
  start: *const char;
  end: *const char;
  val: double;
  suffix: TokenSuffix;
}

struct ExprStrLit {
  val: *const char;
  mod: TokenMod;
}

struct ExprOffsetofField {
  type: &Typespec;
  name: *const char;
}

struct ExprCompound {
  type: &Typespec;
  fields: *CompoundField;
  num_fields: usize;
}

struct ExprCast {
  type: &Typespec;
  expr: &Expr;
}

struct ExprModify {
  op: TokenKind;
  post: bool;
  expr: &Expr;
}

struct ExprUnary {
  op: TokenKind;
  expr: &Expr;
}

struct ExprBinary {
  op: TokenKind;
  left: &Expr;
  right: &Expr;
}

struct ExprTernary {
  cond: &Expr;
  then_expr: &Expr;
  else_expr: &Expr;
}

struct ExprCall {
  expr: &Expr;
  args: *&Expr;
  num_args: usize;
}

struct ExprIndex {
  expr: &Expr;
  index: &Expr;
}

struct ExprField {
  expr: &Expr;
  name: *const char;
}

struct ElseIf {
  cond: &Expr;
  block: StmtList;
}

struct SwitchCasePattern {
  start: &Expr;
  end: &Expr;
}

struct SwitchCase {
  patterns: *SwitchCasePattern;
  num_patterns: usize;
  is_default: bool;
  block: StmtList;
}

struct Stmt {
  notes: Notes;
  pos: SrcPos;
  union switch {
    None | Break | Continue => :void;
    DoWhile | While => while_stmt: StmtWhile;
    Expr | Return => expr: &Expr;
    Goto | Label => label: *const char;
    Assign => assign: StmtAssign;
    Block => block: StmtList;
    Decl => decl: &Decl;
    For => for_stmt: StmtFor;
    If => if_stmt: StmtIf;
    Init => init: StmtInit;
    Note => note: Note;
    Switch => switch_stmt: StmtSwitch;
  }
}

struct StmtIf {
  init: &Stmt;
  cond: &Expr;
  then_block: StmtList;
  elseifs: *ElseIf;
  num_elseifs: usize;
  else_block: StmtList;
}

struct StmtWhile {
  cond: &Expr;
  block: StmtList;
}

struct StmtFor {
  init: &Stmt;
  cond: &Expr;
  next: &Stmt;
  block: StmtList;
}

struct StmtSwitch {
  expr: &Expr;
  cases: *SwitchCase;
  num_cases: usize;
}

struct StmtAssign {
  op: TokenKind;
  left: &Expr;
  right: &Expr;
}

struct StmtInit {
  name: *const char;
  is_mut: bool;
  type: &Typespec;
  expr: &Expr;
}
