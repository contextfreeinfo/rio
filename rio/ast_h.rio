// Kept separate from ast.rio for easier diffing with original source split.

struct NoteArg {
  pos: SrcPos;
  name: *const char;
  expr: &Expr;
}

struct Note {
  pos: SrcPos;
  name: *const char;
  args: *NoteArg;
  num_args: usize;
}

struct Notes {
  notes: *Note;
  num_notes: usize;
}

struct StmtList {
  pos: SrcPos;
  stmts: *&Stmt;
  num_stmts: usize;
}

enum TypespecKind {
  None,
  Name,
  Func,
  Array,
  Ptr,
  Ref,
  Const,
}

// enum union TypespecDetail {
//   None,
//   Ptr,
//   Ref,
//   Const;
//   Name: *const char;
//   Func: TypespecFunc;
//   Array: struct {
//     num_elems: *Expr;
//   }
// }
// TypespecDetail{Name=blah}
// TypespecDetail.None

// enum TypespecDetail {
//   None,
//   Name(*const char),
//   Func(TypespecFunc),
//   Array {num_elems: *Expr},
//   Ptr,
//   Ref,
//   Const,
// }
// TypespecDetail.Name(blah)

struct Typespec {
  kind: TypespecKind;
  pos: SrcPos;
  base: &Typespec;
  is_owned: bool;
  // Almost @tagged
  union {
    name: *const char;
    function: TypespecFunc;
    num_elems: *Expr;
    // Voids?: Ptr, Ref, Const
  }
}

struct TypespecFunc {
  args: *&Typespec;
  num_args: usize;
  has_varargs: bool;
  ret: &Typespec;
}

struct FuncParam {
  pos: SrcPos;
  name: *const char;
  type: &Typespec;
}

enum AggregateItemKind {
  None,
  Field,
  Subaggregate,
}

struct AggregateItem {
  pos: SrcPos;
  kind: AggregateItemKind;
  // Kind names apply only to unions ...
  struct {
    kind_names: **const char;
    num_kind_names: usize;
  }
  // @tagged
  union {
    struct {
      names: **const char;
      num_names: usize;
      type: &Typespec;
    }
    subaggregate: &Aggregate;
  }
}

struct EnumItem {
  pos: SrcPos;
  name: *const char;
  init: &Expr;
}

struct ImportItem {
  name: *const char;
  rename: *const char;
}

enum DeclKind {
  None,
  Enum,
  Struct,
  Union,
  Var,
  Const,
  Typedef,
  Func,
  Note,
  Import,
}

enum AggregateKind {
  None,
  Struct,
  Union,
}

struct Aggregate {
  pos: SrcPos;
  kind: AggregateKind;
  items: *AggregateItem;
  num_items: usize;
  union_enum_decl: &Decl;
}

struct Decl {
  kind: DeclKind;
  pos: SrcPos;
  name: *const char;
  notes: Notes;
  is_incomplete: bool;
  // Almost @tagged
  union {
    note: Note;
    enum_decl: DeclEnum;
    // Incudes: Struct, Union
    aggregate: &Aggregate;
    function: DeclFunc;
    typedef_decl: DeclTypedef;
    var_decl: DeclVar;
    const_decl: DeclVar;
    import_decl: DeclImport;
  }
}

struct DeclEnum {
  type: &Typespec;
  items: *EnumItem;
  num_items: usize;
  scope: *const char;
}

struct DeclFunc {
  params: *FuncParam;
  num_params: usize;
  ret_type: &Typespec;
  has_varargs: bool;
  block: StmtList;
}

struct DeclTypedef {
  type: &Typespec;
}

struct DeclVar {
  type: &Typespec;
  expr: &Expr;
}

struct DeclImport {
  is_relative: bool;
  names: **const char;
  num_names: usize;
  import_all: bool;
  items: *ImportItem;
  num_items: usize;
}

struct Decls {
  decls: *&Decl;
  num_decls: usize;
}

enum ExprKind {
  None,
  Paren,
  Int,
  Float,
  Str,
  Name,
  Cast,
  Call,
  Index,
  Field,
  Compound,
  Unary,
  Binary,
  Ternary,
  Modify,
  SizeofExpr,
  SizeofType,
  TypeofExpr,
  TypeofType,
  AlignofExpr,
  AlignofType,
  Offsetof,
}

enum CompoundFieldKind {
  Default,
  Name,
  Index,
}

struct CompoundField {
  kind: CompoundFieldKind;
  pos: SrcPos;
  init: &Expr;
  // @tagged
  union {
    name: *const char;
    index: &Expr;
  }
}

struct Expr {
  kind: ExprKind;
  pos: SrcPos;
  // @tagged
  union {
    paren: ExprParen;
    int_lit: ExprIntLit;
    float_lit: ExprFloatLit;
    str_lit: ExprStrLit;
    name: *const char;
    sizeof_expr: &Expr;
    sizeof_type: &Typespec;
    typeof_expr: &Expr;
    typeof_type: &Typespec;
    alignof_expr: &Expr;
    alignof_type: &Typespec;
    offsetof_field: ExprOffsetofField;
    compound: ExprCompound;
    cast: ExprCast;
    modify: ExprModify;
    unary: ExprUnary;
    binary: ExprBinary;
    ternary: ExprTernary;
    call: ExprCall;
    index: ExprIndex;
    field: ExprField;
  }
}

struct ExprParen {
  expr: &Expr;
}

struct ExprIntLit {
  val: ullong;
  mod: TokenMod;
  suffix: TokenSuffix;
}

struct ExprFloatLit {
  start: *const char;
  end: *const char;
  val: double;
  suffix: TokenSuffix;
}

struct ExprStrLit {
  val: *const char;
  mod: TokenMod;
}

struct ExprOffsetofField {
  type: &Typespec;
  name: *const char;
}

struct ExprCompound {
  type: &Typespec;
  fields: *CompoundField;
  num_fields: usize;
}

struct ExprCast {
  type: &Typespec;
  expr: &Expr;
}

struct ExprModify {
  op: TokenKind;
  post: bool;
  expr: &Expr;
}

struct ExprUnary {
  op: TokenKind;
  expr: &Expr;
}

struct ExprBinary {
  op: TokenKind;
  left: &Expr;
  right: &Expr;
}

struct ExprTernary {
  cond: &Expr;
  then_expr: &Expr;
  else_expr: &Expr;
}

struct ExprCall {
  expr: &Expr;
  args: *&Expr;
  num_args: usize;
}

struct ExprIndex {
  expr: &Expr;
  index: &Expr;
}

struct ExprField {
  expr: &Expr;
  name: *const char;
}

struct ElseIf {
  cond: &Expr;
  block: StmtList;
}

struct SwitchCasePattern {
  start: &Expr;
  end: &Expr;
}

struct SwitchCase {
  patterns: *SwitchCasePattern;
  num_patterns: usize;
  is_default: bool;
  block: StmtList;
}

@enum struct Stmt {
  notes: Notes;
  pos: SrcPos;
  union switch {
    None | Break | Continue => :void;
    DoWhile | While => while_stmt: StmtWhile;
    Expr | Return => expr: &Expr;
    Goto | Label => label: *const char;
    Assign => assign: StmtAssign;
    Block => block: StmtList;
    Decl => decl: &Decl;
    For => for_stmt: StmtFor;
    If => if_stmt: StmtIf;
    Init => init: StmtInit;
    Note => note: Note;
    Switch => switch_stmt: StmtSwitch;
  }
}

struct StmtIf {
  init: &Stmt;
  cond: &Expr;
  then_block: StmtList;
  elseifs: *ElseIf;
  num_elseifs: usize;
  else_block: StmtList;
}

struct StmtWhile {
  cond: &Expr;
  block: StmtList;
}

struct StmtFor {
  init: &Stmt;
  cond: &Expr;
  next: &Stmt;
  block: StmtList;
}

struct StmtSwitch {
  expr: &Expr;
  cases: *SwitchCase;
  num_cases: usize;
}

struct StmtAssign {
  op: TokenKind;
  left: &Expr;
  right: &Expr;
}

struct StmtInit {
  name: *const char;
  is_mut: bool;
  type: &Typespec;
  expr: &Expr;
}
