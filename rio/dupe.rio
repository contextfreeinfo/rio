typedef MapClosureCall = fn(self: &void, item: Any) -> &void;

struct MapClosure {
  self: &void;
  call: MapClosureCall;
}

struct TypeMap {
  type_args: TypeArgSlice;
  type_params: DeclSlice;
}

fn dupe_aggregate(aggregate: &Aggregate, map: &MapClosure) -> &Aggregate {
  let dupe: &Aggregate = map.call(map.self, Any{aggregate, typeof(*aggregate)});
  if (dupe) {
    return dupe;
  }
  dupe = ast_dup(aggregate, sizeof(*aggregate));
  dupe.items = ast_dup(dupe.items, sizeof(*dupe.items) * dupe.num_items);
  for (let i: usize = 0; i < dupe.num_items; ++i) {
    let item = &dupe.items[i];
    // These are value, not pointer, so presume any modifications are in place.
    map.call(map.self, Any{item, typeof(*item)});
    // Now go deeper.
    @complete
    switch (item.kind) {
      Field => {
        item.type = dupe_typespec(item.type, map);
      }
      Subaggregate => {
        item.subaggregate = dupe_aggregate(item.subaggregate, map);
      }
    }
  }
  return dupe;
}

fn dupe_typespec(type: &Typespec, map: &MapClosure) -> &Typespec {
  let dupe: &Typespec = map.call(map.self, Any{type, typeof(*type)});
  if (dupe) {
    return dupe;
  }
  return type;
}

fn map_type_args(self: &TypeMap, item: Any) -> &void {
  switch (item.type) {
    typeof(Aggregate) => {
      // Let these be copied.
      printf("Copy that agg!\n");
      return NULL;
    }
    typeof(Typespec) => {
      printf("Could be mapping!\n");
      return item.ptr;
    }
    default => {
      printf("Whatever!\n");
      return item.ptr;
    }
  }
}
