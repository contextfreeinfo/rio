typedef MapClosureCall = fn(self: &void, item: Any) -> &void;

struct MapClosure {
  self: &void;
  call: MapClosureCall;
}

struct TypeMap {
  type_args: Slice<TypeArg>;
  type_params: Slice<Decl>;
}

fn dupe_aggregate(aggregate: &Aggregate, map: &MapClosure) -> &Aggregate {
  let dupe: &Aggregate = map.call(map.self, Any{aggregate, typeof(*aggregate)});
  if (dupe) {
    return dupe;
  }
  dupe = ast_dup(aggregate, sizeof(*aggregate));
  dupe.items.items =
    ast_dup(dupe.items.items, sizeof(*dupe.items.items) * dupe.items.length);
  for &(dupe.items) do(item) {
    // These are value, not pointer, so presume any modifications are in place.
    map.call(map.self, Any{item, typeof(*item)});
    // Now go deeper.
    @complete
    switch (item.kind) {
      Field => {
        item.type = dupe_typespec(item.type, map);
      }
      Subaggregate => {
        item.subaggregate = dupe_aggregate(item.subaggregate, map);
      }
    }
  }
  return dupe;
}

fn dupe_block(block: StmtList, map: &MapClosure) -> StmtList {
  let dupe = &block;
  for &(dupe.stmts) do(stmt) {
    *stmt = dupe_stmt(*stmt, map);
  }
  return *dupe;
}

fn dupe_expr(expr: &Expr, map: &MapClosure) -> &Expr {
  return expr;
}

fn dupe_function(func: &DeclFunc, map: &MapClosure) -> &DeclFunc {
  let dupe: &DeclFunc = ast_dup(func, sizeof(*func));
  dupe.params.items =
    ast_dup(dupe.params.items, sizeof(FuncParam) * dupe.params.length);
  for &(dupe.params) do(param) {
    *param = dupe_func_param(*param, map);
  }
  dupe.ret_type = dupe_typespec(dupe.ret_type, map);
  dupe.block = dupe_block(dupe.block, map);
  return dupe;
}

fn dupe_func_param(param: FuncParam, map: &MapClosure) -> FuncParam {
  let dupe = &param;
  dupe.type = dupe_typespec(dupe.type, map);
  if (dupe.default_val) {
    dupe.default_val = dupe_expr(dupe.default_val, map);
  }
  return *dupe;
}

fn dupe_stmt(stmt: &Stmt, map: &MapClosure) -> &Stmt {
  return stmt;
}

fn dupe_typespec(type: &Typespec, map: &MapClosure) -> &Typespec {
  let dupe: &Typespec = map.call(map.self, Any{type, typeof(*type)});
  if (dupe) {
    return dupe;
  }
  dupe = ast_dup(type, sizeof(*type));
  switch (type.kind) {
    Array, Const, Ptr, Ref => {
      dupe.base = dupe_typespec(type.base, map);
    }
    Func => {
      fatal_error(type.pos, "Function types not yet supported in generics\n");
    }
    default => {}
  }
  return dupe;
}

fn get_typespec_sym_name(type: &Typespec) -> *char {
  let buf: *char;
  put_typespec_sym_name(&buf, type);
  return buf;
}

fn map_type_args(self: &TypeMap, item: Any) -> &void {
  switch (item.type) {
    typeof(Aggregate) => {
      // Let these be copied do we can make changes inside.
      return NULL;
    }
    typeof(Typespec) => {
      let type: &Typespec = item.ptr;
      switch (type.kind) {
        Typespec.Name => {
          // See if this is a reference to a type parameter.
          let decl = type.decl;
          let params = self.type_params;
          for &(params) do(param, i) {
            if (decl == param) {
              // Yep. Found it.
              let arg = &self.type_args[i];
              return arg.val;
            }
          }
          // Nope. Just let it be.
          return item.ptr;
        }
        default => {
          // Let others be copied so we can make changes inside.
          return NULL;
        }
      }
    }
    default => {
      // Let these move on.
      return item.ptr;
    }
  }
}

fn put_typespec_sym_name(buf: **char, type: &Typespec) {
  @complete
  switch (type.kind) {
    Name => {
      // This is the perceived type, which is what we want for mangling, so the
      // programmer has some manual control.
      for &(type.names) do(name, i) {
        if (i) {
          buf_printf(buf, "_");
        }
        buf_printf(buf, "%s", name.name);
        // And args, too.
        for &(name.type_args) do(type_arg) {
          buf_printf(buf, "_");
          put_typespec_sym_name(buf, type_arg.val);
        }
      }
    }
    Const => {
      buf_printf(buf, "const_");
      put_typespec_sym_name(buf, type.base);
    }
    Ptr => {
      buf_printf(buf, "ptr_");
      put_typespec_sym_name(buf, type.base);
    }
    Ref => {
      buf_printf(buf, "ref_");
      put_typespec_sym_name(buf, type.base);
    }
    Array => {
      // TODO Do want to resolve the constant count or to convert the expression
      // TODO to a string, or just force typedefs????
      // buf_printf(buf, "array%zu_", type.num_elems);
      buf_printf(buf, "array_");
      put_typespec_sym_name(buf, type.base);
    }
    Func => {
      let function = &type.function;
      buf_printf(buf, "fn_");
      for (let i: usize = 0; i < type.function.num_args; i++) {
        if (i) {
          buf_printf(buf, "_");
        }
        put_typespec_sym_name(buf, type.function.args[i]);
      }
      if (type.function.has_varargs) {
        buf_printf(buf, "_etc");
      }
      if (type.function.ret) {
        buf_printf(buf, "_to_");
        put_typespec_sym_name(buf, type.function.ret);
      }
    }
  } switch;
}
