enum Os {
  Win32,
  Linux,
  OsX,
  Num,
}

let os_names: [Os.Num]*const char = [
  Os.Win32: "win32",
  Os.Linux: "linux",
  Os.OsX: "osx",
];

enum Arch {
  X64,
  X86,
  Num,
}

let arch_names: [Arch.Num]*const char = [
  Arch.X64: "x64",
  Arch.X86: "x86",
];

let target_os: int;
let target_arch: int;

def get_os(name: *const char) -> int {
  for (let i = 0; i < Os.Num; i++) {
    if (strcmp(os_names[i], name) == 0) {
      return i;
    }
  }
  return -1;
}

def get_arch(name: *const char) -> int {
  for (let i = 0; i < Arch.Num; i++) {
    if (strcmp(arch_names[i], name) == 0) {
      return i;
    }
  }
  return -1;
}

def init_default_type_metrics(metrics: [CompilerTypeKind.Num]TypeMetrics) {
  metrics[CompilerTypeKind.Ref] = metrics[CompilerTypeKind.Ptr];
  metrics[CompilerTypeKind.Bool] = {size: 1, align: 1};
  metrics[CompilerTypeKind.Char] = {size: 1, align: 1, max: 0x7f, sign: true};
  metrics[CompilerTypeKind.SChar] = {size: 1, align: 1, max: 0x7f, sign: true};
  metrics[CompilerTypeKind.UChar] = {size: 1, align: 1, max: 0xff};
  metrics[CompilerTypeKind.Short] = {size: 2, align: 2, max: 0x7fff, sign: true};
  metrics[CompilerTypeKind.UShort] = {size: 2, align: 2, max: 0xffff};
  metrics[CompilerTypeKind.Int] = {size: 4, align: 4, max: 0x7fffffff, sign: true};
  metrics[CompilerTypeKind.UInt] = {size: 4, align: 4, max: 0xffffffff};
  metrics[CompilerTypeKind.LLong] = {size: 8, align: 8, max: 0x7fffffffffffffff, sign: true};
  metrics[CompilerTypeKind.ULLong] = {size: 8, align: 8, max: 0xffffffffffffffff};
  metrics[CompilerTypeKind.Float] = {size: 4, align: 4};
  metrics[CompilerTypeKind.Double] = {size: 8, align: 8};
}

let win32_x86_metrics: [CompilerTypeKind.Num]TypeMetrics = [
  // DEFAULT_TYPE_METRICS,
  CompilerTypeKind.Ptr: {size: 4, align: 4},
  CompilerTypeKind.Long: {size: 4, align: 4, max: 0x7fffffff, sign: true},
  CompilerTypeKind.ULong: {size: 4, align: 4, max: 0x7fffffff, sign: true},
];

let win32_x64_metrics: [CompilerTypeKind.Num]TypeMetrics = [
  // DEFAULT_TYPE_METRICS,
  CompilerTypeKind.Ptr: {size: 8, align: 8},
  CompilerTypeKind.Long: {size: 4, align: 4, max: 0x7fffffff, sign: true},
  CompilerTypeKind.ULong: {size: 4, align: 4, max: 0x7fffffff, sign: true},
];

let ilp32_metrics: [CompilerTypeKind.Num]TypeMetrics = [
  // DEFAULT_TYPE_METRICS,
  CompilerTypeKind.Ptr: {size: 4, align: 4},
  CompilerTypeKind.Long: {size: 4, align: 4, max: 0x7fffffff, sign: true},
  CompilerTypeKind.ULong: {size: 4, align: 4, max: 0x7fffffff, sign: true},
];

let lp64_metrics: [CompilerTypeKind.Num]TypeMetrics = [
  // DEFAULT_TYPE_METRICS,
  CompilerTypeKind.Ptr: {size: 8, align: 8},
  CompilerTypeKind.Long: {size: 8, align: 8, max: 0x7fffffffffffffff, sign: true},
  CompilerTypeKind.ULong: {size: 8, align: 8, max: 0xffffffffffffffff, sign: true},
];

def init_target() {
  type_metrics = NULL;
  switch (target_os) {
    Os.Win32 => {
      switch (target_arch) {
        Arch.X86 => type_metrics = win32_x86_metrics;
        Arch.X64 => type_metrics = win32_x64_metrics;
        default => {}
      }
    }
    Os.Linux => {
      switch (target_arch) {
        Arch.X86 => type_metrics = ilp32_metrics;
        Arch.X64 => type_metrics = lp64_metrics;
        default => {}
      }
    }
    Os.OsX => {
      switch (target_arch) {
        Arch.X64 => type_metrics = lp64_metrics;
        default => {}
      }
    }
    default => {}
  }
  if (!type_metrics) {
    printf("Unsupported os/arch combination: %s/%s\n", os_names[target_os], arch_names[target_arch]);
    exit(1);
  }
  init_default_type_metrics(type_metrics);
  // TODO These aren't okay, really.
  // TODO People should be writing code for the abstract machine instead of
  // TODO working on the current machine!
  if (type_metrics[CompilerTypeKind.Ptr].size == 4) {
    type_uintptr = type_uint;
    type_usize = type_uint;
    type_ssize = type_int;
  } else {
    #assert(type_metrics[CompilerTypeKind.Ptr].size == 8);
    type_uintptr = type_ullong;
    type_usize = type_ullong;
    type_ssize = type_llong;
  }
}

def is_excluded_target_filename(name: *const char) -> bool {
  let end = name + strlen(name);

  let ptr1 = end;
  while (ptr1 != name && ptr1[-1] != '_') {
    ptr1--;
  }
  let str1: [MAX_PATH]char;
  if (ptr1 == name) {
    str1[0] = 0;
  } else {
    memcpy(str1, ptr1, end - ptr1);
    str1[end - ptr1] = 0;
    ptr1--;
  }

  let ptr2 = ptr1;
  while (ptr2 != name && ptr2[-1] != '_') {
    ptr2--;
  }
  let str2: [MAX_PATH]char;
  if (ptr2 == name) {
    str2[0] = 0;
  } else {
    memcpy(str2, ptr2, ptr1 - ptr2);
    str2[ptr1 - ptr2] = 0;
  }

  let os1 = get_os(str1);
  let arch1 = get_arch(str1);
  let os2 = get_os(str2);
  let arch2 = get_arch(str2);
  if (arch1 != -1 && os2 != -1) {
    return arch1 != target_arch || os2 != target_os;
  } else if (arch2 != -1 && os1 != -1) {
    return arch2 != target_arch || os1 != target_os;
  } else if (os1 != -1) {
    return os1 != target_os;
  } else if (arch1 != -1) {
    return arch1 != target_arch;
  } else {
    return false;
  }
}
