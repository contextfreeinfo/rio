enum CompilerTypeKind {
  None,
  Incomplete,
  Completing,
  Void,
  Bool,
  Char,
  SChar,
  UChar,
  Short,
  UShort,
  Int,
  UInt,
  Long,
  ULong,
  LLong,
  ULLong,
  Enum,
  Float,
  Double,
  Ptr,
  Ref,
  Func,
  Array,
  Struct,
  Union,
  Const,
  Num,
}

struct TypeField {
  name: *const char;
  type: &Type;
  offset: usize;
}

struct Type {
  kind: CompilerTypeKind;
  size: usize;
  align: usize;
  sym: &Sym;
  base: &Type;
  typeid: int;
  nonmodifiable: bool;
  // Not @tagged?, or just many voids?
  union {
    num_elems: usize;
    aggregate: TypeAggregate;
    function: TypeFunc;
  }
}

struct TypeAggregate {
  fields: *TypeField;
  num_fields: usize;
}

struct TypeFunc {
  params: *&Type;
  num_params: usize;
  has_varargs: bool;
  ret: &Type;
}

struct TypeMetrics {
  size: usize;
  align: usize;
  sign: bool;
  max: ullong;
}

let type_metrics: *TypeMetrics;

let type_void = &Type {CompilerTypeKind.Void};
let type_bool = &Type {CompilerTypeKind.Bool};
let type_char = &Type {CompilerTypeKind.Char};
let type_uchar = &Type {CompilerTypeKind.UChar};
let type_schar = &Type {CompilerTypeKind.SChar};
let type_short = &Type {CompilerTypeKind.Short};
let type_ushort = &Type {CompilerTypeKind.UShort};
let type_int = &Type {CompilerTypeKind.Int};
let type_uint = &Type {CompilerTypeKind.UInt};
let type_long = &Type {CompilerTypeKind.Long};
let type_ulong = &Type {CompilerTypeKind.ULong};
let type_llong = &Type {CompilerTypeKind.LLong};
let type_ullong = &Type {CompilerTypeKind.ULLong};
let type_float = &Type {CompilerTypeKind.Float};
let type_double = &Type {CompilerTypeKind.Double};

let next_typeid: int = 1;

let type_uintptr: &Type;
let type_usize: &Type;
let type_ssize: &Type;

let typeid_map: Map;

fn get_type_from_typeid(typeid: int) -> &Type {
  if (typeid == 0) {
    return NULL;
  }
  return map_get(&typeid_map, (:&void)(:uintptr)typeid);
}

fn register_typeid(type: &Type) {
  map_put(&typeid_map, (:&void)(:uintptr)type.typeid, type);
}

fn type_alloc(kind: TypeKind) -> &Type {
  let type: &Type = xcalloc(1, sizeof(Type));
  type.kind = kind;
  type.typeid = next_typeid++;
  register_typeid(type);
  return type;
}

fn is_ptr_type(type: &Type) -> bool {
  return type.kind == CompilerTypeKind.Ptr || type.kind == CompilerTypeKind.Ref;
}

fn is_ptr_star_type(type: &Type) -> bool {
  return type.kind == CompilerTypeKind.Ptr;
}

fn is_func_type(type: &Type) -> bool {
  return type.kind == CompilerTypeKind.Func;
}

fn is_ptr_like_type(type: &Type) -> bool {
  return is_ptr_type(type) || type.kind == CompilerTypeKind.Func;
}

fn is_const_type(type: &Type) -> bool {
  return type.kind == CompilerTypeKind.Const;
}

fn is_array_type(type: &Type) -> bool {
  return type.kind == CompilerTypeKind.Array;
}

fn is_incomplete_array_type(type: &Type) -> bool {
  return is_array_type(type) && type.num_elems == 0;
}

fn is_integer_type(type: &Type) -> bool {
  return CompilerTypeKind.Bool <= type.kind && type.kind <= CompilerTypeKind.Enum;
}

fn is_floating_type(type: &Type) -> bool {
  return CompilerTypeKind.Float <= type.kind && type.kind <= CompilerTypeKind.Double;
}

fn is_arithmetic_type(type: &Type) -> bool {
  return CompilerTypeKind.Bool <= type.kind && type.kind <= CompilerTypeKind.Double;
}

fn is_scalar_type(type: &Type) -> bool {
  return CompilerTypeKind.Bool <= type.kind && type.kind <= CompilerTypeKind.Func;
}

fn is_aggregate_type(type: &Type) -> bool {
  return type.kind == CompilerTypeKind.Struct || type.kind == CompilerTypeKind.Union;
}

fn is_signed_type(type: &Type) -> bool {
  switch (type.kind) {
  case CompilerTypeKind.Char:
    return type_metrics[CompilerTypeKind.Char].sign;
  case CompilerTypeKind.SChar:
  case CompilerTypeKind.Short:
  case CompilerTypeKind.Int:
  case CompilerTypeKind.Long:
  case CompilerTypeKind.LLong:
    return true;
  default:
    return false;
  }
}

let type_names: [CompilerTypeKind.Num]*const char = {
  [CompilerTypeKind.Void] = "void",
  [CompilerTypeKind.Bool] = "bool",
  [CompilerTypeKind.Char] = "char",
  [CompilerTypeKind.SChar] = "schar",
  [CompilerTypeKind.UChar] = "uchar",
  [CompilerTypeKind.Short] = "short",
  [CompilerTypeKind.UShort] = "ushort",
  [CompilerTypeKind.Int] = "int",
  [CompilerTypeKind.UInt] = "uint",
  [CompilerTypeKind.Long] = "long",
  [CompilerTypeKind.ULong] = "ulong",
  [CompilerTypeKind.LLong] = "llong",
  [CompilerTypeKind.ULLong] = "ullong",
  [CompilerTypeKind.Float] = "float",
  [CompilerTypeKind.Double] = "double",
};

let type_ranks: [CompilerTypeKind.Num]int = {
  [CompilerTypeKind.Bool] = 1,
  [CompilerTypeKind.Char] = 2,
  [CompilerTypeKind.SChar] = 2,
  [CompilerTypeKind.UChar] = 2,
  [CompilerTypeKind.Short] = 3,
  [CompilerTypeKind.UShort] = 3,
  [CompilerTypeKind.Int] = 4,
  [CompilerTypeKind.UInt] = 4,
  [CompilerTypeKind.Long] = 5,
  [CompilerTypeKind.ULong] = 5,
  [CompilerTypeKind.LLong] = 6,
  [CompilerTypeKind.ULLong] = 6,
};

fn type_rank(type: &Type) -> int {
  let rank = type_ranks[type.kind];
  #assert(rank != 0);
  return rank;
}

fn unsigned_type(type: &Type) -> &Type {
  switch (type.kind) {
  case CompilerTypeKind.Bool:
    return type_bool;
  case CompilerTypeKind.Char:
  case CompilerTypeKind.SChar:
  case CompilerTypeKind.UChar:
    return type_uchar;
  case CompilerTypeKind.Short:
  case CompilerTypeKind.UShort:
    return type_ushort;
  case CompilerTypeKind.Int:
  case CompilerTypeKind.UInt:
    return type_uint;
  case CompilerTypeKind.Long:
  case CompilerTypeKind.ULong:
    return type_ulong;
  case CompilerTypeKind.LLong:
  case CompilerTypeKind.ULLong:
    return type_ullong;
  default:
    #assert(0);
    return NULL;
  }
}

fn type_sizeof(type: &Type) -> usize {
  #assert(type.kind > CompilerTypeKind.Completing);
  return type.size;
}

fn type_alignof(type: &Type) -> usize {
  #assert(type.kind > CompilerTypeKind.Completing);
  return type.align;
}

let cached_ptr_types: Map;
let cached_ref_types: Map;

fn type_ptr_any(kind: CompilerTypeKind, base: &Type) -> &Type {
  let cache: &Map;
  @complete
  switch (kind) {
  case CompilerTypeKind.Ptr:
    cache = &cached_ptr_types;
  case CompilerTypeKind.Ref:
    cache = &cached_ref_types;
  }
  let type: *Type = map_get(cache, base);
  if (!type) {
    type = type_alloc(kind);
    // Same base type and sizes beneath.
    type.size = type_metrics[CompilerTypeKind.Ptr].size;
    type.align = type_metrics[CompilerTypeKind.Ptr].align;
    type.base = base;
    map_put(cache, base, type);
  }
  return type;
}

fn type_ptr(base: &Type) -> &Type {
  return type_ptr_any(CompilerTypeKind.Ptr, base);
}

fn type_ref(base: &Type) -> &Type {
  return type_ptr_any(CompilerTypeKind.Ref, base);
}

let cached_const_types: Map;

fn type_const(base: &Type) -> &Type {
  if (base.kind == CompilerTypeKind.Const) {
    return base;
  }
  let type: &Type = map_get(&cached_const_types, base);
  if (!type) {
    complete_type(base);
    type = type_alloc(CompilerTypeKind.Const);
    type.nonmodifiable = true;
    type.size = base.size;
    type.align = base.align;
    type.base = base;
    map_put(&cached_const_types, base, type);
  }
  return type;
}

fn unqualify_type(type: &Type) -> &Type {
  if (type.kind == CompilerTypeKind.Const) {
    return type.base;
  } else {
    return type;
  }
}

struct CachedArrayType {
  type: &Type;
  next: &CachedArrayType;
}

let cached_array_types: Map;

fn type_array(base: &Type, num_elems: usize) -> &Type {
  let hash = hash_mix(hash_ptr(base), hash_uint64(num_elems));
  let key: uint64 = hash ? hash : 1;
  let cached: &CachedArrayType = map_get_from_uint64(&cached_array_types, key);
  for (let it: *CachedArrayType = cached; it; it = it.next) {
    let type = it.type;
    if (type.base == base && type.num_elems == num_elems) {
      return type;
    }
  }
  complete_type(base);
  let type = type_alloc(CompilerTypeKind.Array);
  type.nonmodifiable = base.nonmodifiable;
  type.size = num_elems * type_sizeof(base);
  type.align = type_alignof(base);
  type.base = base;
  type.num_elems = num_elems;
  let new_cached: &CachedArrayType = xmalloc(sizeof(CachedArrayType));
  new_cached.type = type;
  new_cached.next = cached;
  map_put_from_uint64(&cached_array_types, key, new_cached);
  return type;
}

struct CachedFuncType {
  type: &Type;
  next: &CachedFuncType;
}

let cached_func_types: Map;

fn type_func(params: *&Type, num_params: usize, ret: &Type, has_varargs: bool) -> &Type {
  let params_size = num_params * sizeof(*params);
  let hash = hash_mix(hash_bytes(params, params_size), hash_ptr(ret));
  let key: uint64 = hash ? hash : 1;
  let cached: &CachedFuncType = map_get_from_uint64(&cached_func_types, key);
  for (let it = cached; it; it = it.next) {
    let type = it.type;
    if (type.function.num_params == num_params && type.function.ret == ret && type.function.has_varargs == has_varargs) {
      if (memcmp(type.function.params, params, params_size) == 0) {
        return type;
      }
    }
  }
  let type = type_alloc(CompilerTypeKind.Func);
  type.size = type_metrics[CompilerTypeKind.Ptr].size;
  type.align = type_metrics[CompilerTypeKind.Ptr].align;
  type.function.params = memdup(params, params_size);
  type.function.num_params = num_params;
  type.function.has_varargs = has_varargs;
  type.function.ret = ret;
  let new_cached: *CachedFuncType = xmalloc(sizeof(CachedFuncType));
  new_cached.type = type;
  new_cached.next = cached;
  map_put_from_uint64(&cached_func_types, key, new_cached);
  return type;
}

fn has_duplicate_fields(type: &Type) -> bool {
  for (let i: usize = 0; i < type.aggregate.num_fields; i++) {
    for (let j: usize = i+1; j < type.aggregate.num_fields; j++) {
      if (type.aggregate.fields[i].name == type.aggregate.fields[j].name) {
        return true;
      }
    }
  }
  return false;
}

fn add_type_fields(fields: &*TypeField, type: &Type, offset: usize) {
  #assert(type.kind == CompilerTypeKind.Struct || type.kind == CompilerTypeKind.Union);
  for (let i: usize = 0; i < type.aggregate.num_fields; i++) {
    let field = &type.aggregate.fields[i];
    let new_field = TypeField {field.name, field.type, field.offset + offset};
    buf_push((:*&void)fields, &new_field, sizeof(new_field));
  }
}

fn type_complete_struct(type: &Type, fields: *TypeField, num_fields: usize) {
  #assert(type.kind == CompilerTypeKind.Completing);
  type.kind = CompilerTypeKind.Struct;
  type.size = 0;
  type.align = 0;
  let nonmodifiable: bool = false;
  let new_fields: *TypeField;
  for (let it = fields; it != fields + num_fields; it++) {
    #assert(is_pow2(type_alignof(it.type)));
    if (it.name) {
      it.offset = type.size;
      buf_push((:*&void)&new_fields, it, sizeof(*it));
    } else {
      add_type_fields(&new_fields, it.type, type.size);
    }
    type.align = max(type.align, type_alignof(it.type));
    type.size = type_sizeof(it.type) + align_up(type.size, type_alignof(it.type));
    nonmodifiable = it.type.nonmodifiable || nonmodifiable;
  }
  type.size = align_up(type.size, type.align);
  type.aggregate.fields = new_fields;
  type.aggregate.num_fields = buf_len(new_fields);
  type.nonmodifiable = nonmodifiable;
}

fn type_complete_union(type: &Type, fields: *TypeField, num_fields: usize) {
  #assert(type.kind == CompilerTypeKind.Completing);
  type.kind = CompilerTypeKind.Union;
  type.size = 0;
  type.align = 0;
  let nonmodifiable: bool = false;
  let new_fields: *TypeField;
  for (let it = fields; it != fields + num_fields; it++) {
    #assert(it.type.kind > CompilerTypeKind.Completing);
    if (it.name) {
      if (*it.name) {
        // A non-void-switch field.
        it.offset = type.size;
        buf_push((:*&void)&new_fields, it, sizeof(*it));
      }
    } else {
      add_type_fields(&new_fields, it.type, 0);
    }
    type.size = max(type.size, type_sizeof(it.type));
    type.align = max(type.align, type_alignof(it.type));
    nonmodifiable = it.type.nonmodifiable || nonmodifiable;
  }
  type.size = align_up(type.size, type.align);
  type.aggregate.fields = new_fields;
  type.aggregate.num_fields = buf_len(new_fields);
  type.nonmodifiable = nonmodifiable;
}

fn type_incomplete(sym: &Sym) -> &Type {
  let type = type_alloc(CompilerTypeKind.Incomplete);
  type.sym = sym;
  return type;
}

fn type_enum(sym: &Sym, base: &Type) -> &Type {
  let type = type_alloc(CompilerTypeKind.Enum);
  type.sym = sym;
  type.base = base;
  type.size = type_int.size;
  type.align = type_int.align;
  return type;
}

fn init_builtin_type(type: &Type) {
  type.typeid = next_typeid++;
  register_typeid(type);
  type.size = type_metrics[type.kind].size;
  type.align = type_metrics[type.kind].align;
}

fn init_builtin_types() {
  init_builtin_type(type_void);
  init_builtin_type(type_bool);
  init_builtin_type(type_char);
  init_builtin_type(type_uchar);
  init_builtin_type(type_schar);
  init_builtin_type(type_short);
  init_builtin_type(type_ushort);
  init_builtin_type(type_int);
  init_builtin_type(type_uint);
  init_builtin_type(type_long);
  init_builtin_type(type_ulong);
  init_builtin_type(type_llong);
  init_builtin_type(type_ullong);
  init_builtin_type(type_float);
  init_builtin_type(type_double);
}

fn aggregate_item_field_index(type: &Type, name: *const char) -> int {
  #assert(is_aggregate_type(type));
  for (let i: usize = 0; i < type.aggregate.num_fields; i++) {
    if (type.aggregate.fields[i].name == name) {
      return (:int)i;
    }
  }
  return -1;
}

fn aggregate_item_field_type_from_index(type: &Type, index: int) -> &Type {
  #assert(is_aggregate_type(type));
  #assert(0 <= index && index < (:int)type.aggregate.num_fields);
  return type.aggregate.fields[index].type;
}

fn aggregate_item_field_type_from_name(type: &Type, name: *const char) -> &Type {
  #assert(is_aggregate_type(type));
  let index = aggregate_item_field_index(type, name);
  if (index < 0) {
    return NULL;
  }
  return aggregate_item_field_type_from_index(type, index);
}
