enum CompilerTypeKind {
  CMPL_TYPE_NONE,
  CMPL_TYPE_INCOMPLETE,
  CMPL_TYPE_COMPLETING,
  CMPL_TYPE_VOID,
  CMPL_TYPE_BOOL,
  CMPL_TYPE_CHAR,
  CMPL_TYPE_SCHAR,
  CMPL_TYPE_UCHAR,
  CMPL_TYPE_SHORT,
  CMPL_TYPE_USHORT,
  CMPL_TYPE_INT,
  CMPL_TYPE_UINT,
  CMPL_TYPE_LONG,
  CMPL_TYPE_ULONG,
  CMPL_TYPE_LLONG,
  CMPL_TYPE_ULLONG,
  CMPL_TYPE_ENUM,
  CMPL_TYPE_FLOAT,
  CMPL_TYPE_DOUBLE,
  CMPL_TYPE_PTR,
  CMPL_TYPE_FUNC,
  CMPL_TYPE_ARRAY,
  CMPL_TYPE_STRUCT,
  CMPL_TYPE_UNION,
  CMPL_TYPE_CONST,
  NUM_CMPL_TYPE_KINDS,
}

struct TypeField {
  name: char const*;
  type: Type*;
  offset: usize;
}

struct Type {
  kind: CompilerTypeKind;
  size: usize;
  align: usize;
  sym: Sym*;
  base: Type*;
  typeid: int;
  nonmodifiable: bool;
  union {
    num_elems: usize;
    aggregate: TypeAggregate;
    function: TypeFunc;
  }
}

struct TypeAggregate {
  fields: TypeField*;
  num_fields: usize;
}

struct TypeFunc {
  params: Type**;
  num_params: usize;
  has_varargs: bool;
  ret: Type*;
}

struct TypeMetrics {
  size: usize;
  align: usize;
  sign: bool;
  max: ullong;
}

let type_metrics: TypeMetrics*;

let type_void: Type* = &{CMPL_TYPE_VOID};
let type_bool: Type* = &{CMPL_TYPE_BOOL};
let type_char: Type* = &{CMPL_TYPE_CHAR};
let type_uchar: Type* = &{CMPL_TYPE_UCHAR};
let type_schar: Type* = &{CMPL_TYPE_SCHAR};
let type_short: Type* = &{CMPL_TYPE_SHORT};
let type_ushort: Type* = &{CMPL_TYPE_USHORT};
let type_int: Type* = &{CMPL_TYPE_INT};
let type_uint: Type* = &{CMPL_TYPE_UINT};
let type_long: Type* = &{CMPL_TYPE_LONG};
let type_ulong: Type* = &{CMPL_TYPE_ULONG};
let type_llong: Type* = &{CMPL_TYPE_LLONG};
let type_ullong: Type* = &{CMPL_TYPE_ULLONG};
let type_float: Type* = &{CMPL_TYPE_FLOAT};
let type_double: Type* = &{CMPL_TYPE_DOUBLE};

let next_typeid: int = 1;

let type_uintptr: Type*;
let type_usize: Type*;
let type_ssize: Type*;

let typeid_map: Map;

fn get_type_from_typeid(typeid: int): Type* {
  if (typeid == 0) {
    return NULL;
  }
  return map_get(&typeid_map, (:void*)(:uintptr)typeid);
}

fn register_typeid(type: Type*) {
  map_put(&typeid_map, (:void*)(:uintptr)type.typeid, type);
}

fn type_alloc(kind: TypeKind): Type* {
  let type: Type* = xcalloc(1, sizeof(Type));
  type.kind = kind;
  type.typeid = next_typeid++;
  register_typeid(type);
  return type;
}

fn is_ptr_type(type: Type*): bool {
  return type.kind == CMPL_TYPE_PTR;
}

fn is_func_type(type: Type*): bool {
  return type.kind == CMPL_TYPE_FUNC;
}

fn is_ptr_like_type(type: Type*): bool {
  return type.kind == CMPL_TYPE_PTR || type.kind == CMPL_TYPE_FUNC;
}

fn is_const_type(type: Type*): bool {
  return type.kind == CMPL_TYPE_CONST;
}

fn is_array_type(type: Type*): bool {
  return type.kind == CMPL_TYPE_ARRAY;
}

fn is_incomplete_array_type(type: Type*): bool {
  return is_array_type(type) && type.num_elems == 0;
}

fn is_integer_type(type: Type*): bool {
  return CMPL_TYPE_BOOL <= type.kind && type.kind <= CMPL_TYPE_ENUM;
}

fn is_floating_type(type: Type*): bool {
  return CMPL_TYPE_FLOAT <= type.kind && type.kind <= CMPL_TYPE_DOUBLE;
}

fn is_arithmetic_type(type: Type*): bool {
  return CMPL_TYPE_BOOL <= type.kind && type.kind <= CMPL_TYPE_DOUBLE;
}

fn is_scalar_type(type: Type*): bool {
  return CMPL_TYPE_BOOL <= type.kind && type.kind <= CMPL_TYPE_FUNC;
}

fn is_aggregate_type(type: Type*): bool {
  return type.kind == CMPL_TYPE_STRUCT || type.kind == CMPL_TYPE_UNION;
}

fn is_signed_type(type: Type*): bool {
  switch (type.kind) {
  case CMPL_TYPE_CHAR:
    return type_metrics[CMPL_TYPE_CHAR].sign;
  case CMPL_TYPE_SCHAR:
  case CMPL_TYPE_SHORT:
  case CMPL_TYPE_INT:
  case CMPL_TYPE_LONG:
  case CMPL_TYPE_LLONG:
    return true;
  default:
    return false;
  }
}

let type_names: char const*[NUM_CMPL_TYPE_KINDS] = {
  [CMPL_TYPE_VOID] = "void",
  [CMPL_TYPE_BOOL] = "bool",
  [CMPL_TYPE_CHAR] = "char",
  [CMPL_TYPE_SCHAR] = "schar",
  [CMPL_TYPE_UCHAR] = "uchar",
  [CMPL_TYPE_SHORT] = "short",
  [CMPL_TYPE_USHORT] = "ushort",
  [CMPL_TYPE_INT] = "int",
  [CMPL_TYPE_UINT] = "uint",
  [CMPL_TYPE_LONG] = "long",
  [CMPL_TYPE_ULONG] = "ulong",
  [CMPL_TYPE_LLONG] = "llong",
  [CMPL_TYPE_ULLONG] = "ullong",
  [CMPL_TYPE_FLOAT] = "float",
  [CMPL_TYPE_DOUBLE] = "double",
};

let type_ranks: int[NUM_CMPL_TYPE_KINDS] = {
  [CMPL_TYPE_BOOL] = 1,
  [CMPL_TYPE_CHAR] = 2,
  [CMPL_TYPE_SCHAR] = 2,
  [CMPL_TYPE_UCHAR] = 2,
  [CMPL_TYPE_SHORT] = 3,
  [CMPL_TYPE_USHORT] = 3,
  [CMPL_TYPE_INT] = 4,
  [CMPL_TYPE_UINT] = 4,
  [CMPL_TYPE_LONG] = 5,
  [CMPL_TYPE_ULONG] = 5,
  [CMPL_TYPE_LLONG] = 6,
  [CMPL_TYPE_ULLONG] = 6,
};

fn type_rank(type: Type*): int {
  let rank = type_ranks[type.kind];
  #assert(rank != 0);
  return rank;
}

fn unsigned_type(type: Type*): Type* {
  switch (type.kind) {
  case CMPL_TYPE_BOOL:
    return type_bool;
  case CMPL_TYPE_CHAR:
  case CMPL_TYPE_SCHAR:
  case CMPL_TYPE_UCHAR:
    return type_uchar;
  case CMPL_TYPE_SHORT:
  case CMPL_TYPE_USHORT:
    return type_ushort;
  case CMPL_TYPE_INT:
  case CMPL_TYPE_UINT:
    return type_uint;
  case CMPL_TYPE_LONG:
  case CMPL_TYPE_ULONG:
    return type_ulong;
  case CMPL_TYPE_LLONG:
  case CMPL_TYPE_ULLONG:
    return type_ullong;
  default:
    #assert(0);
    return NULL;
  }
}

fn type_sizeof(type: Type*): usize {
  #assert(type.kind > CMPL_TYPE_COMPLETING);
  return type.size;
}

fn type_alignof(type: Type*): usize {
  #assert(type.kind > CMPL_TYPE_COMPLETING);
  return type.align;
}

let cached_ptr_types: Map;

fn type_ptr(base: Type*): Type* {
  let type: Type* = map_get(&cached_ptr_types, base);
  if (!type) {
    type = type_alloc(CMPL_TYPE_PTR);
    type.size = type_metrics[CMPL_TYPE_PTR].size;
    type.align = type_metrics[CMPL_TYPE_PTR].align;
    type.base = base;
    map_put(&cached_ptr_types, base, type);
  }
  return type;
}

let cached_const_types: Map;

fn type_const(base: Type*): Type* {
  if (base.kind == CMPL_TYPE_CONST) {
    return base;
  }
  let type: Type* = map_get(&cached_const_types, base);
  if (!type) {
    complete_type(base);
    type = type_alloc(CMPL_TYPE_CONST);
    type.nonmodifiable = true;
    type.size = base.size;
    type.align = base.align;
    type.base = base;
    map_put(&cached_const_types, base, type);
  }
  return type;
}

fn unqualify_type(type: Type*): Type* {
  if (type.kind == CMPL_TYPE_CONST) {
    return type.base;
  } else {
    return type;
  }
}

struct CachedArrayType {
  type: Type*;
  next: CachedArrayType*;
}

let cached_array_types: Map;

fn type_array(base: Type*, num_elems: usize): Type* {
  let hash = hash_mix(hash_ptr(base), hash_uint64(num_elems));
  let key: uint64 = hash ? hash : 1;
  let cached: CachedArrayType* = map_get_from_uint64(&cached_array_types, key);
  for (let it: CachedArrayType* = cached; it; it = it.next) {
    let type = it.type;
    if (type.base == base && type.num_elems == num_elems) {
      return type;
    }
  }
  complete_type(base);
  let type = type_alloc(CMPL_TYPE_ARRAY);
  type.nonmodifiable = base.nonmodifiable;
  type.size = num_elems * type_sizeof(base);
  type.align = type_alignof(base);
  type.base = base;
  type.num_elems = num_elems;
  let new_cached: CachedArrayType* = xmalloc(sizeof(CachedArrayType));
  new_cached.type = type;
  new_cached.next = cached;
  map_put_from_uint64(&cached_array_types, key, new_cached);
  return type;
}

struct CachedFuncType {
  type: Type*;
  next: CachedFuncType*;
}

let cached_func_types: Map;

fn type_func(params: Type**, num_params: usize, ret: Type*, has_varargs: bool): Type* {
  let params_size = num_params * sizeof(*params);
  let hash = hash_mix(hash_bytes(params, params_size), hash_ptr(ret));
  let key: uint64 = hash ? hash : 1;
  let cached: CachedFuncType* = map_get_from_uint64(&cached_func_types, key);
  for (let it = cached; it; it = it.next) {
    let type = it.type;
    if (type.function.num_params == num_params && type.function.ret == ret && type.function.has_varargs == has_varargs) {
      if (memcmp(type.function.params, params, params_size) == 0) {
        return type;
      }
    }
  }
  let type: Type* = type_alloc(CMPL_TYPE_FUNC);
  type.size = type_metrics[CMPL_TYPE_PTR].size;
  type.align = type_metrics[CMPL_TYPE_PTR].align;
  type.function.params = memdup(params, params_size);
  type.function.num_params = num_params;
  type.function.has_varargs = has_varargs;
  type.function.ret = ret;
  let new_cached: CachedFuncType* = xmalloc(sizeof(CachedFuncType));
  new_cached.type = type;
  new_cached.next = cached;
  map_put_from_uint64(&cached_func_types, key, new_cached);
  return type;
}

fn has_duplicate_fields(type: Type*): bool {
  for (let i: usize = 0; i < type.aggregate.num_fields; i++) {
    for (let j: usize = i+1; j < type.aggregate.num_fields; j++) {
      if (type.aggregate.fields[i].name == type.aggregate.fields[j].name) {
        return true;
      }
    }
  }
  return false;
}

fn add_type_fields(fields: TypeField**, type: Type*, offset: usize) {
  #assert(type.kind == CMPL_TYPE_STRUCT || type.kind == CMPL_TYPE_UNION);
  for (let i: usize = 0; i < type.aggregate.num_fields; i++) {
    let field = &type.aggregate.fields[i];
    let new_field = TypeField {field.name, field.type, field.offset + offset};
    buf_push((:void**)fields, &new_field, sizeof(new_field));
  }
}

fn type_complete_struct(type: Type*, fields: TypeField*, num_fields: usize) {
  #assert(type.kind == CMPL_TYPE_COMPLETING);
  type.kind = CMPL_TYPE_STRUCT;
  type.size = 0;
  type.align = 0;
  let nonmodifiable: bool = false;
  let new_fields: TypeField*;
  for (let it = fields; it != fields + num_fields; it++) {
    #assert(is_pow2(type_alignof(it.type)));
    if (it.name) {
      it.offset = type.size;
      buf_push((:void**)&new_fields, it, sizeof(*it));
    } else {
      add_type_fields(&new_fields, it.type, type.size);
    }
    type.align = max(type.align, type_alignof(it.type));
    type.size = type_sizeof(it.type) + align_up(type.size, type_alignof(it.type));
    nonmodifiable = it.type.nonmodifiable || nonmodifiable;
  }
  type.size = align_up(type.size, type.align);
  type.aggregate.fields = new_fields;
  type.aggregate.num_fields = buf_len(new_fields);
  type.nonmodifiable = nonmodifiable;
}

fn type_complete_union(type: Type*, fields: TypeField*, num_fields: usize) {
  #assert(type.kind == CMPL_TYPE_COMPLETING);
  type.kind = CMPL_TYPE_UNION;
  type.size = 0;
  type.align = 0;
  let nonmodifiable: bool = false;
  let new_fields: TypeField*;
  for (let it = fields; it != fields + num_fields; it++) {
    #assert(it.type.kind > CMPL_TYPE_COMPLETING);
    if (it.name) {
      it.offset = type.size;
      buf_push((:void**)&new_fields, it, sizeof(*it));
    } else {
      add_type_fields(&new_fields, it.type, 0);
    }
    type.size = max(type.size, type_sizeof(it.type));
    type.align = max(type.align, type_alignof(it.type));
    nonmodifiable = it.type.nonmodifiable || nonmodifiable;
  }
  type.size = align_up(type.size, type.align);
  type.aggregate.fields = new_fields;
  type.aggregate.num_fields = buf_len(new_fields);
  type.nonmodifiable = nonmodifiable;
}

fn type_incomplete(sym: Sym*): Type* {
  let type = type_alloc(CMPL_TYPE_INCOMPLETE);
  type.sym = sym;
  return type;
}

fn type_enum(sym: Sym*, base: Type*): Type* {
  let type = type_alloc(CMPL_TYPE_ENUM);
  type.sym = sym;
  type.base = base;
  type.size = type_int.size;
  type.align = type_int.align;
  return type;
}

fn init_builtin_type(type: Type*) {
  type.typeid = next_typeid++;
  register_typeid(type);
  type.size = type_metrics[type.kind].size;
  type.align = type_metrics[type.kind].align;
}

fn init_builtin_types() {
  init_builtin_type(type_void);
  init_builtin_type(type_bool);
  init_builtin_type(type_char);
  init_builtin_type(type_uchar);
  init_builtin_type(type_schar);
  init_builtin_type(type_short);
  init_builtin_type(type_ushort);
  init_builtin_type(type_int);
  init_builtin_type(type_uint);
  init_builtin_type(type_long);
  init_builtin_type(type_ulong);
  init_builtin_type(type_llong);
  init_builtin_type(type_ullong);
  init_builtin_type(type_float);
  init_builtin_type(type_double);
}

fn aggregate_item_field_index(type: Type*, name: char const*): int {
  #assert(is_aggregate_type(type));
  for (let i: usize = 0; i < type.aggregate.num_fields; i++) {
    if (type.aggregate.fields[i].name == name) {
      return (:int)i;
    }
  }
  return -1;
}

fn aggregate_item_field_type_from_index(type: Type*, index: int): Type* {
  #assert(is_aggregate_type(type));
  #assert(0 <= index && index < (:int)type.aggregate.num_fields);
  return type.aggregate.fields[index].type;
}

fn aggregate_item_field_type_from_name(type: Type*, name: char const*): Type* {
  #assert(is_aggregate_type(type));
  let index = aggregate_item_field_index(type, name);
  if (index < 0) {
    return NULL;
  }
  return aggregate_item_field_type_from_index(type, index);
}
