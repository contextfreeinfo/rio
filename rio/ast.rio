let ast_arena: Arena;

fn ast_alloc(size: usize) -> &void {
  #assert(size != 0);
  let ptr = arena_alloc(&ast_arena, size);
  memset(ptr, 0, size);
  return ptr;
}

fn ast_dup(src: &const void, size: usize) -> &void {
  if (size == 0) {
    return NULL;
  }
  let ptr = arena_alloc(&ast_arena, size);
  memcpy(ptr, src, size);
  return ptr;
}

// #define AST_DUP(x) ast_dup(x, num_##x * sizeof(*x))

fn new_note(pos: SrcPos, name: *const char, args: *NoteArg, num_args: usize) -> Note {
  return {pos = pos, name = name, args = ast_dup(args, num_args * sizeof(*args)), num_args = num_args};
}

fn new_notes(notes: *Note, num_notes: usize) -> Notes {
  return {ast_dup(notes, num_notes * sizeof(*notes)), num_notes};
}

fn new_stmt_list(pos: SrcPos, stmts: *&Stmt, num_stmts: usize) -> StmtList {
  return {pos, ast_dup(stmts, num_stmts * sizeof(*stmts)), num_stmts};
}

fn new_typespec(kind: TypespecKind, pos: SrcPos) -> &Typespec {
  let t: &Typespec = ast_alloc(sizeof(Typespec));
  t.kind = kind;
  t.pos = pos;
  return t;
}

fn new_typespec_name(pos: SrcPos, name: *const char) -> &Typespec {
  let t = new_typespec(TypespecKind.Name, pos);
  t.name = name;
  return t;
}

fn new_typespec_ptr(pos: SrcPos, base: &Typespec, is_owned: bool) -> &Typespec {
  let t = new_typespec(TypespecKind.Ptr, pos);
  t.base = base;
  t.is_owned = is_owned;
  return t;
}

fn new_typespec_ref(pos: SrcPos, base: &Typespec, is_owned: bool) -> &Typespec {
  let t = new_typespec(TypespecKind.Ref, pos);
  t.base = base;
  t.is_owned = is_owned;
  return t;
}

fn new_typespec_const(pos: SrcPos, base: &Typespec) -> &Typespec {
  let t = new_typespec(TypespecKind.Const, pos);
  t.base = base;
  return t;
}

fn new_typespec_array(pos: SrcPos, elem: &Typespec, size: &Expr) -> &Typespec {
  let t = new_typespec(TypespecKind.Array, pos);
  t.base = elem;
  t.num_elems = size;
  return t;
}

fn new_typespec_func(pos: SrcPos, args: *&Typespec, num_args: usize, ret: &Typespec, has_varargs: bool) -> &Typespec {
  let t = new_typespec(TypespecKind.Func, pos);
  t.function.args = ast_dup(args, num_args * sizeof(*args));
  t.function.num_args = num_args;
  t.function.ret = ret;
  t.function.has_varargs = has_varargs;
  return t;
}

fn new_decls(decls: *&Decl, num_decls: usize) -> &Decls {
  let d: &Decls = ast_alloc(sizeof(Decls));
  d.decls = ast_dup(decls, num_decls * sizeof(*decls));
  d.num_decls = num_decls;
  return d;
}

fn new_decl(kind: DeclKind, pos: SrcPos, name: *const char) -> &Decl {
  let d: &Decl = ast_alloc(sizeof(Decl));
  d.kind = kind;
  d.pos = pos;
  d.name = name;
  return d;
}

fn get_decl_note(decl: &Decl, name: *const char) -> &Note {
  return get_note(&decl.notes, name);
}

fn get_note(notes: &Notes, name: *const char) -> &Note {
  for (let i: usize = 0; i < notes.num_notes; i++) {
    let note: &Note = notes.notes + i;
    if (note.name == name) {
      return note;
    }
  }
  return NULL;
}

fn get_subunion(num_items: usize, items: *AggregateItem) -> &Aggregate {
  // See if we are a struct with a subunion.
  let result: &Aggregate;
  for (let i: usize = 0; i < num_items; i++) {
    let item = items[i];
    if (item.kind == AggregateItemKind.Subaggregate) {
      if (item.subaggregate.kind == AggregateKind.Union) {
        // But only one subunion here is allowed.
        if (result) {
          fatal_error(item.subaggregate.pos, "Multiple unions in struct");
          return NULL;
        }
        result = item.subaggregate;
      }
    }
  }
  return result;
}

fn is_decl_foreign(decl: &Decl) -> bool {
  return get_decl_note(decl, foreign_name) != NULL;
}

fn new_decl_enum(pos: SrcPos, name: *const char, type: &Typespec, items: *EnumItem, num_items: usize) -> &Decl {
  let d = new_decl(DeclKind.Enum, pos, name);
  d.enum_decl.type = type;
  d.enum_decl.items = ast_dup(items, num_items * sizeof(*items));
  d.enum_decl.num_items = num_items;
  return d;
}

fn new_aggregate(
  pos: SrcPos, kind: AggregateKind, items: *AggregateItem, num_items: usize,
) -> &Aggregate {
  let aggregate: &Aggregate = ast_alloc(sizeof(Aggregate));
  aggregate.pos = pos;
  aggregate.kind = kind;
  aggregate.items = ast_dup(items, num_items * sizeof(*items));
  if (items) {
    // This is safe for our usage, but how to define generally?
    buf_free((:*&void)&items);
  }
  aggregate.num_items = num_items;
  return aggregate;
}

fn new_decl_aggregate(pos: SrcPos, kind: DeclKind, name: *const char, aggregate: &Aggregate) -> &Decl {
  #assert(kind == DeclKind.Struct || kind == DeclKind.Union);
  let d = new_decl(kind, pos, name);
  d.aggregate = aggregate;
  return d;
}

fn new_decl_var(pos: SrcPos, name: *const char, type: &Typespec, expr: &Expr) -> &Decl {
  let d = new_decl(DeclKind.Var, pos, name);
  d.var_decl.type = type;
  d.var_decl.expr = expr;
  return d;
}

fn new_decl_func(pos: SrcPos, name: *const char, params: *FuncParam, num_params: usize, ret_type: &Typespec, has_varargs: bool, block: StmtList) -> &Decl {
  let d = new_decl(DeclKind.Func, pos, name);
  d.function.params = ast_dup(params, num_params * sizeof(*params));
  d.function.num_params = num_params;
  d.function.ret_type = ret_type;
  d.function.has_varargs = has_varargs;
  d.function.block = block;
  return d;
}

fn new_decl_const(pos: SrcPos, name: *const char, type: &Typespec, expr: &Expr) -> &Decl {
  let d = new_decl(DeclKind.Const, pos, name);
  d.const_decl.type = type;
  d.const_decl.expr = expr;
  return d;
}

fn new_decl_typedef(pos: SrcPos, name: *const char, type: &Typespec) -> &Decl {
  let d = new_decl(DeclKind.Typedef, pos, name);
  d.typedef_decl.type = type;
  return d;
}

fn new_decl_note(pos: SrcPos, note: Note) -> &Decl {
  let d = new_decl(DeclKind.Note, pos, NULL);
  d.note = note;
  return d;
}

fn new_decl_import(pos: SrcPos, rename_name: *const char, is_relative: bool, names: **const char, num_names: usize, import_all: bool, items: *ImportItem, num_items: usize) -> &Decl {
  let d = new_decl(DeclKind.Import, pos, NULL);
  d.name = rename_name;
  d.import_decl.is_relative = is_relative;
  d.import_decl.names = ast_dup(names, num_names * sizeof(*names));
  d.import_decl.num_names = num_names;
  d.import_decl.import_all = import_all;
  d.import_decl.items = ast_dup(items, num_items * sizeof(*items));
  d.import_decl.num_items = num_items;
  return d;
}

fn new_expr(kind: ExprKind, pos: SrcPos) -> &Expr {
  let e: &Expr = ast_alloc(sizeof(Expr));
  e.kind = kind;
  e.pos = pos;
  return e;
}

fn new_expr_paren(pos: SrcPos, expr: &Expr) -> &Expr {
  let e = new_expr(ExprKind.Paren, pos);
  e.paren.expr = expr;
  return e;
}

fn new_expr_sizeof_expr(pos: SrcPos, expr: &Expr) -> &Expr {
  let e = new_expr(ExprKind.SizeofExpr, pos);
  e.sizeof_expr = expr;
  return e;
}

fn new_expr_sizeof_type(pos: SrcPos, type: &Typespec) -> &Expr {
  let e = new_expr(ExprKind.SizeofType, pos);
  e.sizeof_type = type;
  return e;
}

fn new_expr_typeof_expr(pos: SrcPos, expr: &Expr) -> &Expr {
  let e = new_expr(ExprKind.TypeofExpr, pos);
  e.typeof_expr  = expr;
  return e;
}

fn new_expr_typeof_type(pos: SrcPos, type: &Typespec) -> &Expr {
  let e = new_expr(ExprKind.TypeofType, pos);
  e.typeof_type = type;
  return e;
}

fn new_expr_alignof_expr(pos: SrcPos, expr: &Expr) -> &Expr {
  let e = new_expr(ExprKind.AlignofExpr, pos);
  e.alignof_expr = expr;
  return e;
}

fn new_expr_alignof_type(pos: SrcPos, type: &Typespec) -> &Expr {
  let e = new_expr(ExprKind.AlignofType, pos);
  e.alignof_type = type;
  return e;
}

fn new_expr_offsetof(pos: SrcPos, type: &Typespec, name: *const char) -> &Expr {
  let e = new_expr(ExprKind.Offsetof, pos);
  e.offsetof_field.type = type;
  e.offsetof_field.name = name;
  return e;
}

fn new_expr_modify(pos: SrcPos, op: TokenKind, post: bool, expr: &Expr) -> &Expr {
  let e = new_expr(ExprKind.Modify, pos);
  e.modify.op = op;
  e.modify.post = post;
  e.modify.expr = expr;
  return e;
}

fn new_expr_int(pos: SrcPos, val: ullong, mod: TokenMod, suffix: TokenSuffix) -> &Expr {
  let e = new_expr(ExprKind.Int, pos);
  e.int_lit.val = val;
  e.int_lit.mod = mod;
  e.int_lit.suffix = suffix;
  return e;
}

fn new_expr_float(pos: SrcPos, start: *const char, end: *const char, val: double, suffix: TokenSuffix) -> &Expr {
  let e = new_expr(ExprKind.Float, pos);
  e.float_lit.start = start;
  e.float_lit.end = end;
  e.float_lit.val = val;
  e.float_lit.suffix = suffix;
  return e;
}

fn new_expr_str(pos: SrcPos, val: *const char, mod: TokenMod) -> &Expr {
  let e = new_expr(ExprKind.Str, pos);
  e.str_lit.val = val;
  e.str_lit.mod = mod;
  return e;
}

fn new_expr_name(pos: SrcPos, name: *const char) -> &Expr {
  let e = new_expr(ExprKind.Name, pos);
  e.name = name;
  return e;
}

fn new_expr_compound(pos: SrcPos, type: &Typespec, fields: *CompoundField, num_fields: usize) -> &Expr {
  let e = new_expr(ExprKind.Compound, pos);
  e.compound.type = type;
  e.compound.fields = ast_dup(fields, num_fields * sizeof(*fields));
  e.compound.num_fields = num_fields;
  return e;
}

fn new_expr_cast(pos: SrcPos, type: &Typespec, expr: &Expr) -> &Expr {
  let e = new_expr(ExprKind.Cast, pos);
  e.cast.type = type;
  e.cast.expr = expr;
  return e;
}

fn new_expr_call(pos: SrcPos, expr: &Expr, args: *&Expr, num_args: usize) -> &Expr {
  let e = new_expr(ExprKind.Call, pos);
  e.call.expr = expr;
  e.call.args = ast_dup(args, num_args * sizeof(*args));
  e.call.num_args = num_args;
  return e;
}

fn new_expr_index(pos: SrcPos, expr: &Expr, index: &Expr) -> &Expr {
  let e = new_expr(ExprKind.Index, pos);
  e.index.expr = expr;
  e.index.index = index;
  return e;
}

fn new_expr_field(pos: SrcPos, expr: &Expr, name: *const char) -> &Expr {
  let e = new_expr(ExprKind.Field, pos);
  e.field.expr = expr;
  e.field.name = name;
  return e;
}

fn new_expr_unary(pos: SrcPos, op: TokenKind, expr: &Expr) -> &Expr {
  let e = new_expr(ExprKind.Unary, pos);
  e.unary.op = op;
  e.unary.expr = expr;
  return e;
}

fn new_expr_binary(pos: SrcPos, op: TokenKind, left: &Expr, right: &Expr) -> &Expr {
  let e = new_expr(ExprKind.Binary, pos);
  e.binary.op = op;
  e.binary.left = left;
  e.binary.right = right;
  return e;
}

fn new_expr_ternary(pos: SrcPos, cond: &Expr, then_expr: &Expr, else_expr: &Expr) -> &Expr {
  let e = new_expr(ExprKind.Ternary, pos);
  e.ternary.cond = cond;
  e.ternary.then_expr = then_expr;
  e.ternary.else_expr = else_expr;
  return e;
}

fn get_stmt_note(stmt: &Stmt, name: *const char) -> &Note {
  for (let i: usize = 0; i < stmt.notes.num_notes; i++) {
    let note = stmt.notes.notes + i;
    if (note.name == name) {
      return note;
    }
  }
  return NULL;
}

fn new_stmt(kind: Stmt_Kind, pos: SrcPos) -> &Stmt {
  let s: &Stmt = ast_alloc(sizeof(Stmt));
  s.kind = kind;
  s.pos = pos;
  return s;
}

fn new_stmt_label(pos: SrcPos, label: *const char) -> &Stmt {
  let s = new_stmt(Stmt.Label, pos);
  s.label = label;
  return s;
}

fn new_stmt_goto(pos: SrcPos, label: *const char) -> &Stmt {
  let s = new_stmt(Stmt.Goto, pos);
  s.label = label;
  return s;
}

fn new_stmt_note(pos: SrcPos, note: Note) -> &Stmt {
  let s = new_stmt(Stmt.Note, pos);
  s.note = note;
  return s;
}

fn new_stmt_decl(pos: SrcPos, decl: &Decl) -> &Stmt {
  let s = new_stmt(Stmt.Decl, pos);
  s.decl = decl;
  return s;
}

fn new_stmt_return(pos: SrcPos, expr: &Expr) -> &Stmt {
  let s = new_stmt(Stmt.Return, pos);
  s.expr = expr;
  return s;
}

fn new_stmt_break(pos: SrcPos) -> &Stmt {
  return new_stmt(Stmt.Break, pos);
}

fn new_stmt_continue(pos: SrcPos) -> &Stmt {
  return new_stmt(Stmt.Continue, pos);
}

fn new_stmt_block(pos: SrcPos, block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.Block, pos);
  s.block = block;
  return s;
}

fn new_stmt_if(pos: SrcPos, init: &Stmt, cond: &Expr, then_block: StmtList, elseifs: *ElseIf, num_elseifs: usize, else_block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.If, pos);
  s.if_stmt.init = init;
  s.if_stmt.cond = cond;
  s.if_stmt.then_block = then_block;
  s.if_stmt.elseifs = ast_dup(elseifs, num_elseifs * sizeof(*elseifs));
  s.if_stmt.num_elseifs = num_elseifs;
  s.if_stmt.else_block = else_block;
  return s;
}

fn new_stmt_while(pos: SrcPos, cond: &Expr, block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.While, pos);
  s.while_stmt.cond = cond;
  s.while_stmt.block = block;
  return s;
}

fn new_stmt_do_while(pos: SrcPos, cond: &Expr, block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.DoWhile, pos);
  s.while_stmt.cond = cond;
  s.while_stmt.block = block;
  return s;
}

fn new_stmt_for(pos: SrcPos, init: &Stmt, cond: &Expr, next: &Stmt, block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.For, pos);
  s.for_stmt.init = init;
  s.for_stmt.cond = cond;
  s.for_stmt.next = next;
  s.for_stmt.block = block;
  return s;
}

fn new_stmt_switch(pos: SrcPos, expr: &Expr, cases: *SwitchCase, num_cases: usize) -> &Stmt {
  let s = new_stmt(Stmt.Switch, pos);
  s.switch_stmt.expr = expr;
  s.switch_stmt.cases = ast_dup(cases, num_cases * sizeof(*cases));
  s.switch_stmt.num_cases = num_cases;
  return s;
}

fn new_stmt_assign(pos: SrcPos, op: TokenKind, left: &Expr, right: &Expr) -> &Stmt {
  let s = new_stmt(Stmt.Assign, pos);
  s.assign.op = op;
  s.assign.left = left;
  s.assign.right = right;
  return s;
}

fn new_stmt_init(pos: SrcPos, name: *const char, is_mut: bool, type: &Typespec, expr: &Expr) -> &Stmt {
  let s = new_stmt(Stmt.Init, pos);
  s.init.name = name;
  s.init.is_mut = is_mut;
  s.init.type = type;
  s.init.expr = expr;
  return s;
}

fn new_stmt_expr(pos: SrcPos, expr: &Expr) -> &Stmt {
  let s = new_stmt(Stmt.Expr, pos);
  s.expr = expr;
  return s;
}

// #undef AST_DUP
