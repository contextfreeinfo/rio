// Types.

struct NoteArg {
  pos: SrcPos;
  name: *const char;
  expr: &Expr;
}

struct Note {
  pos: SrcPos;
  name: *const char;
  args: *NoteArg;
  num_args: usize;
}

struct Notes {
  notes: *Note;
  num_notes: usize;
}

struct StmtList {
  pos: SrcPos;
  stmts: *&Stmt;
  num_stmts: usize;
}

struct Typespec {
  pos: SrcPos;
  base: &Typespec;
  is_owned: bool;
  union switch {
    None, Const, Ptr, Ref => :void;
    Name => struct {
      // TODO Break these out into individual AST items!
      names: *TypespecName;
      num_names: usize;
      decl: &Decl;
    }
    Func => function: TypespecFunc;
    Array => num_elems: *Expr;
  }
}

struct TypespecName {
  name: *const char;
  type_args: TypeArgSlice;
}

struct TypespecFunc {
  args: *&Typespec;
  num_args: usize;
  has_varargs: bool;
  ret: &Typespec;
}

struct FuncParam {
  pos: SrcPos;
  name: *const char;
  type: &Typespec;
  // TODO Support default values!
  default_val: &Expr;
}

struct TypeArg {
  pos: SrcPos;
  val: &Typespec;
}

struct TypeArgSlice {
  length: usize;
  items: *TypeArg;
}

struct DeclSlice {
  length: usize;
  items: *Decl;
}

struct AggregateItem {
  pos: SrcPos;
  // Kind names apply only to unions ...
  struct {
    kind_names: **const char;
    num_kind_names: usize;
  }
  union switch {
    None => :void;
    Field => struct {
      names: **const char;
      num_names: usize;
      type: &Typespec;
    }
    Subaggregate => subaggregate: &Aggregate;
  }
}

struct EnumItem {
  pos: SrcPos;
  name: *const char;
  init: &Expr;
}

struct ImportItem {
  name: *const char;
  rename: *const char;
}

enum AggregateKind {
  None,
  Struct,
  Union,
}

struct Aggregate {
  pos: SrcPos;
  kind: AggregateKind;
  items: *AggregateItem;
  num_items: usize;
  union_enum_decl: &Decl;
}

struct SymRef {
  union switch {
    // More precisely, a name ref, but this includes pos.
    Expr => expr: &Expr;
    // Again a name typespect.
    Type => type: &Typespec;
  }
}

struct SymRefSlice {
  length: usize;
  items: *SymRef;
}

struct Decl {
  pos: SrcPos;
  name: *const char;
  notes: Notes;
  is_incomplete: bool;
  type_params: DeclSlice;
  refs: SymRefSlice;
  union switch {
    None => :void;
    Note => note: Note;
    Enum => enum_decl: DeclEnum;
    Struct, Union => aggregate: &Aggregate;
    Func => function: DeclFunc;
    Typedef => typedef_decl: DeclTypedef;
    // This is an example of wanting different names for the same thing ...
    Var => var_decl: DeclVar;
    Const => const_decl: DeclVar;
    Import => import_decl: DeclImport;
  }
}

struct DeclEnum {
  type: &Typespec;
  items: *EnumItem;
  num_items: usize;
  scope: *const char;
}

struct DeclFunc {
  params: *FuncParam;
  num_params: usize;
  ret_type: &Typespec;
  has_varargs: bool;
  block: StmtList;
}

struct DeclTypedef {
  constraint: &Typespec;
  val: &Typespec;
}

struct DeclVar {
  type: &Typespec;
  expr: &Expr;
}

struct DeclImport {
  is_relative: bool;
  names: **const char;
  num_names: usize;
  import_all: bool;
  items: *ImportItem;
  num_items: usize;
}

struct Decls {
  decls: *&Decl;
  num_decls: usize;
}

struct CompoundField {
  pos: SrcPos;
  init: &Expr;
  union switch {
    Default => :void;
    Name => name: *const char;
    Index => index: &Expr;
  }
}

struct Expr {
  pos: SrcPos;
  union switch {
    None => :void;
    Paren => paren: ExprParen;
    Int => int_lit: ExprIntLit;
    Float => float_lit: ExprFloatLit;
    Str => str_lit: ExprStrLit;
    Name => name: *const char;
    SizeofExpr => sizeof_expr: &Expr;
    SizeofType => sizeof_type: &Typespec;
    TypeofExpr => typeof_expr: &Expr;
    TypeofType => typeof_type: &Typespec;
    AlignofExpr => alignof_expr: &Expr;
    AlignofType => alignof_type: &Typespec;
    Offsetof => offsetof_field: ExprOffsetofField;
    Compound => compound: ExprCompound;
    Cast => cast: ExprCast;
    Modify => modify: ExprModify;
    Unary => unary: ExprUnary;
    Binary => binary: ExprBinary;
    Ternary => ternary: ExprTernary;
    Call => call: ExprCall;
    Index => index: ExprIndex;
    Field => field: ExprField;
  }
}

struct ExprParen {
  expr: &Expr;
}

struct ExprIntLit {
  val: ullong;
  mod: TokenMod;
  suffix: TokenSuffix;
}

struct ExprFloatLit {
  start: *const char;
  end: *const char;
  val: double;
  suffix: TokenSuffix;
}

struct ExprStrLit {
  val: *const char;
  mod: TokenMod;
}

struct ExprOffsetofField {
  type: &Typespec;
  name: *const char;
}

struct ExprCompound {
  type: &Typespec;
  fields: *CompoundField;
  num_fields: usize;
}

struct ExprCast {
  type: &Typespec;
  expr: &Expr;
}

struct ExprModify {
  op: TokenKind;
  post: bool;
  expr: &Expr;
}

struct ExprUnary {
  op: TokenKind;
  expr: &Expr;
}

struct ExprBinary {
  op: TokenKind;
  left: &Expr;
  right: &Expr;
}

struct ExprTernary {
  cond: &Expr;
  then_expr: &Expr;
  else_expr: &Expr;
}

struct ExprCall {
  expr: &Expr;
  args: *&Expr;
  num_args: usize;
}

struct ExprIndex {
  expr: &Expr;
  index: &Expr;
}

struct ExprField {
  expr: &Expr;
  name: *const char;
}

struct ElseIf {
  cond: &Expr;
  block: StmtList;
}

struct SwitchCasePattern {
  is_default: bool;
  start: &Expr;
  end: &Expr;
}

struct SwitchCase {
  patterns: *SwitchCasePattern;
  num_patterns: usize;
  block: StmtList;
}

struct Stmt {
  notes: Notes;
  pos: SrcPos;
  union switch {
    None, Break, Continue => :void;
    DoWhile, While => while_stmt: StmtWhile;
    Expr, Return => expr: &Expr;
    Goto, Label => label: *const char;
    Assign => assign: StmtAssign;
    Block => block: StmtList;
    Decl => decl: &Decl;
    For => for_stmt: StmtFor;
    If => if_stmt: StmtIf;
    Init => init: StmtInit;
    Note => note: Note;
    Switch => switch_stmt: StmtSwitch;
    Close => tag: Stmt.Kind;
  }
}

struct StmtIf {
  init: &Stmt;
  cond: &Expr;
  then_block: StmtList;
  elseifs: *ElseIf;
  num_elseifs: usize;
  else_block: StmtList;
}

struct StmtWhile {
  cond: &Expr;
  block: StmtList;
}

struct StmtFor {
  init: &Stmt;
  cond: &Expr;
  next: &Stmt;
  block: StmtList;
}

struct StmtSwitch {
  expr: &Expr;
  cases: *SwitchCase;
  num_cases: usize;
}

struct StmtAssign {
  op: TokenKind;
  left: &Expr;
  right: &Expr;
}

struct StmtInit {
  name: *const char;
  is_mut: bool;
  type: &Typespec;
  expr: &Expr;
}

// Support code.

let ast_arena: Arena;

fn ast_alloc(size: usize) -> &void {
  #assert(size != 0);
  let ptr = arena_alloc(&ast_arena, size);
  memset(ptr, 0, size);
  return ptr;
}

fn ast_dup(src: &const void, size: usize) -> &void {
  if (size == 0) {
    return NULL;
  }
  let ptr = arena_alloc(&ast_arena, size);
  memcpy(ptr, src, size);
  return ptr;
}

// #define AST_DUP(x) ast_dup(x, num_##x * sizeof(*x))

fn new_note(pos: SrcPos, name: *const char, args: *NoteArg, num_args: usize) -> Note {
  return {pos = pos, name = name, args = ast_dup(args, num_args * sizeof(*args)), num_args = num_args};
}

fn new_notes(notes: *Note, num_notes: usize) -> Notes {
  return {ast_dup(notes, num_notes * sizeof(*notes)), num_notes};
}

fn new_stmt_list(pos: SrcPos, stmts: *&Stmt, num_stmts: usize) -> StmtList {
  return {pos, ast_dup(stmts, num_stmts * sizeof(*stmts)), num_stmts};
}

fn new_typespec(kind: Typespec.Kind, pos: SrcPos) -> &Typespec {
  let t: &Typespec = ast_alloc(sizeof(Typespec));
  t.kind = kind;
  t.pos = pos;
  return t;
}

fn new_typespec_name1(pos: SrcPos, name: *const char) -> &Typespec {
  return new_typespec_name(pos, &TypespecName{name = name}, 1);
}

fn new_typespec_name(
  pos: SrcPos, names: *TypespecName, num_names: usize,
) -> &Typespec {
  let t = new_typespec(Typespec.Name, pos);
  t.names = ast_dup(names, num_names * sizeof(*names));
  t.num_names = num_names;
  return t;
}

fn new_typespec_ptr(pos: SrcPos, base: &Typespec, is_owned: bool) -> &Typespec {
  let t = new_typespec(Typespec.Ptr, pos);
  t.base = base;
  t.is_owned = is_owned;
  return t;
}

fn new_typespec_ref(pos: SrcPos, base: &Typespec, is_owned: bool) -> &Typespec {
  let t = new_typespec(Typespec.Ref, pos);
  t.base = base;
  t.is_owned = is_owned;
  return t;
}

fn new_typespec_const(pos: SrcPos, base: &Typespec) -> &Typespec {
  let t = new_typespec(Typespec.Const, pos);
  t.base = base;
  return t;
}

fn new_typespec_array(pos: SrcPos, elem: &Typespec, size: &Expr) -> &Typespec {
  let t = new_typespec(Typespec.Array, pos);
  t.base = elem;
  t.num_elems = size;
  return t;
}

fn new_typespec_func(pos: SrcPos, args: *&Typespec, num_args: usize, ret: &Typespec, has_varargs: bool) -> &Typespec {
  let t = new_typespec(Typespec.Func, pos);
  t.function.args = ast_dup(args, num_args * sizeof(*args));
  t.function.num_args = num_args;
  t.function.ret = ret;
  t.function.has_varargs = has_varargs;
  return t;
}

fn new_decls(decls: *&Decl, num_decls: usize) -> &Decls {
  let d: &Decls = ast_alloc(sizeof(Decls));
  d.decls = ast_dup(decls, num_decls * sizeof(*decls));
  d.num_decls = num_decls;
  return d;
}

fn new_decl(kind: Decl.Kind, pos: SrcPos, name: *const char) -> &Decl {
  let d: &Decl = ast_alloc(sizeof(Decl));
  d.kind = kind;
  d.pos = pos;
  d.name = name;
  return d;
}

fn get_decl_note(decl: &Decl, name: *const char) -> &Note {
  return get_note(&decl.notes, name);
}

fn get_note(notes: &Notes, name: *const char) -> &Note {
  for (let i: usize = 0; i < notes.num_notes; i++) {
    let note: &Note = notes.notes + i;
    if (note.name == name) {
      return note;
    }
  }
  return NULL;
}

fn get_subunion(num_items: usize, items: *AggregateItem) -> &Aggregate {
  // See if we are a struct with a subunion.
  let result: &Aggregate;
  for (let i: usize = 0; i < num_items; i++) {
    let item = items[i];
    if (item.kind == AggregateItem.Subaggregate) {
      if (item.subaggregate.kind == AggregateKind.Union) {
        // But only one subunion here is allowed.
        if (result) {
          fatal_error(item.subaggregate.pos, "Multiple unions in struct");
          return NULL;
        }
        result = item.subaggregate;
      }
    }
  }
  return result;
}

fn is_decl_foreign(decl: &Decl) -> bool {
  return get_decl_note(decl, foreign_name) != NULL;
}

fn new_decl_enum(pos: SrcPos, name: *const char, type: &Typespec, items: *EnumItem, num_items: usize) -> &Decl {
  let d = new_decl(Decl.Enum, pos, name);
  d.enum_decl.type = type;
  d.enum_decl.items = ast_dup(items, num_items * sizeof(*items));
  d.enum_decl.num_items = num_items;
  return d;
}

fn new_aggregate(
  pos: SrcPos, kind: AggregateKind, items: *AggregateItem, num_items: usize,
) -> &Aggregate {
  let aggregate: &Aggregate = ast_alloc(sizeof(Aggregate));
  aggregate.pos = pos;
  aggregate.kind = kind;
  aggregate.items = ast_dup(items, num_items * sizeof(*items));
  if (items) {
    // This is safe for our usage, but how to define generally?
    buf_free((:*&void)&items);
  }
  aggregate.num_items = num_items;
  return aggregate;
}

fn new_decl_aggregate(
  pos: SrcPos, kind: Decl.Kind, name: *const char, params: DeclSlice,
  aggregate: &Aggregate,
) -> &Decl {
  #assert(kind == Decl.Struct || kind == Decl.Union);
  let d = new_decl(kind, pos, name);
  if (params.length) {
    d.type_params.length = params.length;
    d.type_params.items =
      ast_dup(params.items, params.length * sizeof(*params.items));
    buf_free((:*&void)&params.items);
  }
  d.aggregate = aggregate;
  return d;
}

fn new_decl_var(pos: SrcPos, name: *const char, type: &Typespec, expr: &Expr) -> &Decl {
  let d = new_decl(Decl.Var, pos, name);
  d.var_decl.type = type;
  d.var_decl.expr = expr;
  return d;
}

fn new_decl_func(pos: SrcPos, name: *const char, params: *FuncParam, num_params: usize, ret_type: &Typespec, has_varargs: bool, block: StmtList) -> &Decl {
  let d = new_decl(Decl.Func, pos, name);
  d.function.params = ast_dup(params, num_params * sizeof(*params));
  d.function.num_params = num_params;
  d.function.ret_type = ret_type;
  d.function.has_varargs = has_varargs;
  d.function.block = block;
  return d;
}

fn new_decl_const(pos: SrcPos, name: *const char, type: &Typespec, expr: &Expr) -> &Decl {
  let d = new_decl(Decl.Const, pos, name);
  d.const_decl.type = type;
  d.const_decl.expr = expr;
  return d;
}

fn new_decl_typedef(pos: SrcPos, name: *const char, val: &Typespec) -> &Decl {
  let d = new_decl(Decl.Typedef, pos, name);
  d.typedef_decl.val = val;
  return d;
}

fn new_decl_note(pos: SrcPos, note: Note) -> &Decl {
  let d = new_decl(Decl.Note, pos, NULL);
  d.note = note;
  return d;
}

fn new_decl_import(pos: SrcPos, rename_name: *const char, is_relative: bool, names: **const char, num_names: usize, import_all: bool, items: *ImportItem, num_items: usize) -> &Decl {
  let d = new_decl(Decl.Import, pos, NULL);
  d.name = rename_name;
  d.import_decl.is_relative = is_relative;
  d.import_decl.names = ast_dup(names, num_names * sizeof(*names));
  d.import_decl.num_names = num_names;
  d.import_decl.import_all = import_all;
  d.import_decl.items = ast_dup(items, num_items * sizeof(*items));
  d.import_decl.num_items = num_items;
  return d;
}

fn new_expr(kind: Expr.Kind, pos: SrcPos) -> &Expr {
  let e: &Expr = ast_alloc(sizeof(Expr));
  e.kind = kind;
  e.pos = pos;
  return e;
}

fn new_expr_paren(pos: SrcPos, expr: &Expr) -> &Expr {
  let e = new_expr(Expr.Paren, pos);
  e.paren.expr = expr;
  return e;
}

fn new_expr_sizeof_expr(pos: SrcPos, expr: &Expr) -> &Expr {
  let e = new_expr(Expr.SizeofExpr, pos);
  e.sizeof_expr = expr;
  return e;
}

fn new_expr_sizeof_type(pos: SrcPos, type: &Typespec) -> &Expr {
  let e = new_expr(Expr.SizeofType, pos);
  e.sizeof_type = type;
  return e;
}

fn new_expr_typeof_expr(pos: SrcPos, expr: &Expr) -> &Expr {
  let e = new_expr(Expr.TypeofExpr, pos);
  e.typeof_expr  = expr;
  return e;
}

fn new_expr_typeof_type(pos: SrcPos, type: &Typespec) -> &Expr {
  let e = new_expr(Expr.TypeofType, pos);
  e.typeof_type = type;
  return e;
}

fn new_expr_alignof_expr(pos: SrcPos, expr: &Expr) -> &Expr {
  let e = new_expr(Expr.AlignofExpr, pos);
  e.alignof_expr = expr;
  return e;
}

fn new_expr_alignof_type(pos: SrcPos, type: &Typespec) -> &Expr {
  let e = new_expr(Expr.AlignofType, pos);
  e.alignof_type = type;
  return e;
}

fn new_expr_offsetof(pos: SrcPos, type: &Typespec, name: *const char) -> &Expr {
  let e = new_expr(Expr.Offsetof, pos);
  e.offsetof_field.type = type;
  e.offsetof_field.name = name;
  return e;
}

fn new_expr_modify(pos: SrcPos, op: TokenKind, post: bool, expr: &Expr) -> &Expr {
  let e = new_expr(Expr.Modify, pos);
  e.modify.op = op;
  e.modify.post = post;
  e.modify.expr = expr;
  return e;
}

fn new_expr_int(pos: SrcPos, val: ullong, mod: TokenMod, suffix: TokenSuffix) -> &Expr {
  let e = new_expr(Expr.Int, pos);
  e.int_lit.val = val;
  e.int_lit.mod = mod;
  e.int_lit.suffix = suffix;
  return e;
}

fn new_expr_float(pos: SrcPos, start: *const char, end: *const char, val: double, suffix: TokenSuffix) -> &Expr {
  let e = new_expr(Expr.Float, pos);
  e.float_lit.start = start;
  e.float_lit.end = end;
  e.float_lit.val = val;
  e.float_lit.suffix = suffix;
  return e;
}

fn new_expr_str(pos: SrcPos, val: *const char, mod: TokenMod) -> &Expr {
  let e = new_expr(Expr.Str, pos);
  e.str_lit.val = val;
  e.str_lit.mod = mod;
  return e;
}

fn new_expr_name(pos: SrcPos, name: *const char) -> &Expr {
  let e = new_expr(Expr.Name, pos);
  e.name = name;
  return e;
}

fn new_expr_compound(pos: SrcPos, type: &Typespec, fields: *CompoundField, num_fields: usize) -> &Expr {
  let e = new_expr(Expr.Compound, pos);
  e.compound.type = type;
  e.compound.fields = ast_dup(fields, num_fields * sizeof(*fields));
  e.compound.num_fields = num_fields;
  return e;
}

fn new_expr_cast(pos: SrcPos, type: &Typespec, expr: &Expr) -> &Expr {
  let e = new_expr(Expr.Cast, pos);
  e.cast.type = type;
  e.cast.expr = expr;
  return e;
}

fn new_expr_call(pos: SrcPos, expr: &Expr, args: *&Expr, num_args: usize) -> &Expr {
  let e = new_expr(Expr.Call, pos);
  e.call.expr = expr;
  e.call.args = ast_dup(args, num_args * sizeof(*args));
  e.call.num_args = num_args;
  return e;
}

fn new_expr_index(pos: SrcPos, expr: &Expr, index: &Expr) -> &Expr {
  let e = new_expr(Expr.Index, pos);
  e.index.expr = expr;
  e.index.index = index;
  return e;
}

fn new_expr_field(pos: SrcPos, expr: &Expr, name: *const char) -> &Expr {
  let e = new_expr(Expr.Field, pos);
  e.field.expr = expr;
  e.field.name = name;
  return e;
}

fn new_expr_unary(pos: SrcPos, op: TokenKind, expr: &Expr) -> &Expr {
  let e = new_expr(Expr.Unary, pos);
  e.unary.op = op;
  e.unary.expr = expr;
  return e;
}

fn new_expr_binary(pos: SrcPos, op: TokenKind, left: &Expr, right: &Expr) -> &Expr {
  let e = new_expr(Expr.Binary, pos);
  e.binary.op = op;
  e.binary.left = left;
  e.binary.right = right;
  return e;
}

fn new_expr_ternary(pos: SrcPos, cond: &Expr, then_expr: &Expr, else_expr: &Expr) -> &Expr {
  let e = new_expr(Expr.Ternary, pos);
  e.ternary.cond = cond;
  e.ternary.then_expr = then_expr;
  e.ternary.else_expr = else_expr;
  return e;
}

fn get_stmt_note(stmt: &Stmt, name: *const char) -> &Note {
  for (let i: usize = 0; i < stmt.notes.num_notes; i++) {
    let note = stmt.notes.notes + i;
    if (note.name == name) {
      return note;
    }
  }
  return NULL;
}

fn new_stmt(kind: Stmt.Kind, pos: SrcPos) -> &Stmt {
  let s: &Stmt = ast_alloc(sizeof(Stmt));
  s.kind = kind;
  s.pos = pos;
  return s;
}

fn new_stmt_label(pos: SrcPos, label: *const char) -> &Stmt {
  let s = new_stmt(Stmt.Label, pos);
  s.label = label;
  return s;
}

fn new_stmt_goto(pos: SrcPos, label: *const char) -> &Stmt {
  let s = new_stmt(Stmt.Goto, pos);
  s.label = label;
  return s;
}

fn new_stmt_note(pos: SrcPos, note: Note) -> &Stmt {
  let s = new_stmt(Stmt.Note, pos);
  s.note = note;
  return s;
}

fn new_stmt_decl(pos: SrcPos, decl: &Decl) -> &Stmt {
  let s = new_stmt(Stmt.Decl, pos);
  s.decl = decl;
  return s;
}

fn new_stmt_return(pos: SrcPos, expr: &Expr) -> &Stmt {
  let s = new_stmt(Stmt.Return, pos);
  s.expr = expr;
  return s;
}

fn new_stmt_break(pos: SrcPos) -> &Stmt {
  return new_stmt(Stmt.Break, pos);
}

fn new_stmt_continue(pos: SrcPos) -> &Stmt {
  return new_stmt(Stmt.Continue, pos);
}

fn new_stmt_block(pos: SrcPos, block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.Block, pos);
  s.block = block;
  return s;
}

fn new_stmt_close(pos: SrcPos, tag: Stmt.Kind) -> &Stmt {
  let s = new_stmt(Stmt.Close, pos);
  s.tag = tag;
  return s;
}

fn new_stmt_if(pos: SrcPos, init: &Stmt, cond: &Expr, then_block: StmtList, elseifs: *ElseIf, num_elseifs: usize, else_block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.If, pos);
  s.if_stmt.init = init;
  s.if_stmt.cond = cond;
  s.if_stmt.then_block = then_block;
  s.if_stmt.elseifs = ast_dup(elseifs, num_elseifs * sizeof(*elseifs));
  s.if_stmt.num_elseifs = num_elseifs;
  s.if_stmt.else_block = else_block;
  return s;
}

fn new_stmt_while(pos: SrcPos, cond: &Expr, block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.While, pos);
  s.while_stmt.cond = cond;
  s.while_stmt.block = block;
  return s;
}

fn new_stmt_do_while(pos: SrcPos, cond: &Expr, block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.DoWhile, pos);
  s.while_stmt.cond = cond;
  s.while_stmt.block = block;
  return s;
}

fn new_stmt_for(pos: SrcPos, init: &Stmt, cond: &Expr, next: &Stmt, block: StmtList) -> &Stmt {
  let s = new_stmt(Stmt.For, pos);
  s.for_stmt.init = init;
  s.for_stmt.cond = cond;
  s.for_stmt.next = next;
  s.for_stmt.block = block;
  return s;
}

fn new_stmt_switch(pos: SrcPos, expr: &Expr, cases: *SwitchCase, num_cases: usize) -> &Stmt {
  let s = new_stmt(Stmt.Switch, pos);
  s.switch_stmt.expr = expr;
  s.switch_stmt.cases = ast_dup(cases, num_cases * sizeof(*cases));
  s.switch_stmt.num_cases = num_cases;
  return s;
}

fn new_stmt_assign(pos: SrcPos, op: TokenKind, left: &Expr, right: &Expr) -> &Stmt {
  let s = new_stmt(Stmt.Assign, pos);
  s.assign.op = op;
  s.assign.left = left;
  s.assign.right = right;
  return s;
}

fn new_stmt_init(pos: SrcPos, name: *const char, is_mut: bool, type: &Typespec, expr: &Expr) -> &Stmt {
  let s = new_stmt(Stmt.Init, pos);
  s.init.name = name;
  s.init.is_mut = is_mut;
  s.init.type = type;
  s.init.expr = expr;
  return s;
}

fn new_stmt_expr(pos: SrcPos, expr: &Expr) -> &Stmt {
  let s = new_stmt(Stmt.Expr, pos);
  s.expr = expr;
  return s;
}

// #undef AST_DUP
