Case* = for<Value> be struct of
    claim: Claim
    value: Value
end

Claim* = Either<Void, Void>

Either* = for<YesValue, NoValue> be Yes<YesValue> | No<NoValue>

Function* = for<ArgTypes, ReturnType> be class of
    # TODO
end

Int32* = class of
    add = for(other: Int32): Int32 be native()
end

List* = for<Item> be class of
    # TODO
end

No* = for<Value> be ordered struct of
    value: Value
end

Text*: Type = native()

Type* = class of
    union = for(a: Type, b: Type): Type be native()
end

Void*: Type = native()

Yes* = for<Value> be ordered struct of
    value: Value
end

branch* = for<Value>(cases...: List<Case<Value>>): Value be native()

case* = for<Value>(claim: Claim, value: Value): Case<Value> be {claim, value}

class* = for() be native()

else* = for<Value>(value: Value): Case<Value> be case true value

false* = No(void)

native* = for() be native()

ordered* = for() be native()

# print*: Function<[Text], [Void]> = native()
# print*: Function<[Text], Void> = native()
# print*: Function<Text, Void> = native()
# print*: for(Text): Void = native()
print* = for(text: Text): Void be native()

struct* = for() be native()

true* = Yes(void)

void*: Void = native()
