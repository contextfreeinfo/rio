abstract* = for void be extern

Array* = for Item:Type size:Int be extern

Claim* = Maybe Void

Class* = struct with
    face:Interface
    fields:(List Field)
end

describe* = for Value:Type be for value:Value :String be extern

Either* = for YesValue:Type NoValue:Type be union of
    Yes YesValue
    No NoValue
end

false* = no void

Field* = struct with
    # TODO This needs dynamic typing and sizing for `type` and `default`.
    name:Text
    type:Type
    default:(Maybe type)
    offset:Int
end

Int* = class with
    add* = for other:Int :Int be extern
    eq* = for other:Int :Claim be extern
    ge* = for other:Int :Claim be extern
    gt* = for other:Int :Claim be extern
    le* = for other:Int :Claim be extern
    lt* = for other:Int :Claim be extern
    ne* = for other:Int :Claim be extern
    sub* = for other:Int :Int be extern
end

Interface* = struct with
    name:Text
    # TODO constructor separate?
    # methods:(List Function)
end

log* = for Value:Type be for value:Value be extern
# TODO Also think and cry for log levels?

Maybe* = for Value:Type be Either Value Void

extern* = for void be extern

No* = for Value:Type be struct with
    value:Value
end

no* = for Value:Type be for value:Value be No {value}

null* = false

Pair* = for Key:Type Value:Type be struct with
    key:Key
    value:Value
end

pair* = for Key:Type Value:Type be for key:Key value:Value be Pair {key, value}

Predicate* = for Subject:Type be
    interface for subject:Subject :Claim be abstract
end

Struct* = struct with
    name:Text
    fields:(List Field)
end

struct* = extern

true* = yes void

Text*:Type = extern

Type* = for Bound:(Maybe Type) be extern

# Type* = union ... ???

Val*:Type = for Ref:Type be extern
# For expanded value forms of class types?

Void*:Type = extern

void*:Void = extern

Yes* = for Value:Type be struct with
    value:Value
end

yes* = for Value:Type be for value:Value be Yes {value}
